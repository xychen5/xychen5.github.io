<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=victor+mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"xychen5.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12,"width":300},"copycode":false,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"changyan":{"text":"Load Disqus","order":-2},"gitalk":{"order":-1}}},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"zoomIn","post_header":"zoomIn","post_body":"zoomIn","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

  <meta name="description" content="Freiheit Weht">
<meta property="og:type" content="website">
<meta property="og:title" content="LuftBallon">
<meta property="og:url" content="https://xychen5.github.io/page/3/index.html">
<meta property="og:site_name" content="LuftBallon">
<meta property="og:description" content="Freiheit Weht">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="xychen5">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://xychen5.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LuftBallon</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LuftBallon</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-arrow-right fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="xychen5"
      src="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
  <p class="site-author-name" itemprop="name">xychen5</p>
  <div class="site-description" itemprop="description">Freiheit Weht</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">69</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/xychen5?tab=repositories" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xychen5?tab&#x3D;repositories" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cxynash5@gmail.com" title="E-Mail → mailto:cxynash5@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2022/03/20/lcDP1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/20/lcDP1/" class="post-title-link" itemprop="url">lcDP1 - 动态规划1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-20 19:14:43" itemprop="dateCreated datePublished" datetime="2022-03-20T19:14:43+08:00">2022-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1 动态规划"></a>1 动态规划</h1><p>从背包问题开始：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/93857890">https://zhuanlan.zhihu.com/p/93857890</a><br>区间dp等等：</li>
<li><a target="_blank" rel="noopener" href="https://oi-wiki.org/dp/interval/">https://oi-wiki.org/dp/interval/</a></li>
</ul>
<p>最重要的是，能够用dp数组，1到3维度一般，去表示最终结果，对于具体的题目，dp[i][j]表示什么意思，将成为解答的关键</p>
<p>很多动态规划都可以使用带记忆化的搜索去做</p>
<h1 id="2-例题"><a href="#2-例题" class="headerlink" title="2 例题"></a>2 例题</h1><h2 id="0410splitArrayMinMax-分割出最小的子数组最大值"><a href="#0410splitArrayMinMax-分割出最小的子数组最大值" class="headerlink" title="0410splitArrayMinMax 分割出最小的子数组最大值"></a>0410splitArrayMinMax 分割出最小的子数组最大值</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-array-largest-sum/">https://leetcode-cn.com/problems/split-array-largest-sum/</a></p>
<h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><p>参考官方解答：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-array-largest-sum/solution/fen-ge-shu-zu-de-zui-da-zhi-by-leetcode-solution/">https://leetcode-cn.com/problems/split-array-largest-sum/solution/fen-ge-shu-zu-de-zui-da-zhi-by-leetcode-solution/</a></p>
<ul>
<li>1 dp: 首先搞明白动态规划的单元，注意，不仅仅是说增加一个元素，对分割造成了什么影响，而且还要考虑，不通的分割数目，本题目是分割，那么一定是分割数目以及分割对象带来的变化为dp的状态迁移， dp[i][j] means: res of: nums[:i] to be splited in j’s segments, dp[i][j] = max {dp[k][j-1], sum[k+1, i] | j &lt;= k &lt;= i - 1}，所以</li>
<li>2 二分查找法：这样，判断一个数字能否作为分割m个子数组的方案？应该很好判断，顺序遍历即可<ul>
<li>2.1 那么记录该数字为x，最小就是数组里的最大值，最大即为数组和，于是仅仅需要用二分法，从这个范围中找出该数字即可</li>
<li>2.2 具体如何二分？若x过于小了，会导致分割数目太大，然后我们就知道往大处搜索，反之同理</li>
</ul>
</li>
<li>3 二分法的标准写法：<ul>
<li>3.1 注意用&gt;&gt;代表除2，尤其是考虑负数时候有区别</li>
<li>3.2 注意当往大地方搜，st = mid+1，往小地方则不用，不然可能导致ed漏搜索<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> lastCheck = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(st &lt; ed) &#123;</span><br><span class="line">    x = (st + ed) &gt;&gt; <span class="number">1</span>; <span class="comment">// means: floor of (st + ed)</span></span><br><span class="line">    lastCheck = <span class="built_in">xIsLarge</span>(x, nums, m);</span><br><span class="line">    <span class="keyword">if</span>(lastCheck) &#123;</span><br><span class="line">        ed = x; <span class="comment">// when ed - st = 1, (st + ed) &gt;&gt; 1 == st</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        st = x + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> st;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">splitArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; preSum = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            preSum.<span class="built_in">push_back</span>(preSum.<span class="built_in">back</span>() + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// // dp[i][j] means: res of: nums[:i] to be splited in j&#x27;s segments</span></span><br><span class="line">        <span class="comment">// // dp[i][j] = max &#123;dp[k][j-1], sum[k+1, i] | j &lt;= k &lt;= i - 1&#125;</span></span><br><span class="line">        <span class="comment">// vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(m+1, INT_MAX));</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[1][1] = nums[0];</span></span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt;= n; ++i) &#123;</span></span><br><span class="line">        <span class="comment">//     for(int j = 1; j &lt;= min(m, i); ++j) &#123;</span></span><br><span class="line">        <span class="comment">//         if(j == 1) &#123;</span></span><br><span class="line">        <span class="comment">//             dp[i][1] = preSum[i] - preSum[0];</span></span><br><span class="line">        <span class="comment">//             continue;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         int tmpMaxMin = 0;</span></span><br><span class="line">        <span class="comment">//         for(int k = j - 1; k &lt; i; ++k) &#123;</span></span><br><span class="line">        <span class="comment">//             tmpMaxMin = max(dp[k][j-1], preSum[i] - preSum[k]);</span></span><br><span class="line">        <span class="comment">//             dp[i][j] = min(dp[i][j], tmpMaxMin);</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return dp[n][m];</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// binsearch x as the min max res</span></span><br><span class="line">        <span class="type">int</span> st = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> ed = preSum[n];</span><br><span class="line">        <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> lastCheck = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(st &lt; ed) &#123;</span><br><span class="line">            x = (st + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            lastCheck = <span class="built_in">xIsLarge</span>(x, nums, m);</span><br><span class="line">            <span class="keyword">if</span>(lastCheck) &#123;</span><br><span class="line">                ed = x; <span class="comment">// when ed - st = 1, (st + ed) &gt;&gt; 1 == st</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st = x + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// at last, st == ed</span></span><br><span class="line">        <span class="keyword">return</span> st;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">xIsLarge</span><span class="params">(<span class="type">int</span> x, vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curSum + nums[i] &gt; x)  &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                curSum = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curSum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;&gt;&gt; x/cnt is&quot; &lt;&lt; x &lt;&lt; &quot;/&quot; &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0403frogCrossRiver-青蛙过河"><a href="#0403frogCrossRiver-青蛙过河" class="headerlink" title="0403frogCrossRiver 青蛙过河"></a>0403frogCrossRiver 青蛙过河</h2><h3 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/frog-jump/">https://leetcode-cn.com/problems/frog-jump/</a></p>
<h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 动态规划：首先明白动态规划最终是指向结果的，于是，定义dp[i][k]，为到达i的最后一跳长度为k，是否能够跳到目的地<ul>
<li>1.1 首先有疑问：那k岂不是max(stone) - min(stone)，那k就会非常大，不合理啊？错，因为每一跳长度最多增加1，然而你最多有n-1跳，于是 k &lt;= n-1</li>
<li>1.2 状态转移: dp[i][k] = dp[j][k] || dp[j][k-1] || dp[j][k+1]，j就是i的上一跳，那么我们可以直到，j到i，k=stone[i] - stone[j]</li>
<li>1.3 需要注意到上面的状态转移: 因为是从j跳，必须保证: k &lt;= j+1，因为你从第j个石头开始跳，最远长度就是j+1</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// jump to i, and last jump dis</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">jump</span>(n , <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        jump[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the i th jump len &lt;= i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(stones[i] - stones[i - <span class="number">1</span>] &gt; i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp, from j jump to i</span></span><br><span class="line">        <span class="type">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> k = stones[i] - stones[j];</span><br><span class="line">                <span class="comment">// cout &lt;&lt; j &lt;&lt; &quot; -&gt; &quot; &lt;&lt; i &lt;&lt; &quot; &#x27;s dis: &quot; &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span>(k &gt; j + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; jump[j].size() &lt;&lt; &quot; / &quot; &lt;&lt; k + 1 &lt;&lt; &quot; jump[j][k] || jump[j][k-1] || jump[j][k+1] &quot; &lt;&lt; jump[j][k] &lt;&lt; jump[j][k-1] &lt;&lt; jump[j][k+1] &lt;&lt; endl;</span></span><br><span class="line">                jump[i][k] = jump[j][k] || jump[j][k<span class="number">-1</span>] || jump[j][k+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(i == n - <span class="number">1</span> &amp;&amp; jump[i][k]) &#123;</span><br><span class="line">                    res = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0488zumaGame-祖玛游戏"><a href="#0488zumaGame-祖玛游戏" class="headerlink" title="0488zumaGame 祖玛游戏"></a>0488zumaGame 祖玛游戏</h2><h3 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zuma-game/">https://leetcode-cn.com/problems/zuma-game/</a></p>
<h3 id="2-解题思路-2"><a href="#2-解题思路-2" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 对于hand中，每次挑选一个去填补到board中，然后消除board中的球，接着用剩下的hand再选择一个，到board里中去消除，dfs去遍历即可</li>
<li>2 使用记忆化搜索 memo[board + “ “ + hand]记录了对应的board和hand的结果，为何” “是必须的？<ul>
<li>2.1 考虑以下例子：</li>
<li>2.2 可以知道必须在中间的RR中先插入B，那么假设我们的第一次搜索从第一个字符G，第二个字符是B，开始，那么我们的memo中会有结果(若是不带空格)：memo[RRYGGYYRBRYYGGYRRGGBB]，这样当第一个字符变成B，我们会在memo发现一个失败的方法直接返回结果，导致改题变成没有结果，同时这个例子也解释了为何减枝的条件3需要在两个相同字符之间插入字符，如果带了空格，就能够绝对避免这个问题，因为：</li>
<li>memo[RRYGGYYRBRYYGGYRR GGB] 和 memo[RRYGGYYRBRYYGGYRR GGBB]就能够区分开<blockquote>
<p>“RRYGGYYRRYYGGYRR”<br><br>“GGBBB”</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> allBallsCnt = <span class="number">-1</span>;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinStep</span><span class="params">(string board, string hand)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// simulate this game</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        allBallsCnt = hand.<span class="built_in">size</span>();</span><br><span class="line">        res = <span class="built_in">bfs</span>(board, hand);</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(string board, string hand)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// space mustn&#x27;t be eliminated! it&#x27;s neutig!</span></span><br><span class="line">        <span class="keyword">if</span>(memo.<span class="built_in">find</span>(board + <span class="string">&quot; &quot;</span> + hand) != memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[board + <span class="string">&quot; &quot;</span> + hand];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == board.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> allBallsCnt - hand.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == hand.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> useRes = INT_MAX;</span><br><span class="line">        string lastTarBallStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; hand.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">            string nextHand = hand.<span class="built_in">substr</span>(<span class="number">0</span>, k) + hand.<span class="built_in">substr</span>(k + <span class="number">1</span>);</span><br><span class="line">            string tarBallStr = hand.<span class="built_in">substr</span>(k, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// case1: cut the same ball</span></span><br><span class="line">            <span class="keyword">if</span>(tarBallStr == lastTarBallStr) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// use this char, find put pos</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= board.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="comment">// case2: only insert at the start of str with same chars</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; board[i - <span class="number">1</span>] == hand[k]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// case3: only put when cur is equal current || when cur is not equal to two continuous same chars</span></span><br><span class="line">                <span class="keyword">if</span>(i &lt; board.<span class="built_in">size</span>() &amp;&amp; board[i] == hand[k] || \</span><br><span class="line">                i &gt; <span class="number">0</span> &amp;&amp; board[i] == board[i<span class="number">-1</span>] &amp;&amp; hand[k] != board[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                    string tmpBoard1 = board;</span><br><span class="line">                    tmpBoard1.<span class="built_in">insert</span>(i, tarBallStr);</span><br><span class="line">                    <span class="comment">// reduce repeat balls</span></span><br><span class="line">                    <span class="built_in">reduceRepeat</span>(tmpBoard1);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// put to tarBall left and right</span></span><br><span class="line">                    <span class="type">int</span> lRes = <span class="built_in">bfs</span>(tmpBoard1, nextHand);</span><br><span class="line"></span><br><span class="line">                    useRes = <span class="built_in">min</span>(lRes, useRes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            lastTarBallStr = tarBallStr;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[board + <span class="string">&quot; &quot;</span> + hand] = useRes;</span><br><span class="line">        <span class="keyword">return</span> useRes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">reduceRepeat</span><span class="params">(string&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;reducing &quot; &lt;&lt; board &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">while</span>(board.<span class="built_in">length</span>() &gt; <span class="number">0</span> &amp;&amp; idx &lt; board.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> st = idx, cur = st;</span><br><span class="line">            <span class="type">char</span> head = board[st];</span><br><span class="line">            <span class="keyword">while</span>(++cur &lt; board.<span class="built_in">length</span>() &amp;&amp; board[cur] == head) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur - st &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                board.<span class="built_in">erase</span>(st, cur - st);</span><br><span class="line">                idx = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                idx = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;after redu &quot; &lt;&lt; board &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0552checkRecord-学生出勤记录"><a href="#0552checkRecord-学生出勤记录" class="headerlink" title="0552checkRecord 学生出勤记录"></a>0552checkRecord 学生出勤记录</h2><h3 id="1-题目-3"><a href="#1-题目-3" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/student-attendance-record-ii/">https://leetcode-cn.com/problems/student-attendance-record-ii/</a></p>
<h3 id="2-解题思路-3"><a href="#2-解题思路-3" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 初步思路 dp[i][j]作为直到i天，以j为出勤记录的所有记录数，但是会发现无法处理连续的L的情况</li>
<li>2 更改，采用官方题解思路： dp[i][j]为以连续j个l为结尾的记录数，首先只考虑PL，但是此方法不行，因为，A可以隔断两个L，所以，如果先算出所有PL的方法，然后将A插入，那么结果一定会比用A去隔断两个L少。</li>
<li>3 官方接单： dp[i][j][k]是含有j个A的k个L为结尾的记录数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bigInt = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">checkRecord</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">3</span> : <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// we can use A to interrupt the LLL, so we calculate A after only PL</span></span><br><span class="line">        <span class="comment">// // n&#x27;s day without &#x27;A&#x27;</span></span><br><span class="line">        <span class="comment">// vector&lt;vector&lt;long long&gt;&gt; dp(n + 1, vector&lt;long long&gt;(3, 0));</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// // dp[i][j], j means end with n&#x27;s L</span></span><br><span class="line">        <span class="comment">// dp[1][0] = 1; dp[1][1] = 1; dp[1][2] = 0;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i = 2; i &lt;= n; ++i) &#123;</span></span><br><span class="line">        <span class="comment">//     // end with p</span></span><br><span class="line">        <span class="comment">//     dp[i][0] = dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2];</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">//     // ent with l</span></span><br><span class="line">        <span class="comment">//     dp[i][1] = (dp[i - 1][0]) % bigInt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//     // end with ll</span></span><br><span class="line">        <span class="comment">//     dp[i][2] = dp[i - 1][1] % bigInt;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; th: P/L: &quot; &lt;&lt; dp[i][1] &lt;&lt; &quot; &quot; &lt;&lt; dp[i][0] &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// // when there is a A:</span></span><br><span class="line">        <span class="comment">// long long res = 0;</span></span><br><span class="line">        <span class="comment">// res += ((dp[n][0] + dp[n][1]) % bigInt + dp[n][2]) % bigInt;</span></span><br><span class="line">        <span class="comment">// res += (((dp[n-1][0] + dp[n-1][1]) % bigInt + dp[n-1][2]) % bigInt * n) % bigInt;</span></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="comment">// n&#x27;s day without &#x27;A&#x27;</span></span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt;(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">3</span>, <span class="number">0</span>)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[i][j], j means end with n&#x27;s L</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="comment">// end with p</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; ++k) &#123;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = (dp[i][j][<span class="number">0</span>] + dp[i - <span class="number">1</span>][j][k]) % bigInt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// end with a</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; ++k) &#123;</span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">0</span>] = (dp[i][<span class="number">1</span>][<span class="number">0</span>] + dp[i<span class="number">-1</span>][<span class="number">0</span>][k]) % bigInt;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ent with l</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; ++k) &#123;</span><br><span class="line">                    dp[i][j][k] = (dp[i][j][k] + dp[i - <span class="number">1</span>][j][k<span class="number">-1</span>]) % bigInt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k) &#123;</span><br><span class="line">                res = (res + dp[n][j][k]) % bigInt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0600countUncontinous1-不含连续1的非负整数"><a href="#0600countUncontinous1-不含连续1的非负整数" class="headerlink" title="0600countUncontinous1 不含连续1的非负整数"></a>0600countUncontinous1 不含连续1的非负整数</h2><h3 id="1-题目-4"><a href="#1-题目-4" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/">https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/</a></p>
<h3 id="2-解题思路-4"><a href="#2-解题思路-4" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 解题思路：<ul>
<li>1.1 很显然的动态规划，首先考虑问题： 给你一个二进制数字a = 2^n，判断从0到a有多少个数字不含有连续的两个1？动态规划即可：<ul>
<li>dp[len][0] = dp[len - 1][1] + dp[len - 1][0];</li>
<li>dp[len][1] = dp[len - 1][0];</li>
<li>其中dp[len][0]表示长度为len然后以0开始的二进制数字的集合中，含有多少个不连续为1的数字</li>
</ul>
</li>
<li>1.2 有了上述的思考，那么对于1024，32这种数字的解答就很显而易见了，比如32 = 100000，那么答案就是：首先假设最高位为0，然后res += dp[5][0] + dp[5][1]，这是所有： 0xxxx和1xxxx组成的答案，但是32是6位数字，还需要加上32本身即可</li>
<li>1.3 更近一步，对于a = 101010 和 b = 110000 这样的呢？<ul>
<li>以每一个1对结果的贡献来思考，从高位到低位这样去思考： </li>
<li>首先拿a来说，我们看最高位，和32一样的解法，接下来我们找到下一个1，那么就是变成，找以前缀为10，后缀为 0xxx 的有多少种，那么动态规划直接找出来就行，那么为什么不是1xxx，因为1xxx加上前缀10可能就大于a了，就超出了范围，那么我们接着找到下一个1，也就是前缀为1010，找0x有多少种，然后最后找不到1，看看a本身是否合理加上即可</li>
<li>对于b，首先第一个1对最终结果的贡献都是和32一样的，那么第二个1呢？很显然，<strong>遇到了连续的第二个1，意味着后面的1对答案都不会有贡献，因为以11为前缀的都是不合法的</strong>，所以仅仅需要考虑，将第二个连续的1变成0，以10为前缀，xxxx有多少中方案，很简单，就是 dp[4][0] + dp[4][1]</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findIntegers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp = n;</span><br><span class="line">        <span class="type">int</span> bit = <span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; bits = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(tmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            bits.<span class="built_in">push_back</span>(tmp &amp; <span class="number">1</span>);</span><br><span class="line">            tmp = tmp &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = bits.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(k, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// mainly for the last bit is 1</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= k - <span class="number">1</span>; ++len)&#123;</span><br><span class="line">            dp[len][<span class="number">0</span>] = dp[len - <span class="number">1</span>][<span class="number">1</span>] + dp[len - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[len][<span class="number">1</span>] = dp[len - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;dp &quot; &lt;&lt; len &lt;&lt; &quot;/0,1 = &quot; &lt;&lt; dp[len][0] &lt;&lt; &quot;,&quot; &lt;&lt; dp[len][1] &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> lastOneBitIdx = k - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// assume the biggest bit starts with 0</span></span><br><span class="line">        <span class="type">int</span> res = dp[lastOneBitIdx][<span class="number">0</span>] + dp[lastOneBitIdx][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;assume biggest bit = 0&#x27;s res : &quot; &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> mySelfOk = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(lastOneBitIdx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> nextOneBitIdx = lastOneBitIdx - <span class="number">1</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;&gt;&gt; last/next: &quot;</span> &lt;&lt; lastOneBitIdx &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; nextOneBitIdx &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;bits[next] &quot;</span> &lt;&lt; bits[nextOneBitIdx] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// find next one bit</span></span><br><span class="line">            <span class="keyword">while</span>(bits[nextOneBitIdx] != <span class="number">1</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;not 1 bit: &quot;</span> &lt;&lt; nextOneBitIdx &lt;&lt; endl;</span><br><span class="line">                -- nextOneBitIdx;</span><br><span class="line">                <span class="keyword">if</span>(nextOneBitIdx == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> res + mySelfOk;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;last/next: &quot;</span> &lt;&lt; lastOneBitIdx &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; nextOneBitIdx &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span>(lastOneBitIdx - nextOneBitIdx &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// view the bits[nextOneBitIdx] as 0</span></span><br><span class="line">                res += dp[nextOneBitIdx][<span class="number">0</span>] + dp[nextOneBitIdx][<span class="number">1</span>];</span><br><span class="line">                mySelfOk = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;+ dp &quot; &lt;&lt; nextOneBitIdx &lt;&lt; &quot;,&quot; &lt;&lt; 0 &lt;&lt; &quot; break!!!&quot; &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// view the bits[nextOneBitIdx] as 0</span></span><br><span class="line">                res += dp[nextOneBitIdx][<span class="number">0</span>] + dp[nextOneBitIdx][<span class="number">1</span>];</span><br><span class="line">                lastOneBitIdx = nextOneBitIdx;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;+ dp &quot; &lt;&lt; nextOneBitIdx &lt;&lt; &quot;,&quot; &lt;&lt; 0 &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;lastOneBitIdx is &quot; &lt;&lt; lastOneBitIdx &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;curRes = &quot; &lt;&lt; res;</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;me ok: &quot;</span> &lt;&lt; mySelfOk &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res + mySelfOk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2022/03/07/algoHierHolzerEulerPath/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/07/algoHierHolzerEulerPath/" class="post-title-link" itemprop="url">algoHierHolzerEulerPath - 半欧拉图/欧拉图的欧拉路径计算</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-07 15:09:08" itemprop="dateCreated datePublished" datetime="2022-03-07T15:09:08+08:00">2022-03-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-欧拉图基本概念："><a href="#1-欧拉图基本概念：" class="headerlink" title="1 欧拉图基本概念："></a>1 欧拉图基本概念：</h1><blockquote>
<p>圈：任选图中一个顶点为起点，沿着不重复的边，经过不重复的顶点为途径，之后又回到起点的闭合途径称为圈。</p>
</blockquote>
<blockquote>
<p>欧拉路径：通过图中所有边一次且仅一次遍历所有顶点的路径称为欧拉(Euler)路径；</p>
</blockquote>
<blockquote>
<p>欧拉回路：通过图中所有边一次且仅一次行遍所有顶点的回路称为欧拉回路；</p>
</blockquote>
<blockquote>
<p>欧拉图：具有欧拉回路的图称为欧拉图；</p>
</blockquote>
<blockquote>
<p>半欧拉图：有欧拉路径但没有欧拉回路的图称为半欧拉图。</p>
</blockquote>
<blockquote>
<p>欧拉图与半欧拉图的判定：</p>
</blockquote>
<blockquote>
<p>G是欧拉图 ⇔ G中所有顶点的度均为偶数 ⇔ G是若干个边不重的圈的并。</p>
</blockquote>
<blockquote>
<p>G是半欧拉图 ⇔ G中恰有两个奇数度顶点。</p>
</blockquote>
<ul>
<li><p>2 hierholzer算法</p>
<ul>
<li>2.1 dfs，当一个节点没邻居了</li>
<li>2.2 将节点入栈reversePath</li>
<li>2.3 dfs完成，reversePath则为逆序栈</li>
</ul>
</li>
<li><p>3 例子：<br><img src="https://media.geeksforgeeks.org/wp-content/uploads/Euler-3.jpg" alt="https://media.geeksforgeeks.org/wp-content/uploads/Euler-3.jpg"></p>
</li>
</ul>
<p>从0开始的话，那么<br>访问栈为：0 -&gt; 1 -&gt; 2 -&gt; 0, 此时reversePath可以将访问栈里的0弹出加入，则reversePath = [0, 2]<br>此时访问栈为： 0-&gt; 1 ，接着访问3，4,然后弹出4，3，1，0<br>则 reversPath = [0,2,4,3,1,0]，然后逆序则为：<br>0 1 3 4 2 0，为目标的eular path</p>
<h1 id="2-一句话总结hierhozer算法-dfs后续遍历节点的逆序为eular路径"><a href="#2-一句话总结hierhozer算法-dfs后续遍历节点的逆序为eular路径" class="headerlink" title="2 一句话总结hierhozer算法: dfs后续遍历节点的逆序为eular路径"></a>2 一句话总结hierhozer算法: dfs后续遍历节点的逆序为eular路径</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2022/03/07/lcDFS1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/07/lcDFS1/" class="post-title-link" itemprop="url">lcDFS1 - 深度优先遍历1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-07 15:05:49" itemprop="dateCreated datePublished" datetime="2022-03-07T15:05:49+08:00">2022-03-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-深度优先遍历"><a href="#1-深度优先遍历" class="headerlink" title="1 深度优先遍历"></a>1 深度优先遍历</h1><p>最常见的优化：</p>
<ul>
<li><p>1 记忆化搜索： 使用hash记录遍历起点对应的值，然后直接从hash中获得，避免重复计算</p>
</li>
<li><p>2 常见算法：<br>对于欧拉图和半欧拉图算欧拉路径：<a href="https://xychen5.github.io/2022/03/07/algoHierHolzerEulerPath/">hierholzer算法</a></p>
</li>
</ul>
<h1 id="2-例子"><a href="#2-例子" class="headerlink" title="2 例子"></a>2 例子</h1><h2 id="0332HierholzerToFindEulerPath-找欧拉路径"><a href="#0332HierholzerToFindEulerPath-找欧拉路径" class="headerlink" title="0332HierholzerToFindEulerPath 找欧拉路径"></a>0332HierholzerToFindEulerPath 找欧拉路径</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reconstruct-itinerary/">https://leetcode-cn.com/problems/reconstruct-itinerary/</a></p>
<h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><p>hierholzer算法参考：<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/hierholzers-algorithm-directed-graph/">https://www.geeksforgeeks.org/hierholzers-algorithm-directed-graph/</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34292517/article/details/105463522?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.pc_relevant_default&spm=1001.2101.3001.4242.1&utm_relevant_index=3">https://blog.csdn.net/qq_34292517/article/details/105463522?utm_medium=distribute.pc_relevant.none-task-blog-2<del>default</del>baidujs_title~default-0.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p>
<ul>
<li>1 自己的思路：<ul>
<li>1.1 主要是使用hierholzer算法找到欧拉路径，由于需要字典序，那么我们邻接表则使用优先队列来存储</li>
</ul>
</li>
<li>2 hierholzer算法<ul>
<li>2.1 dfs，当一个节点没邻居了(因为每访问一条边就删除一条边)</li>
<li>2.2 将节点入栈reversePath</li>
<li>2.3 dfs完成，reversePath则为逆序栈</li>
</ul>
</li>
<li>3 欧拉图等等理解：参考上述第二篇文章<blockquote>
<p>基本概念</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>圈：任选图中一个顶点为起点，沿着不重复的边，经过不重复的顶点为途径，之后又回到起点的闭合途径称为圈。</p>
</blockquote>
<blockquote>
<p>欧拉路径：通过图中所有边一次且仅一次遍历所有顶点的路径称为欧拉(Euler)路径；</p>
</blockquote>
<blockquote>
<p>欧拉回路：通过图中所有边一次且仅一次行遍所有顶点的回路称为欧拉回路；</p>
</blockquote>
<blockquote>
<p>欧拉图：具有欧拉回路的图称为欧拉图；</p>
</blockquote>
<blockquote>
<p>半欧拉图：有欧拉路径但没有欧拉回路的图称为半欧拉图。</p>
</blockquote>
<blockquote>
<p>欧拉图与半欧拉图的判定：</p>
</blockquote>
<blockquote>
<p>G是欧拉图 ⇔ G中所有顶点的度均为偶数 ⇔ G是若干个边不重的圈的并。</p>
</blockquote>
<blockquote>
<p>G是半欧拉图 ⇔ G中恰有两个奇数度顶点。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> edgeNums = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> nodeNums = <span class="number">-1</span>;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; nodes;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, string&gt; toStr;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// map str to int according to dictionary order</span></span><br><span class="line">        set&lt;string, std::less&lt;string&gt;&gt; airports;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vec : tickets) &#123;</span><br><span class="line">            airports.<span class="built_in">insert</span>(vec[<span class="number">0</span>]);</span><br><span class="line">            airports.<span class="built_in">insert</span>(vec[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str : airports) &#123;</span><br><span class="line">            toStr[i] = str;</span><br><span class="line">            nodes[str] = i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// construct the adj table</span></span><br><span class="line">        <span class="type">int</span> nodeNums = airports.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> edgeNums = tickets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// vector&lt;vector&lt;int&gt;&gt; table(nodeNums, vector&lt;int&gt;(0));</span></span><br><span class="line">        vector&lt;priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">table</span>(nodeNums, priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vec : tickets) &#123;</span><br><span class="line">            table[nodes[vec[<span class="number">0</span>]]].<span class="built_in">push</span>(nodes[vec[<span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; strRes;</span><br><span class="line">        vector&lt;priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">tableTmp</span>(table);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(nodes[<span class="string">&quot;JFK&quot;</span>], tableTmp, res);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; node : res) &#123;</span><br><span class="line">            strRes.<span class="built_in">push_back</span>(toStr[node]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> strRes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> st, vector&lt;priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt;&gt;&amp; map, vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!map[st].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> nextSt = map[st].<span class="built_in">top</span>();</span><br><span class="line">            map[st].<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;from to: &quot; &lt;&lt; toStr[st] &lt;&lt; &quot; -&gt; &quot; &lt;&lt; toStr[nextSt] &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">dfs</span>(nextSt, map, res);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(st);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0753crackSafe-破解保险箱-变形欧拉路"><a href="#0753crackSafe-破解保险箱-变形欧拉路" class="headerlink" title="0753crackSafe 破解保险箱(变形欧拉路)"></a>0753crackSafe 破解保险箱(变形欧拉路)</h2><h3 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/freedom-trail/">https://leetcode-cn.com/problems/freedom-trail/</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reconstruct-itinerary/">https://leetcode-cn.com/problems/reconstruct-itinerary/</a></p>
<h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 对于 n = 3, k = 3, 我们的图的节点为(k ^ (n-1)个)： 00, 01, …, 22, 然后每个节点都有k个边，这样一共是k^n个边<ul>
<li>1.1 那么如何认为走过一条边就是尝试一次密码呢？</li>
<li>1.2 比如: 00的邻接顶点为0,1,2, 那么当dfs访问从00节点到其邻接点分别组成的边为000，001，002，则他们对应的下一跳就为: 00,01,02，也就是<strong>取当前dfs访问得到的边的后n-1位</strong></li>
</ul>
</li>
<li>2 hierholzer算法<ul>
<li>2.0 选择一个节点开始dfs</li>
<li>2.1 当一个节点没邻居了</li>
<li>2.2 将节点入栈reversePath</li>
<li>2.3 dfs完成，reversePath则为逆序栈<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; kVec;</span><br><span class="line">    <span class="function">string <span class="title">crackSafe</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// since for each bit, there a k&#x27;s possiblity</span></span><br><span class="line">        <span class="comment">// so the final str&#x27;s length = k^n</span></span><br><span class="line">        <span class="comment">// consider a G, vertices are &#123;0, 1, ..., k-1&#125;</span></span><br><span class="line">        <span class="comment">// for each edge: vi -&gt; vj(vi could equal vj), </span></span><br><span class="line">        <span class="comment">// there shall be n-1&#x27;s such same edge</span></span><br><span class="line">        <span class="comment">// we just need a way to walk through the G</span></span><br><span class="line">        <span class="comment">// try hierholzer algo</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == n) &#123;</span><br><span class="line">            string tmpRes = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                tmpRes.<span class="built_in">push_back</span>(i + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tmpRes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            kVec.<span class="built_in">push_back</span>(i + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;string&gt; seen;</span><br><span class="line">        unordered_map&lt;string, vector&lt;<span class="type">char</span>&gt;&gt; graph;</span><br><span class="line">        <span class="built_in">buildGraph</span>(<span class="string">&quot;&quot;</span>, n - <span class="number">1</span>, graph);</span><br><span class="line">        </span><br><span class="line">        <span class="function">string <span class="title">stStr</span><span class="params">(n<span class="number">-1</span>, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">hierholzer</span>(stStr, graph, res, seen);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// when n=3, k=3, we start from &quot;00&quot; node, so we add reverse of &quot;00&quot; to the end of the res, cause hierholzer produce a reverse eular path (start from &quot;00&quot;, end to &quot;00&quot;)</span></span><br><span class="line">        res += stStr;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildGraph</span><span class="params">(string tmp, <span class="type">int</span> leftBitNum, unordered_map&lt;string, vector&lt;<span class="type">char</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == leftBitNum) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;len: &quot; &lt;&lt; leftBitNum &lt;&lt; &quot;finish node: &quot; &lt;&lt; tmp &lt;&lt; endl;</span></span><br><span class="line">            graph[tmp] = kVec;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> st = <span class="number">0</span>; st &lt; k; ++st) &#123;</span><br><span class="line">            <span class="built_in">buildGraph</span>(tmp + kVec[st], leftBitNum<span class="number">-1</span>, graph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hierholzer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    string st, </span></span></span><br><span class="line"><span class="params"><span class="function">    unordered_map&lt;string, vector&lt;<span class="type">char</span>&gt;&gt;&amp; graph, </span></span></span><br><span class="line"><span class="params"><span class="function">    string&amp; res, </span></span></span><br><span class="line"><span class="params"><span class="function">    unordered_set&lt;string&gt;&amp; seen)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;doing : &quot; &lt;&lt; st &lt;&lt; endl;</span></span><br><span class="line">        <span class="type">bool</span> hasOut = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> edIdx = <span class="number">0</span>; edIdx &lt; k; ++edIdx) &#123;</span><br><span class="line">            <span class="function">string <span class="title">curEdge</span><span class="params">(st)</span></span>;</span><br><span class="line">            curEdge.<span class="built_in">push_back</span>(graph[st][edIdx]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(seen.<span class="built_in">count</span>(curEdge)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            hasOut = <span class="literal">true</span>;</span><br><span class="line">            string nextSt = curEdge.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;st -&gt; nextSt: &quot; &lt;&lt; st &lt;&lt; &quot; -&gt; &quot; &lt;&lt; nextSt &lt;&lt; endl;</span></span><br><span class="line">            seen.<span class="built_in">insert</span>(curEdge);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;see edge: &quot; &lt;&lt; curEdge &lt;&lt; endl; </span></span><br><span class="line">            <span class="built_in">hierholzer</span>(nextSt, graph, res, seen); <span class="comment">// post order</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(graph[st][edIdx]); <span class="comment">// hierholzer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="0514wayOfFreedom-自由之路"><a href="#0514wayOfFreedom-自由之路" class="headerlink" title="0514wayOfFreedom 自由之路"></a>0514wayOfFreedom 自由之路</h2><h3 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/freedom-trail/">https://leetcode-cn.com/problems/freedom-trail/</a></p>
<h3 id="2-解题思路-2"><a href="#2-解题思路-2" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 首先考虑到，key中的每一个字符，环的所有同种字符的所有位置都是遍历的可能<ul>
<li>1.1 于是使用dfs去尝试对于key的一个字符的每个位置即可，然后讲每个位置得到的结果比较取一个最小值</li>
<li>1.2 1.1中提到的算法肯定是有问题的，比如key： abc， 然后ring: aaabbbccc<ul>
<li>会出现哪种情况呢？ ring中a的三个位置都会搜索，然后对于剩下的key和ring bc以及bbbccc会由于a有三个位置而搜索了三遍，所以需要记忆化搜索</li>
</ul>
</li>
<li>1.3 使用memo[i][j]记录： key[i:]和ring[j:]对应的最小步数即可</li>
</ul>
</li>
<li>2 经过1的思考，也较为容易知道，本题目，动态规划也能做</li>
<li>3 <strong>写代码的教训，由于我将dfsmemo写好，然后调用dfs的地方也改了，但是依然超时？</strong><ul>
<li>3.1 <strong>因为dfsmemo递归调用不是自身，而是dfs函数，所以务必及时清理不需要的代码</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ringLen = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> keyLen = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRotateSteps</span><span class="params">(string ring, string key)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, vector&lt;<span class="type">int</span>&gt;&gt; ringMap;</span><br><span class="line">        ringLen = ring.<span class="built_in">length</span>();</span><br><span class="line">        keyLen = key.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : ring) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == ringMap.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; tmp = &#123;pos&#125;;</span><br><span class="line">                ringMap[c] = tmp;         </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ringMap[c].<span class="built_in">push_back</span>(pos);</span><br><span class="line">            &#125;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(keyLen, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(ringLen, INT_MAX));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfsMemo</span>(<span class="number">0</span>, <span class="number">0</span>, ringMap, key, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no memo dfs, too slow</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> tar, <span class="type">int</span> markPos, unordered_map&lt;<span class="type">char</span>, vector&lt;<span class="type">int</span>&gt;&gt;&amp; ringMap, string&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tar == key.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> minStep = INT_MAX;</span><br><span class="line">        <span class="comment">// for cur key char, try ervery possible way on the ring</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> tarPos : ringMap[key[tar]]) &#123;</span><br><span class="line">            <span class="type">int</span> curStep = <span class="built_in">minDis</span>(tarPos, markPos); <span class="comment">// rotate</span></span><br><span class="line">            curStep += <span class="number">1</span>; <span class="comment">// write</span></span><br><span class="line"></span><br><span class="line">            minStep = <span class="built_in">min</span>(</span><br><span class="line">                minStep,</span><br><span class="line">                <span class="built_in">dfs</span>(tar + <span class="number">1</span>, tarPos, ringMap, key) + curStep</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minStep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// memo version</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfsMemo</span><span class="params">(<span class="type">int</span> tar, <span class="type">int</span> markPos, unordered_map&lt;<span class="type">char</span>, vector&lt;<span class="type">int</span>&gt;&gt;&amp; ringMap, string&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tar == key.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(INT_MAX != memo[tar][markPos]) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[tar][markPos];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for cur key char, try ervery possible way on the ring</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> tarPos : ringMap[key[tar]]) &#123;</span><br><span class="line">            <span class="type">int</span> curStep = <span class="built_in">minDis</span>(tarPos, markPos); <span class="comment">// rotate</span></span><br><span class="line">            curStep += <span class="number">1</span>; <span class="comment">// write</span></span><br><span class="line">            memo[tar][markPos] = <span class="built_in">min</span>(</span><br><span class="line">                memo[tar][markPos],</span><br><span class="line">                <span class="built_in">dfsMemo</span>(tar + <span class="number">1</span>, tarPos, ringMap, key, memo) + curStep</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;memo ing: &quot; &lt;&lt; tar &lt;&lt; &quot;, &quot; &lt;&lt; markPos &lt;&lt; &quot;: &quot; &lt;&lt; memo[tar][markPos] &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> memo[tar][markPos];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDis</span><span class="params">(<span class="type">int</span> tarPos, <span class="type">int</span> markPos)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> gt = <span class="built_in">max</span>(tarPos, markPos);</span><br><span class="line">        <span class="type">int</span> lt = <span class="built_in">min</span>(tarPos, markPos);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(gt - lt, lt + ringLen - gt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="0968minCameraCover-监控二叉树"><a href="#0968minCameraCover-监控二叉树" class="headerlink" title="0968minCameraCover 监控二叉树"></a>0968minCameraCover 监控二叉树</h2><h3 id="1-题目-3"><a href="#1-题目-3" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-cameras/submissions/">https://leetcode-cn.com/problems/binary-tree-cameras/submissions/</a></p>
<h3 id="2-解题思路-3"><a href="#2-解题思路-3" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 首先得在思考的过程中，理解改题目的本质就是，<ul>
<li>1.1 在dfs的过程中，在每个节点可以放置或者不放置相机，重要的是，如何去体现放置还是不放置相机</li>
<li>1.2 如何提现呢？很简单，比如root放置，然后你想让它的两个子节点都不放置，那么直接递归调用两个子节点的后代即可，具体看代码即可</li>
<li>1.3 那么对于每个节点，有几种放置相机的可能呢？<ul>
<li>一共三种，要么root，要么left，要么right，然后取最小代价即可，这里以选择left子节点仔细说明：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// choosing: right </span></span><br><span class="line"><span class="type">int</span> tmpRightCover = <span class="built_in">min</span>(</span><br><span class="line">    <span class="comment">// r的监控器对r的两个子节点都有监控作用，于是直接去计算两个子节点的子节点</span></span><br><span class="line">    <span class="number">1</span> + <span class="built_in">minCameraCover</span>(r_rll) + <span class="built_in">minCameraCover</span>(r_rlr) + <span class="built_in">minCameraCover</span>(r_rrl) + <span class="built_in">minCameraCover</span>(r_rrr) + <span class="built_in">minCameraCover</span>(r_l),</span><br><span class="line">    <span class="built_in">min</span>(</span><br><span class="line">        <span class="comment">// r的监控器对r的两个子节点中的右孩子有监控作用，于是计算方式变为算右孩子两个子节点加上左侧节点</span></span><br><span class="line">        <span class="comment">// partly ignore, will not put cam on r_rr, may on r_r</span></span><br><span class="line">        <span class="number">1</span> + <span class="built_in">minCameraCover</span>(r_rrl) + <span class="built_in">minCameraCover</span>(r_rrr) + <span class="built_in">minCameraCover</span>(r_rl) + <span class="built_in">minCameraCover</span>(r_l),</span><br><span class="line">        <span class="comment">// r的监控器对r的两个子节点中的左孩子有监控作用，于是计算方式变为算左孩子两个子节点加上右侧节点</span></span><br><span class="line">        <span class="comment">// partly ignore, will not put cam on r_rl, may on r_l</span></span><br><span class="line">        <span class="number">1</span> + <span class="built_in">minCameraCover</span>(r_rll) + <span class="built_in">minCameraCover</span>(r_rlr) + <span class="built_in">minCameraCover</span>(r_rr) + <span class="built_in">minCameraCover</span>(r_l)</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>2 优化思路：<ul>
<li>2.1 同一层递归里面，相同函数名不要反复出现，用临时变量存储以加速</li>
<li>2.2 使用hash存储对应的节点的最小监控值，如果能在hash命中就不用反复计算</li>
<li>2.3 优先计算小规模，然后计算大规模</li>
</ul>
</li>
<li>3 关于为什么需要hash来避免反复计算：<ul>
<li>3.1 看例子：<br>[0,null,0,null,0,null,0,null,0,null,0,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,0,null,null,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null]</li>
<li>3.2 也就是单链表，你会发现，到达第4个节点，可以有两种监控方式，那么说明第4个节点的计算会重复2次，于是需要记忆化搜索</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> level = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;TreeNode* , <span class="type">int</span>&gt; memo;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ++level;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == root-&gt;left &amp;&amp; <span class="literal">nullptr</span> == root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp:</span></span><br><span class="line">        TreeNode* r_l = root-&gt;left;</span><br><span class="line">        TreeNode* r_r = root-&gt;right;</span><br><span class="line"></span><br><span class="line">        TreeNode* r_ll = <span class="built_in">getL</span>(r_l);</span><br><span class="line">        TreeNode* r_lr = <span class="built_in">getR</span>(r_l);</span><br><span class="line">        TreeNode* r_rl = <span class="built_in">getL</span>(r_r);</span><br><span class="line">        TreeNode* r_rr = <span class="built_in">getR</span>(r_r);</span><br><span class="line"></span><br><span class="line">        TreeNode* r_lll = <span class="built_in">getL</span>(r_ll);</span><br><span class="line">        TreeNode* r_llr = <span class="built_in">getR</span>(r_ll);</span><br><span class="line">        TreeNode* r_lrl = <span class="built_in">getL</span>(r_lr);</span><br><span class="line">        TreeNode* r_lrr = <span class="built_in">getR</span>(r_lr);</span><br><span class="line">        TreeNode* r_rll = <span class="built_in">getL</span>(r_rl);</span><br><span class="line">        TreeNode* r_rlr = <span class="built_in">getR</span>(r_rl);</span><br><span class="line">        TreeNode* r_rrl = <span class="built_in">getL</span>(r_rr);</span><br><span class="line">        TreeNode* r_rrr = <span class="built_in">getR</span>(r_rr);</span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> cover_r_lll = <span class="built_in">getFromMemo</span>(r_lll);</span><br><span class="line">        <span class="type">int</span> cover_r_llr = <span class="built_in">getFromMemo</span>(r_llr);</span><br><span class="line">        <span class="type">int</span> cover_r_lrl = <span class="built_in">getFromMemo</span>(r_lrl);</span><br><span class="line">        <span class="type">int</span> cover_r_lrr = <span class="built_in">getFromMemo</span>(r_lrr);</span><br><span class="line">        <span class="type">int</span> cover_r_rll = <span class="built_in">getFromMemo</span>(r_rll);</span><br><span class="line">        <span class="type">int</span> cover_r_rlr = <span class="built_in">getFromMemo</span>(r_rlr);</span><br><span class="line">        <span class="type">int</span> cover_r_rrl = <span class="built_in">getFromMemo</span>(r_rrl);</span><br><span class="line">        <span class="type">int</span> cover_r_rrr = <span class="built_in">getFromMemo</span>(r_rrr);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cover_r_ll = <span class="built_in">getFromMemo</span>(r_ll);</span><br><span class="line">        <span class="type">int</span> cover_r_lr = <span class="built_in">getFromMemo</span>(r_lr);</span><br><span class="line">        <span class="type">int</span> cover_r_rl = <span class="built_in">getFromMemo</span>(r_rl);</span><br><span class="line">        <span class="type">int</span> cover_r_rr = <span class="built_in">getFromMemo</span>(r_rr);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cover_r_l = <span class="built_in">getFromMemo</span>(r_l);</span><br><span class="line">        <span class="type">int</span> cover_r_r = <span class="built_in">getFromMemo</span>(r_r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// // choosing: root</span></span><br><span class="line">        <span class="comment">// int tmpRootCover = min(</span></span><br><span class="line">        <span class="comment">//     // min(</span></span><br><span class="line">        <span class="comment">//         // do not ignore</span></span><br><span class="line">        <span class="comment">//     1 + minCameraCover(r_ll) + minCameraCover(r_lr) + minCameraCover(r_rl) + minCameraCover(r_rr),</span></span><br><span class="line">        <span class="comment">//         // 1 + minCameraCover(r_l) + minCameraCover(r_r)</span></span><br><span class="line">        <span class="comment">//     // ),</span></span><br><span class="line">        <span class="comment">//     // partly ignore root choosen</span></span><br><span class="line">        <span class="comment">//     min(</span></span><br><span class="line">        <span class="comment">//         1 + minCameraCover(r_ll) + minCameraCover(r_lr) + minCameraCover(r_r), </span></span><br><span class="line">        <span class="comment">//         1 + minCameraCover(r_rl) + minCameraCover(r_rr) + minCameraCover(r_l)</span></span><br><span class="line">        <span class="comment">//     )</span></span><br><span class="line">        <span class="comment">// );</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> tmpRootCover = <span class="built_in">min</span>(</span><br><span class="line">            <span class="number">1</span> + cover_r_ll + cover_r_lr + cover_r_rl + cover_r_rr,</span><br><span class="line">            <span class="built_in">min</span>(</span><br><span class="line">                <span class="number">1</span> + cover_r_ll + cover_r_lr + cover_r_r,</span><br><span class="line">                <span class="number">1</span> + cover_r_rl + cover_r_rr + cover_r_l</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// // choosing: right </span></span><br><span class="line">        <span class="comment">// int tmpRightCover = min(</span></span><br><span class="line">        <span class="comment">//     // don&#x27;t ignore, will not put cam on r_rl, r_rr</span></span><br><span class="line">        <span class="comment">//     1 + minCameraCover(r_rll) + minCameraCover(r_rlr) + minCameraCover(r_rrl) + minCameraCover(r_rrr) + minCameraCover(r_l),</span></span><br><span class="line">        <span class="comment">//     min(</span></span><br><span class="line">        <span class="comment">//         // partly ignore, will not put cam on r_rr, may on r_r</span></span><br><span class="line">        <span class="comment">//         1 + minCameraCover(r_rrl) + minCameraCover(r_rrr) + minCameraCover(r_rl) + minCameraCover(r_l),</span></span><br><span class="line">        <span class="comment">//         // partly ignore, will not put cam on r_rl, may on r_l</span></span><br><span class="line">        <span class="comment">//         1 + minCameraCover(r_rll) + minCameraCover(r_rlr) + minCameraCover(r_rr) + minCameraCover(r_l)</span></span><br><span class="line">        <span class="comment">//     )</span></span><br><span class="line">        <span class="comment">// );</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> tmpRightCover = <span class="built_in">min</span>(</span><br><span class="line">            <span class="number">1</span> + cover_r_rll + cover_r_rlr + cover_r_rrl + cover_r_rrr + cover_r_l,</span><br><span class="line">            <span class="built_in">min</span>(</span><br><span class="line">                <span class="number">1</span> + cover_r_rrl + cover_r_rrr + cover_r_rl + cover_r_l,</span><br><span class="line">                <span class="number">1</span> + cover_r_rll + cover_r_rlr + cover_r_rr +  cover_r_l</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// // choosing: left</span></span><br><span class="line">        <span class="comment">// int tmpLeftCover = min(</span></span><br><span class="line">        <span class="comment">//     1 + minCameraCover(r_lll) + minCameraCover(r_llr) + minCameraCover(r_lrl) + minCameraCover(r_lrr) + minCameraCover(r_r),</span></span><br><span class="line">        <span class="comment">//     min(</span></span><br><span class="line">        <span class="comment">//         1 + minCameraCover(r_ll) + minCameraCover(r_lrl) + minCameraCover(r_lrr) + minCameraCover(r_r),</span></span><br><span class="line">        <span class="comment">//         1 + minCameraCover(r_lr) + minCameraCover(r_lll) + minCameraCover(r_llr)  + minCameraCover(r_r)</span></span><br><span class="line">        <span class="comment">//     )</span></span><br><span class="line">        <span class="comment">// );</span></span><br><span class="line">        <span class="type">int</span> tmpLeftCover = <span class="built_in">min</span>(</span><br><span class="line">            <span class="number">1</span> + cover_r_lll + cover_r_llr + cover_r_lrl + cover_r_lrr + cover_r_r,</span><br><span class="line">            <span class="built_in">min</span>(</span><br><span class="line">                <span class="number">1</span> + cover_r_ll + cover_r_lrl + cover_r_lrr + cover_r_r,</span><br><span class="line">                <span class="number">1</span> + cover_r_lr + cover_r_lll + cover_r_llr + cover_r_r</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(tmpRootCover, <span class="built_in">min</span>(tmpLeftCover, tmpRightCover));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">getR</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">getL</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getFromMemo</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(memo.<span class="built_in">end</span>() == memo.<span class="built_in">find</span>(root)) &#123;</span><br><span class="line">            memo[root] = <span class="built_in">minCameraCover</span>(root);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> memo[root];</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2022/02/27/mergeHeapQuickSort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/27/mergeHeapQuickSort/" class="post-title-link" itemprop="url">mergeHeapQuickSort - 四种基础排序-快速，归并，堆排序以及桶排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-27 16:57:51" itemprop="dateCreated datePublished" datetime="2022-02-27T16:57:51+08:00">2022-02-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="四种基础排序"><a href="#四种基础排序" class="headerlink" title="四种基础排序"></a>四种基础排序</h1><ul>
<li>归并排序</li>
<li>堆排序</li>
<li>快速排序</li>
<li>桶排序</li>
</ul>
<h2 id="1-题目："><a href="#1-题目：" class="headerlink" title="1 题目："></a>1 题目：</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-an-array/">https://leetcode-cn.com/problems/sort-an-array/</a></p>
<h2 id="2-解题思路："><a href="#2-解题思路：" class="headerlink" title="2 解题思路："></a>2 解题思路：</h2><ul>
<li>1 分别详细解释 快速排序，归并排序，堆排序<ul>
<li>1.1 快速排序<ul>
<li>算法核心：选择一个数字，然后将比他大的都移动到他左边，比他小的都是右边，然后分别对左侧区域和右侧区域递归执行即可</li>
<li>速度和稳定性：在单调情况下达到最坏，为O(n**2)，不稳定的原因，中枢元素会和最后一个比他小的数字交换位置(以此将左侧分为比他小的，右侧比他大的)；</li>
</ul>
</li>
<li>1.2 归并排序<ul>
<li>算法核心：切分成左右两部分，然后对于左右两部分分别执行算法本身，知道之剩下2个以及1个元素，返回后合并即可</li>
<li>速度稳定性：速度稳定，元素之间次序稳定</li>
</ul>
</li>
<li>1.3 堆排序：<ul>
<li>算法核心：首先建立一个大根堆，之后第i次将大根堆的top移动到nums的nums[n-i]处，而后将nums[0:n-i-1]重新排列成大根堆，一次选出一个最大元素排在末尾，可以看出这里主要代价在于将maxHeapfiy(nums[0:n-i-1])</li>
<li>速度稳定性：速度稳定，元素之间次序不稳定，因为对于7,5,5 你会发现一开始将最后的5移动到了第一个，打乱了次序</li>
<li>图解参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/124885051">https://zhuanlan.zhihu.com/p/124885051</a></li>
</ul>
</li>
<li>1.4 使用桶排序<ul>
<li>1.4.1 根据最大最小值算桶的大小</li>
<li>1.4.2 将桶排列好，将每个值放入(桶内部插入排序)</li>
<li>1.4.3 将所有的值从桶里取出来，然后形成排序后的数组</li>
<li>平均时间复杂度o(n + k)，最烂：o(n**2)，为稳定排序</li>
<li>空间复杂度o(n)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// quick sort, most bad when it is sorted o(n**2), not stable</span></span><br><span class="line">        <span class="comment">// quickSort(0, nums.size() - 1, nums); </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// merge sort, stable</span></span><br><span class="line">        <span class="comment">// mergeSort(0, nums.size() - 1, nums);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// heap sort, not stable</span></span><br><span class="line">        <span class="built_in">head_sort</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">head_sort</span><span class="params">(<span class="type">int</span> st, <span class="type">int</span> ed, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="built_in">buildMaxHeap</span>(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// everytime select max and put to end and call maxHeapify</span></span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ed = len - <span class="number">1</span>; ed &gt;= <span class="number">0</span>; --ed) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(st, ed, nums);</span><br><span class="line">            <span class="comment">// nums[ed:] is sorted</span></span><br><span class="line">            <span class="built_in">maxHeapify</span>(st, ed - <span class="number">1</span>, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildMaxHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// start from the last dad node, till all dad node be the max heap root</span></span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> dad = len / <span class="number">2</span> - <span class="number">1</span>; dad &gt;= <span class="number">0</span>; --dad) &#123;</span><br><span class="line">            <span class="built_in">maxHeapify</span>(dad, len - <span class="number">1</span>, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="type">int</span> st, <span class="type">int</span> ed, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &lt;= st) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(st &lt;= ed) &#123;</span><br><span class="line">            <span class="comment">// cmp the st and its lChild and rChild and decide which side to descend</span></span><br><span class="line">            <span class="type">int</span> lChild = st * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> rChild = st * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;l/r: &quot; &lt;&lt; lChild &lt;&lt; &quot; &quot; &lt;&lt; rChild &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(lChild &gt; ed) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(rChild &gt; ed) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[st] &lt; nums[lChild]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(st, lChild, nums);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[st] &gt;= nums[lChild] &amp;&amp; nums[st] &gt;= nums[rChild]) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[lChild] &gt; nums[rChild]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(st, lChild, nums);</span><br><span class="line">                    st = lChild;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(st, rChild, nums);</span><br><span class="line">                    st = rChild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> st, <span class="type">int</span> ed, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sort when |st - ed| &lt;= 1</span></span><br><span class="line">        <span class="keyword">if</span>(ed - st == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[ed] &lt; nums[st]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(ed, st, nums);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ed == st) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (st + ed) / <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">mergeSort</span>(st, mid, nums);</span><br><span class="line">        <span class="built_in">mergeSort</span>(mid + <span class="number">1</span>, ed, nums);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// merge</span></span><br><span class="line">        <span class="type">int</span> curL = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> curR = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmpL</span><span class="params">(nums.begin() + st, nums.begin() + mid + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmpR</span><span class="params">(nums.begin() + mid + <span class="number">1</span>, nums.begin() + ed + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = st; i &lt;= ed; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curL == mid - st + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;using R to fullly fill from &quot; &lt;&lt; curR &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">for</span>(; curR &lt; ed - mid; ++curR) &#123;</span><br><span class="line">                    nums[i++] = tmpR[curR];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(curR == ed - mid) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;using L to fullly fill from &quot; &lt;&lt; curL &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">for</span>(; curL &lt; mid - st + <span class="number">1</span>; ++curL) &#123;</span><br><span class="line">                    nums[i++] = tmpL[curL];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tmpL[curL] &lt; tmpR[curR]) &#123;</span><br><span class="line">                nums[i] = tmpL[curL++];</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;using L: &quot; &lt;&lt; nums[i] &lt;&lt; endl;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[i] = tmpR[curR++];</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;using R: &quot; &lt;&lt; nums[i] &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> st, <span class="type">int</span> ed, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st &gt;= ed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> newPivot = <span class="built_in">partition</span>(st, ed, nums);</span><br><span class="line">        <span class="built_in">quickSort</span>(st, newPivot<span class="number">-1</span>, nums);</span><br><span class="line">        <span class="built_in">quickSort</span>(newPivot + <span class="number">1</span>, ed, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> st, <span class="type">int</span> ed, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// put &#x27;smaller than st&#x27; to left, others right</span></span><br><span class="line">        <span class="type">int</span> r = ed;</span><br><span class="line">        <span class="type">int</span> l = st;</span><br><span class="line">        <span class="comment">// st is the first blank place</span></span><br><span class="line">        <span class="type">int</span> pivot = nums[st];</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="comment">// r form right to left</span></span><br><span class="line">            <span class="keyword">while</span>(r &gt; l &amp;&amp; nums[r] &gt; pivot) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[l] = nums[r];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// l form left to right</span></span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] &lt;= pivot) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[r] = nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l] = pivot;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;swaping! &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">        <span class="type">int</span> tmp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : nums) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="0164maxGap-最大间距"><a href="#0164maxGap-最大间距" class="headerlink" title="0164maxGap 最大间距"></a>0164maxGap 最大间距</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-gap/">https://leetcode-cn.com/problems/maximum-gap/</a></p>
<h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 使用桶排序<ul>
<li>1.1 平均时间复杂度o(n + k)，最烂：o(n**2)</li>
<li>1.2 空间复杂度o(n)</li>
</ul>
</li>
<li>2 桶排序算<ul>
<li>2.1 根据最大最小值算桶的大小</li>
<li>2.2 将桶排列好，将每个值放入(桶内部插入排序)</li>
<li>2.3 将所有的值从桶里取出来，然后形成排序后的数组</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumGap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// bucket sort</span></span><br><span class="line">        <span class="built_in">bucketSort</span>(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getMaxGap</span></span><br><span class="line">        <span class="type">int</span> gap = INT_MIN;</span><br><span class="line">        <span class="type">int</span> last = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums) &#123;</span><br><span class="line">            gap = <span class="built_in">max</span>(i - last, gap);</span><br><span class="line">            last = i;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> gap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxNum = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> bucketSize = maxNum / len + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> bucketNum = len + <span class="number">1</span>;</span><br><span class="line">        vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buckets</span>(bucketNum, <span class="built_in">list</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put to buckets</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="built_in">insertSort</span>(buckets[nums[i] / bucketSize], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// merge</span></span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; l : buckets) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> num : l) &#123;</span><br><span class="line">                nums[idx++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(std::list&lt;<span class="type">int</span>&gt;&amp; l, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(list&lt;<span class="type">int</span>&gt;::iterator it = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span>(*it &gt; num) &#123;</span><br><span class="line">                l.<span class="built_in">insert</span>(it, num);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        l.<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2022/02/22/EffectiveCPP-ep1-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/22/EffectiveCPP-ep1-2/" class="post-title-link" itemprop="url">EffectiveCPP 阅读笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-22 16:40:37" itemprop="dateCreated datePublished" datetime="2022-02-22T16:40:37+08:00">2022-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Item-2-用-consts-enums-和-inlines-取代-defines"><a href="#Item-2-用-consts-enums-和-inlines-取代-defines" class="headerlink" title="Item 2: 用 consts, enums 和 inlines 取代 #defines"></a>Item 2: 用 consts, enums 和 inlines 取代 #defines</h1><p>使用define的缺陷：</p>
<ul>
<li>1 预处理器盲目多次拷贝替换宏名，导致产生更多的代码 -&gt; 使用const常量解决</li>
<li>2 宏函数的嵌套需要打上括号 -&gt; 使用内连函数达到相同的性能解决</li>
</ul>
<p>使用enum替换const的用例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;; <span class="comment">// &quot;the enum hack&quot; - makes</span></span><br><span class="line"> <span class="comment">// NumTurns a symbolic name for</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"> <span class="type">int</span> scores[NumTurns]; <span class="comment">// fine</span></span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>优点有其二：</p>
<ul>
<li>1 避免常量的指针和引用被取走<br>首先，the enum hack<br>的行为在几个方面上更像一个 #define 而不是 const，而有时这正是你<br>所需要的。例如：可以合法地取得一个 const 的 address（地址），<br>但不能合法地取得一个 enum 的 address（地址），这正像同样不能<br>合法地取得一个 #define 的 address（地址）。如果你不希望人们得<br>到你的 integral constants（整型族常量）的 pointer（指针）或<br>reference（引用），enum（枚举）就是强制约束这一点的好方法。</li>
<li>2 被模板元编程大量使用，属于实用主义</li>
</ul>
<p>总结：</p>
<blockquote>
<p>a. 对于 simple constants（简单常量），用 const objects（const 对<br>象）或 enums（枚举）取代 #defines。</p>
</blockquote>
<blockquote>
<p>b. 对于 function-like macros（类似函数的宏），用 inline<br>functions（内联函数）取代 #defines</p>
</blockquote>
<h1 id="Item-3-只要可能就用-const"><a href="#Item-3-只要可能就用-const" class="headerlink" title="Item 3: 只要可能就用 const"></a>Item 3: 只要可能就用 const</h1><h2 id="1-const用于指针，迭代器："><a href="#1-const用于指针，迭代器：" class="headerlink" title="1 const用于指针，迭代器："></a>1 const用于指针，迭代器：</h2><ul>
<li><p>1 用于指针：<br>如果 const 出现在星号左边，则指针 pointed to（指向）的内容为 constant（常量）；<br>如果 const 出现在星号右边，则 pointer itself（指针自身）为<br>constant（常量）；如果 const 出现在星号两边，则两者都为<br>constant（常量）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = greeting; <span class="comment">// non-const pointer,</span></span><br><span class="line"> <span class="comment">// non-const data</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p = greeting; <span class="comment">// non-const pointer,</span></span><br><span class="line"> <span class="comment">// const data</span></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> p = greeting; <span class="comment">// const pointer,</span></span><br><span class="line"> <span class="comment">// non-const data</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> p = greeting; <span class="comment">// const pointer,</span></span><br><span class="line"> <span class="comment">// const data</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> Widget *pw)</span></span>; <span class="comment">// f1 takes a pointer to a</span></span><br><span class="line"> <span class="comment">// constant Widget object</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(Widget <span class="type">const</span> *pw)</span></span>; <span class="comment">// so does f2</span></span><br></pre></td></tr></table></figure></li>
<li><p>2 用于迭代器：<br>声明一个iterator 为 const 就类似于声明一个 pointer（指针）为 const（也就是说，声明一个 T* const pointer（指针））：不能将这个 iterator 指向另外一件不同的东西，但是它所指向的东西本身可以变化。<br>若需要iterator指向的东西不能变，使用const_iterator即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator iter = <span class="comment">// iter acts like a T*</span></span><br><span class="line"><span class="type">const</span></span><br><span class="line"> vec.<span class="built_in">begin</span>();</span><br><span class="line">*iter = <span class="number">10</span>; <span class="comment">// OK, changes what iter</span></span><br><span class="line">points to</span><br><span class="line">++iter; <span class="comment">// error! iter is const</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::const_iterator cIter = <span class="comment">// cIter acts like a</span></span><br><span class="line"><span class="type">const</span> T*</span><br><span class="line"> vec.<span class="built_in">begin</span>();</span><br><span class="line">*cIter = <span class="number">10</span>; <span class="comment">// error! *cIter is const</span></span><br><span class="line">++cIter; <span class="comment">// fine, changes cIter</span></span><br></pre></td></tr></table></figure>
<h2 id="2-用于函数"><a href="#2-用于函数" class="headerlink" title="2 用于函数"></a>2 用于函数</h2></li>
<li><p>1 返回值和传参是const<br>避免了=和==的错误</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123; ... &#125;;</span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line"></span><br><span class="line">Rational a, b, c;</span><br><span class="line">...</span><br><span class="line">(a * b) = c; <span class="comment">// invoke operator= on the</span></span><br><span class="line"> <span class="comment">// result of a*b!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a * b = c) ... <span class="comment">// oops, meant to do a comparison!</span></span><br></pre></td></tr></table></figure>
<p>参数在不会被改变的时候就应该传入const</p>
</li>
<li><p>2 const member functions（const 成员函数）<br>有两个原因：</p>
<ul>
<li>2.1 它使一个 class（类）的 interface（接口）更容易被理<br>解。知道哪个函数可以改变 object（对象）而哪个不可以是很重要<br>的。</li>
<li>2.2 它们可以和 const objects（对象）一起工作。因为，书写<br>高效代码有一个很重要的方面，就像 Item 20 所解释的，提升一个<br>C++ 程序的性能的基本方法就是 pass objects by reference-to const（以传引用给 const 的方式传递一个对象）。</li>
</ul>
</li>
</ul>
<p>具体看如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> ...</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span> <span class="comment">// operator[]</span></span><br><span class="line"><span class="keyword">for</span></span><br><span class="line"> &#123; <span class="keyword">return</span> text[position]; &#125; <span class="comment">// const objects</span></span><br><span class="line"></span><br><span class="line"> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="comment">// operator[]</span></span><br><span class="line"><span class="keyword">for</span></span><br><span class="line"> &#123; <span class="keyword">return</span> text[position]; &#125; <span class="comment">// non-const objects</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> std::string text;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ------------------- 1 -----------------------</span></span><br><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; tb[<span class="number">0</span>]; <span class="comment">// calls non-const</span></span><br><span class="line"> <span class="comment">// TextBlock::operator[]</span></span><br><span class="line"><span class="function"><span class="type">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; ctb[<span class="number">0</span>]; <span class="comment">// calls const</span></span><br><span class="line">TextBlock::<span class="keyword">operator</span>[]</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------- 2 ----------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> TextBlock&amp; ctb)</span> <span class="comment">// in this function, ctb is</span></span></span><br><span class="line"><span class="function"><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> std::cout &lt;&lt; ctb[<span class="number">0</span>]; <span class="comment">// calls const TextBlock::operator[]</span></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --------------------- 3 ---------------------</span></span><br><span class="line">std::cout &lt;&lt; tb[<span class="number">0</span>]; <span class="comment">// fine — reading a</span></span><br><span class="line"> <span class="comment">// non-const TextBlock</span></span><br><span class="line">tb[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>; <span class="comment">// fine — writing a</span></span><br><span class="line"> <span class="comment">// non-const TextBlock</span></span><br><span class="line">std::cout &lt;&lt; ctb[<span class="number">0</span>]; <span class="comment">// fine — reading a</span></span><br><span class="line"> <span class="comment">// const TextBlock</span></span><br><span class="line">ctb[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>; <span class="comment">// error! — writing a</span></span><br><span class="line"> <span class="comment">// const TextBlock</span></span><br></pre></td></tr></table></figure>
<h2 id="3-const的二进制常量性和逻辑常量性"><a href="#3-const的二进制常量性和逻辑常量性" class="headerlink" title="3 const的二进制常量性和逻辑常量性"></a>3 const的二进制常量性和逻辑常量性</h2><p>bitwise（二进制位）const 派别坚持认为，一个 member function（成<br>员函数），当且仅当它不改变 object（对象）的任何 data<br>members（数据成员）（static（静态的）除外），也就是说如果不改<br>变 object（对象）内的任何 bits（二进制位），则这个 member<br>function（成员函数）就是 const。bitwise constness（二进制位常量<br>性）的一个好处是比较容易监测违例：编译器只需要寻找对 data<br>members（数据成员）的 assignments（赋值）。实际上，bitwise<br>constness（二进制位常量性）就是 C++ 对 constness（常量性）的<br>定义，一个 const member function（成员函数）不被允许改变调用它<br>的 object（对象）的任何 non-static data members（非静态数据成<br>员）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> ...</span><br><span class="line"> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span> <span class="comment">// inappropriate</span></span><br><span class="line">(but bitwise</span><br><span class="line"> &#123; <span class="keyword">return</span> pText[position]; &#125; <span class="comment">// const)</span></span><br><span class="line">declaration of</span><br><span class="line"> <span class="comment">// operator[]</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">char</span> *pText;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ----------------------------------------------</span></span><br><span class="line"><span class="type">const</span> CTextBlock <span class="built_in">cctb</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// declare constant object</span></span><br><span class="line"><span class="type">char</span> *pc = &amp;cctb[<span class="number">0</span>]; <span class="comment">// call the const operator[]to get a</span></span><br><span class="line"> <span class="comment">// pointer to cctb&#x27;s data</span></span><br><span class="line">*pc = <span class="string">&#x27;J&#x27;</span>; <span class="comment">// cctb now has the value &quot;Jello&quot;</span></span><br></pre></td></tr></table></figure>
<p>上述过程中：你用一个 particular value（确定值）创建一个<br>constant object（常量对象），然后你只是用它调用了 const member<br>functions（成员函数），但是你还是改变了它的值！<br>这就引出了 logical constness（逻辑常量性）的概念。这一理论的信<br>徒认为：一个 const member function（成员函数）可能会改变调用它<br>的 object（对象）中的一些 bits（二进制位），但是只能用客户无法<br>察觉的方法。例如，你的 CTextBlock class（类）在需要的时候可以<br>储存文本块的长度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> ...</span><br><span class="line"> <span class="function">std::<span class="type">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">char</span> *pText;</span><br><span class="line"> <span class="comment">// 可以解脱的代码</span></span><br><span class="line"> <span class="comment">// mutable std::size_t textLength; // these data members may</span></span><br><span class="line"> <span class="comment">// mutable bool lengthIsValid; // always be modified, even</span></span><br><span class="line">in</span><br><span class="line"> std::<span class="type">size_t</span> textLength; <span class="comment">// last calculated length of</span></span><br><span class="line">textblock</span><br><span class="line"> <span class="type">bool</span> lengthIsValid; <span class="comment">// whether length is currently</span></span><br><span class="line">valid</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (!lengthIsValid) &#123;</span><br><span class="line"> textLength = std::<span class="built_in">strlen</span>(pText); <span class="comment">// error! can&#x27;t assign to textLength</span></span><br><span class="line"> lengthIsValid = <span class="literal">true</span>; <span class="comment">// and lengthIsValid in a const</span></span><br><span class="line"> &#125; <span class="comment">// member function</span></span><br><span class="line"> <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上述代码会由于成员函数length()后面跟了一个const使得编译器保证了类的二进制常量性</strong>，那么想要修复这个问题，则只用mutable将其从中解脱。</p>
<h2 id="4-const和non-const函数有相同实现的单向调用"><a href="#4-const和non-const函数有相同实现的单向调用" class="headerlink" title="4 const和non-const函数有相同实现的单向调用"></a>4 const和non-const函数有相同实现的单向调用</h2><p>为避免代码重复，则non版本调用const版本，具体例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> ...</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span> <span class="comment">// same as</span></span><br><span class="line">before</span><br><span class="line"> &#123;</span><br><span class="line"> ...</span><br><span class="line"> ...</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">return</span> text[position];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="comment">// now just calls</span></span><br><span class="line"><span class="type">const</span> op[]</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line"> <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;( <span class="comment">// cast away const on</span></span><br><span class="line"> <span class="comment">// op[]&#x27;s return type;</span></span><br><span class="line"> <span class="built_in">static_cast</span>&lt;<span class="type">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position] <span class="comment">// add const to *this&#x27;s type;  // call const version of op[]  </span></span><br><span class="line"> ); &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>cosnt_cast去掉const属性，然后用static_cast将<em>this转为const去调用对应的const函数。<br>而不能用const成员函数去调用非const版本的是因为需要将cosnt的</em>this转为non-const的this，会导致值发生改变，这就导致const成员函数失去本身意义。</p>
<p>总结：</p>
<blockquote>
<p>将某些东西声明为 const 有助于编译器发现使用错误。const 能<br>被用于任何 scope（范围）中的 object（对象），用于 function<br>parameters（函数参数）和 return types（返回类型），用于整<br>个 member functions（成员函数）。</p>
</blockquote>
<blockquote>
<p>编译器坚持 bitwise constness（二进制位常量性），但是你应该<br>用 conceptual constness（概念上的常量性）来编程。</p>
</blockquote>
<blockquote>
<p>当 const 和 non-const member functions（成员函数）具有本质<br>上相同的实现的时候，使用 non-const 版本调用 const 版本可以<br>避免 code duplication（代码重复）。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2022/02/22/lcOrderedSet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/22/lcOrderedSet/" class="post-title-link" itemprop="url">lcOrderedSet - 有序集合1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-22 15:59:44" itemprop="dateCreated datePublished" datetime="2022-02-22T15:59:44+08:00">2022-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-有序集合"><a href="#1-有序集合" class="headerlink" title="1 有序集合"></a>1 有序集合</h1><p>泛指set, map, pirority_queue等能够按照key进行排序，然后使用lower_bound和upper_bound来进行log(n)复杂度查询的基础数据结构<br>(注意priority_queue仅能够在堆顶进行操作)<br>示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        set&lt;<span class="type">int</span>, std::less&lt;<span class="type">int</span>&gt;&gt; spareServers;</span><br><span class="line">&lt;被作者省略&gt;</span><br><span class="line">            <span class="comment">// request distribute, find the server</span></span><br><span class="line">            <span class="type">int</span> tarServer = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">auto</span> itr = spareServers.<span class="built_in">lower_bound</span>(arrivalIdx % k);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;trying to find: &quot; &lt;&lt; arrivalIdx % k &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(itr != spareServers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                tarServer = *itr;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;find tar1: &quot; &lt;&lt; tarServer &lt;&lt; endl;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// search from the start just like search like a cycle</span></span><br><span class="line">                tarServer = *spareServers.<span class="built_in">lower_bound</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;find tar2: &quot; &lt;&lt; tarServer &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-具体示例"><a href="#2-具体示例" class="headerlink" title="2 具体示例"></a>2 具体示例</h1><h2 id="0363maxSumSubMatrix-最大子区域和"><a href="#0363maxSumSubMatrix-最大子区域和" class="headerlink" title="0363maxSumSubMatrix 最大子区域和"></a>0363maxSumSubMatrix 最大子区域和</h2><h3 id="1-题目："><a href="#1-题目：" class="headerlink" title="1 题目："></a>1 题目：</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/</a></p>
<h3 id="2-解题思路："><a href="#2-解题思路：" class="headerlink" title="2 解题思路："></a>2 解题思路：</h3><ul>
<li>1 普通思路：一维前缀和，按行计算前缀和，使用m x n的矩阵存储，然后计算矩形区域，则只需要O(m)的计算复杂度</li>
<li>2 优化：二维前缀和，pre[i][j]存储的是0，0到i，j处的矩形区域和，那么计算方式为：<blockquote>
<p>preMat2[i+1][j+1] = preMat2[i][j+1] + preMat2[i+1][j] - preMat2[i][j] + matrix[i][j];</p>
</blockquote>
</li>
<li>3 使用二位前缀和去计算子区域的和，搜索子区域的方式：<ul>
<li>3.1 对于每个子区域的上下边界搜索左右边界，上下左边界搜索复杂度为o(n^2), 而后搜索左右边界，对于每一个右边界O(n)，搜索左边界，什么样的左边界？left满足sum(up, down, 0, right) - k &lt;= sum(up, down, 0, left), 也就是在[0, right]的范围内找到最小的大于sum(up, down, 0, right) - k的left，在遍历的过程中使用set存所有的sum(up, down, 0, right), 在这个set里面找left，使用lower_bound函数，只需要log(n)复杂度，于是总复杂度为 o(m^2 * nlog(n))</li>
<li>3.2 上述核心思想： 本来需要找right和left的对子，但是现在借助k，找left就变成在right的历史中搜索即可<ul>
<li>3.2.1 原来思想：sum(up, down, 0, right) - sum(up, down, 0, left) &lt;= k</li>
<li>3.2.2 新的思想：sum(up, down, 0, right) - k &lt;= sum(up, down, 0, left)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> matLen = <span class="number">102</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; preMat; <span class="comment">// 2d prefix sum</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSumSubmatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cal 2d prefix sum</span></span><br><span class="line">        m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        preMat.<span class="built_in">resize</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                preMat[i+<span class="number">1</span>][j+<span class="number">1</span>] = preMat[i][j+<span class="number">1</span>] + preMat[i+<span class="number">1</span>][j] - preMat[i][j] + matrix[i][j];</span><br><span class="line">                <span class="comment">// cout &lt;&lt; preMat[i+1][j+1] &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for each up and down, find max l,r</span></span><br><span class="line">        <span class="type">int</span> res = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">0</span>; d &lt; m; ++d) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> u = d; u &gt;= <span class="number">0</span>; --u) &#123;</span><br><span class="line">                set&lt;<span class="type">int</span>&gt; lSet = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">                    <span class="type">int</span> sumRight = <span class="built_in">sumRegion</span>(u, d, <span class="number">0</span>, r);</span><br><span class="line">                    set&lt;<span class="type">int</span>&gt;::iterator lbPtr = lSet.<span class="built_in">lower_bound</span>(sumRight - k);</span><br><span class="line">                    lSet.<span class="built_in">insert</span>(sumRight);</span><br><span class="line">                    <span class="keyword">if</span>(lbPtr != lSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        res = <span class="built_in">max</span>(res, sumRight - *lbPtr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> up, <span class="type">int</span> down, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preMat[down+<span class="number">1</span>][right+<span class="number">1</span>] - preMat[down+<span class="number">1</span>][left] - preMat[up][right+<span class="number">1</span>] - preMat[up][left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="0699fallingSquares-掉落的方块"><a href="#0699fallingSquares-掉落的方块" class="headerlink" title="0699fallingSquares 掉落的方块"></a>0699fallingSquares 掉落的方块</h2><h3 id="1-题目：-1"><a href="#1-题目：-1" class="headerlink" title="1 题目："></a>1 题目：</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/falling-squares/">https://leetcode-cn.com/problems/falling-squares/</a></p>
<h3 id="2-解题思路：-1"><a href="#2-解题思路：-1" class="headerlink" title="2 解题思路："></a>2 解题思路：</h3><ul>
<li>1 普通思路：使用一维数组模拟每个位置方块高度，复杂度为o(N^2)，由于N很大，所以会超时</li>
<li>2 优化：使用坐标压缩，将所有方块的边界存储在2000以内（因为一共就1000个方块），然后更新高度就按照2000以内去更新即可<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fallingSquares</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; positions)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// coordinate compression</span></span><br><span class="line">        set&lt;<span class="type">int</span>, std::less&lt;<span class="type">int</span>&gt;&gt; coords;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;&amp; coord : positions) &#123;</span><br><span class="line">            coords.<span class="built_in">insert</span>(coord[<span class="number">0</span>]);</span><br><span class="line">            coords.<span class="built_in">insert</span>(coord[<span class="number">0</span>] + coord[<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; borderToIdx;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : coords) &#123;</span><br><span class="line">            borderToIdx[i] = t++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cal heights</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">heights</span><span class="params">(t)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> curHeightest = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;&amp; square : positions) &#123;</span><br><span class="line">            <span class="type">int</span> l = borderToIdx[square[<span class="number">0</span>]];</span><br><span class="line">            <span class="type">int</span> r = borderToIdx[square[<span class="number">0</span>] + square[<span class="number">1</span>] - <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> h = square[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> updatedHeight = <span class="built_in">update</span>(l, r, h, heights);</span><br><span class="line">            curHeightest = <span class="built_in">max</span>(curHeightest, updatedHeight);</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(curHeightest);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update and return updated height of [l, r]</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> h, vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> oldHeight = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            oldHeight = <span class="built_in">max</span>(oldHeight, heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> newHeight = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            heights[i] = oldHeight + h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldHeight + h;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="0715-Range-模块-rangeModule"><a href="#0715-Range-模块-rangeModule" class="headerlink" title="0715 Range 模块 rangeModule"></a>0715 Range 模块 rangeModule</h2><h3 id="1-题目：-2"><a href="#1-题目：-2" class="headerlink" title="1 题目："></a>1 题目：</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-module/">https://leetcode-cn.com/problems/range-module/</a></p>
<h3 id="2-解题思路：-2"><a href="#2-解题思路：-2" class="headerlink" title="2 解题思路："></a>2 解题思路：</h3><ul>
<li>1 普通思路：使用map记录这些离散的区间<ul>
<li>1.1 添加、删除： 遍历map，看map的每一个区间和当前区间的关系，这样处理最为合适</li>
<li>1.2 查询：使用upper_bound查询到第一个（左侧）比目标的left小的区间，然后看目标的left和right是否在map对应的区间内部<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RangeModule</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>, std::less&lt;<span class="type">int</span>&gt;&gt; intervals;</span><br><span class="line">    <span class="built_in">RangeModule</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            intervals[left] = right;</span><br><span class="line">            <span class="built_in">print</span>();</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = intervals.<span class="built_in">begin</span>(); it != intervals.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;first &gt;= left) &#123;</span><br><span class="line">                <span class="keyword">if</span>(it-&gt;first &gt; right) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(it != intervals.<span class="built_in">end</span>() &amp;&amp; it-&gt;second &lt;= right) &#123;</span><br><span class="line">                    it = intervals.<span class="built_in">erase</span>(it);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(it == intervals.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    intervals[left] = right;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(it-&gt;first &lt;= right) &#123;</span><br><span class="line">                        <span class="type">int</span> newRight = it-&gt;second;</span><br><span class="line">                        intervals.<span class="built_in">erase</span>(it);</span><br><span class="line">                        intervals[left] = newRight;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        intervals[left] = right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">print</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// it-&gt;first &lt; left</span></span><br><span class="line">                <span class="keyword">if</span>(it-&gt;second &lt; left) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> newLeft = it-&gt;first;</span><br><span class="line">                <span class="keyword">while</span>(it != intervals.<span class="built_in">end</span>() &amp;&amp; it-&gt;second &lt;= right) &#123;</span><br><span class="line">                    it = intervals.<span class="built_in">erase</span>(it);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(it == intervals.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    intervals[newLeft] = right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(it-&gt;first &lt;= right) &#123;</span><br><span class="line">                        <span class="type">int</span> newRight = it-&gt;second;</span><br><span class="line">                        intervals.<span class="built_in">erase</span>(it);</span><br><span class="line">                        intervals[newLeft] = newRight;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        intervals[newLeft] = right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">print</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        intervals[left] = right;</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">queryRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> lBig = intervals.<span class="built_in">upper_bound</span>(left);</span><br><span class="line">        <span class="keyword">if</span>(lBig != intervals.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">            --lBig;</span><br><span class="line">            <span class="keyword">return</span>  lBig-&gt;second &gt;= right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// for(auto it = intervals.begin(); it != intervals.end(); ++it) &#123;</span></span><br><span class="line">        <span class="comment">//     for(int i = 0)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> lBig = intervals.<span class="built_in">lower_bound</span>(left);</span><br><span class="line">        <span class="type">int</span> newLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(lBig != intervals.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;d1.5&quot; &lt;&lt; endl;</span></span><br><span class="line">            --lBig;</span><br><span class="line">            <span class="keyword">if</span>(right &lt; lBig-&gt;second) &#123;</span><br><span class="line">                intervals[right] = lBig-&gt;second;</span><br><span class="line">                intervals[lBig-&gt;first] = left;</span><br><span class="line">                <span class="built_in">print</span>();</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;d2&quot; &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span>(lBig-&gt;second &gt; left) &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; &quot;d2.5&quot; &lt;&lt; endl;</span></span><br><span class="line">                    intervals[lBig-&gt;first] = left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++lBig;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (lBig != intervals.<span class="built_in">end</span>() &amp;&amp; lBig-&gt;second &lt; right) &#123;</span><br><span class="line">                lBig = intervals.<span class="built_in">erase</span>(lBig);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(lBig != intervals.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(lBig-&gt;first &lt; right) &#123;</span><br><span class="line">                    <span class="type">int</span> secondRight = lBig-&gt;second;</span><br><span class="line">                    intervals.<span class="built_in">erase</span>(lBig);</span><br><span class="line">                    intervals[right] = secondRight;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (lBig != intervals.<span class="built_in">end</span>() &amp;&amp; lBig-&gt;second &lt; right) &#123;</span><br><span class="line">                lBig = intervals.<span class="built_in">erase</span>(lBig);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(lBig != intervals.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(lBig-&gt;first &lt; right) &#123;</span><br><span class="line">                    <span class="type">int</span> secondRight = lBig-&gt;second;</span><br><span class="line">                    intervals.<span class="built_in">erase</span>(lBig);</span><br><span class="line">                    intervals[right] = secondRight;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;-----st-----&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// for(auto it = intervals.begin(); it != intervals.end(); ++it) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;-----ed-----&quot; &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RangeModule object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RangeModule* obj = new RangeModule();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addRange(left,right);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;queryRange(left,right);</span></span><br><span class="line"><span class="comment"> * obj-&gt;removeRange(left,right);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="0850-矩形面积-II"><a href="#0850-矩形面积-II" class="headerlink" title="0850. 矩形面积 II"></a>0850. 矩形面积 II</h2><h3 id="1-题目：-3"><a href="#1-题目：-3" class="headerlink" title="1 题目："></a>1 题目：</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rectangle-area-ii/solution">https://leetcode-cn.com/problems/rectangle-area-ii/solution</a></p>
<h3 id="2-解题思路：-3"><a href="#2-解题思路：-3" class="headerlink" title="2 解题思路："></a>2 解题思路：</h3><ul>
<li>1 参考官方思路的扫描线：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rectangle-area-ii/solution/ju-xing-mian-ji-ii-by-leetcode/">https://leetcode-cn.com/problems/rectangle-area-ii/solution/ju-xing-mian-ji-ii-by-leetcode/</a></li>
<li>2 总结过程：<ul>
<li>2.1 将一个矩形看成x1,x2,y1,ST; x1,x2,y2,ED;的两条线</li>
<li>2.2 而后用active记录还没有遇到ED的那些矩形的第一个扫描线集合，每回新来了一根线，则将active中的所有线和当前线计算对应面面积加起来</li>
<li>2.3 当active中遇到了矩形的ED，则将active中对应的矩形的ST删除<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">long</span> <span class="type">long</span> bigPrime = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rectangleArea</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// lines</span></span><br><span class="line">        <span class="type">int</span> ST = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ED = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; lines;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; vec : rectangles) &#123;</span><br><span class="line">            lines.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;vec[<span class="number">0</span>], vec[<span class="number">2</span>], vec[<span class="number">1</span>], ST&#125;);</span><br><span class="line">            lines.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;vec[<span class="number">0</span>], vec[<span class="number">2</span>], vec[<span class="number">3</span>], ED&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sort the lines by the y</span></span><br><span class="line">        <span class="built_in">sort</span>(lines.<span class="built_in">begin</span>(), lines.<span class="built_in">end</span>(), </span><br><span class="line">            [](vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// scan the lines</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; actives;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lastY = lines[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; line : lines) &#123;</span><br><span class="line">            <span class="type">int</span> curY = line[<span class="number">2</span>], type = line[<span class="number">3</span>], x1 = line[<span class="number">0</span>], x2 = line[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> width = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> actX = <span class="number">-1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// actives: those opend lines, sorted by y</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; act : actives) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;act: &quot; &lt;&lt; act[0] &lt;&lt; &quot; &quot; &lt;&lt; act[1] &lt;&lt; endl;</span></span><br><span class="line">                actX = <span class="built_in">max</span>(actX, act[<span class="number">0</span>]);</span><br><span class="line">                width += <span class="built_in">max</span>(act[<span class="number">1</span>] - actX, <span class="number">0</span>);</span><br><span class="line">                actX = <span class="built_in">max</span>(actX, act[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res += <span class="built_in">static_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(width) * (curY - lastY) % bigPrime;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;w: &quot; &lt;&lt; width &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// add new actives</span></span><br><span class="line">            <span class="keyword">if</span>(type == ST) &#123;</span><br><span class="line">                actives.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;x1, x2, curY, type&#125;);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;insert x1,2: &quot; &lt;&lt; x1 &lt;&lt; &quot; &quot; &lt;&lt; x2 &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">// sort the opend lines of the started points</span></span><br><span class="line">                <span class="built_in">sort</span>(actives.<span class="built_in">begin</span>(), actives.<span class="built_in">end</span>(), </span><br><span class="line">                    [](vector&lt;<span class="type">int</span>&gt;&amp; line1, vector&lt;<span class="type">int</span>&gt;&amp; line2) &#123;</span><br><span class="line">                        <span class="keyword">return</span> line1[<span class="number">0</span>] &lt; line2[<span class="number">0</span>];</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// find the active and rm it</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; actives.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(actives[i][<span class="number">0</span>] == x1 &amp;&amp; actives[i][<span class="number">1</span>] == x2) &#123;</span><br><span class="line">                        actives.<span class="built_in">erase</span>(actives.<span class="built_in">begin</span>() + i);</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; &quot;earse x1,2: &quot; &lt;&lt; x1 &lt;&lt; &quot; &quot; &lt;&lt; x2 &lt;&lt; endl;</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            lastY = curY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res % bigPrime;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">getSkyLine</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">        function&lt;<span class="type">bool</span>(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp;, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp;)&gt; cmp = </span><br><span class="line">        [](pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &lt;rightBound, height&gt;</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, function&lt;<span class="type">bool</span>(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp;, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp;)&gt; &gt; <span class="built_in">queue</span>(cmp);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; bounds;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> n = buildings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            bounds.<span class="built_in">emplace_back</span>(buildings[i][<span class="number">0</span>]);</span><br><span class="line">            bounds.<span class="built_in">emplace_back</span>(buildings[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(bounds.<span class="built_in">begin</span>(), bounds.<span class="built_in">end</span>(), std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;c1&quot; &lt;&lt; endl;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; curBound : bounds) &#123;</span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; &quot;c &quot;  &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// push buildings lefter than curBound until one righter meet</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; buildings.<span class="built_in">size</span>() &amp;&amp; curBound &gt;= buildings[j][<span class="number">0</span>]) &#123;</span><br><span class="line">                queue.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(buildings[j][<span class="number">1</span>], buildings[j][<span class="number">2</span>]));</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; &quot;c &quot;  &lt;&lt; &quot;adf&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// pop out those rec unrelevant</span></span><br><span class="line">            <span class="keyword">while</span>(!queue.<span class="built_in">empty</span>() &amp;&amp; curBound &gt;= queue.<span class="built_in">top</span>().first) &#123;</span><br><span class="line">                queue.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curBoundHeight = queue.<span class="built_in">empty</span>() ? <span class="number">0</span> : queue.<span class="built_in">top</span>().second;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if(res.size() == 0 || res.back()[1] != curBoundHeight) &#123;</span></span><br><span class="line">            <span class="comment">//     res.emplace_back(vector&lt;int&gt;&#123;curBound, curBoundHeight&#125;);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">size</span>() == <span class="number">0</span> || res.<span class="built_in">back</span>()[<span class="number">1</span>] != curBoundHeight) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;curBound, curBoundHeight&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; v : vec) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="0895maxFreqStack-最大频率栈"><a href="#0895maxFreqStack-最大频率栈" class="headerlink" title="0895maxFreqStack 最大频率栈"></a>0895maxFreqStack 最大频率栈</h2><h3 id="1-题目：-4"><a href="#1-题目：-4" class="headerlink" title="1 题目："></a>1 题目：</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-frequency-stack/">https://leetcode-cn.com/problems/maximum-frequency-stack/</a></p>
<h3 id="2-解题思路：map-hash栈"><a href="#2-解题思路：map-hash栈" class="headerlink" title="2 解题思路：map/hash栈"></a>2 解题思路：map/hash栈</h3><ul>
<li>1 参考官方思路的扫描线：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-frequency-stack/solution/zui-da-pin-lu-zhan-by-leetcode/">https://leetcode-cn.com/problems/maximum-frequency-stack/solution/zui-da-pin-lu-zhan-by-leetcode/</a></li>
<li>2 总结过程：<ul>
<li>2.1 首先用map维持每一个变量的频率<ul>
<li>2.1.1 维持方法： push中对应的key加一，pop对应的key减一</li>
</ul>
</li>
<li>2.2 如何获得当前最大频率？<ul>
<li>2.2.1 在每个变量push和pop的时候我们可以获得对应的key的频率，那么所有的key的频率变动都是在push和pop执行完成之后，那么只需要用一个变量maxFreq维持最大频率即可</li>
</ul>
</li>
<li>2.3 知道最大频率，如何获得当前最大频率的变量？<ul>
<li>2.3.1 使用map&lt;频率，频率对应的数的集合&gt;来记录即可，然后用2.2中使用maxFreq获取最大频率对应的数字的集合，那如何从这个集合中获取在栈顶的数据呢？map&lt;频率，频率对应的数的集合&gt;中 <strong>频率对应的数的集合</strong> 使用stack去存就好了，因为stack的栈顶总是存着最新来的数据</li>
</ul>
</li>
<li>2.4 一个实例： 3，3，3都是push，那么在频率为1，2，3的栈中，很自然的都有一个3，自然体现在哪里呢？现在pop一下，频率为3对应的stack为空，然后最大频率变为2，然后2里面同样是3<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FreqStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> opNum;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; opNumMap;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freqMap;</span><br><span class="line">    map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;*&gt; groupByFreq;</span><br><span class="line">    <span class="type">int</span> maxFreq;</span><br><span class="line">    <span class="built_in">FreqStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;pushing st: with max freq: &quot; &lt;&lt; maxFreq &lt;&lt; endl;</span></span><br><span class="line">        freqMap[val]++;</span><br><span class="line">        <span class="keyword">if</span>(groupByFreq[freqMap[val]] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            groupByFreq[freqMap[val]] = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        groupByFreq[freqMap[val]]-&gt;<span class="built_in">emplace_back</span>(val);</span><br><span class="line">        maxFreq = <span class="built_in">max</span>(maxFreq, freqMap[val]);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;pushing done: &quot; &lt;&lt; val &lt;&lt; &quot;with maxFreq: &quot; &lt;&lt; maxFreq &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;pop st with maxFreq: &quot; &lt;&lt; maxFreq &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// find biggest frequency and most newly element to rm</span></span><br><span class="line">        <span class="type">int</span> popRes = groupByFreq[maxFreq]-&gt;<span class="built_in">back</span>();</span><br><span class="line">        groupByFreq[maxFreq]-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span>(groupByFreq[maxFreq]-&gt;<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> groupByFreq[maxFreq];</span><br><span class="line">            groupByFreq[maxFreq] = <span class="literal">nullptr</span>;</span><br><span class="line">            --maxFreq;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;pop ed&quot; &lt;&lt; popRes &lt;&lt; &quot; with maxFreq: &quot; &lt;&lt; maxFreq &lt;&lt; endl;</span></span><br><span class="line">        freqMap[popRes]--;</span><br><span class="line">        <span class="keyword">return</span> popRes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FreqStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FreqStack* obj = new FreqStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="1606busiestServers-找到处理最多请求的服务器"><a href="#1606busiestServers-找到处理最多请求的服务器" class="headerlink" title="1606busiestServers 找到处理最多请求的服务器"></a>1606busiestServers 找到处理最多请求的服务器</h2><h3 id="1-题目：-5"><a href="#1-题目：-5" class="headerlink" title="1 题目："></a>1 题目：</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-servers-that-handled-most-number-of-requests/">https://leetcode-cn.com/problems/find-servers-that-handled-most-number-of-requests/</a></p>
<h3 id="2-解题思路：-4"><a href="#2-解题思路：-4" class="headerlink" title="2 解题思路："></a>2 解题思路：</h3><ul>
<li>1 自然的思路：对于每一个到来的请求，我们将服务器分为两部分，一部分是空闲服务器，一部分是繁忙服务器<ul>
<li>1.1 如何快速找到空闲服务器？我们用set记录空闲服务器即可，两次使用lower_bound完成cycle查询</li>
<li>1.2 如何记录繁忙服务器？在每一个请求到来以及处理完成，都可能出现繁忙服务器的改动和空闲服务器的改动，于是采用map&lt;到期时间，相应服务器列表&gt;来存储繁忙服务器</li>
<li>1.3 如何处理请求处理完成时的服务器从繁忙变为空闲？<ul>
<li>1.3.1 采用小根堆存储当前所有繁忙服务器的到期时间，那么只需要在请求到来的时候，将所有比当前请求小的到期时间的繁忙服务器变为空闲即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">busiestServers</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; arrival, vector&lt;<span class="type">int</span>&gt;&amp; load)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// using small root heap to store the smallest avaliable server</span></span><br><span class="line">        <span class="comment">// auto cmp = [](const int&amp; a, const int b) </span></span><br><span class="line">        set&lt;<span class="type">int</span>, std::less&lt;<span class="type">int</span>&gt;&gt; spareServers;</span><br><span class="line">        map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; busyServers;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; dues;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; serverSumLoad;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            spareServers.<span class="built_in">insert</span>(i);</span><br><span class="line">            serverSumLoad.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i,<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// deal request</span></span><br><span class="line">        <span class="type">int</span> reqNum = arrival.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> arrivalIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> arrival : arrival) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;req: &quot; &lt;&lt; arrival &lt;&lt; &quot;load: &quot; &lt;&lt; load[arrivalIdx] &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// release servers</span></span><br><span class="line">            <span class="keyword">while</span>(!dues.<span class="built_in">empty</span>() &amp;&amp; dues.<span class="built_in">top</span>() &lt;= arrival) &#123;</span><br><span class="line">                <span class="type">int</span> due = dues.<span class="built_in">top</span>();</span><br><span class="line">                dues.<span class="built_in">pop</span>();</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt;&amp; toRelease = busyServers[due];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> i : toRelease) &#123;</span><br><span class="line">                    spareServers.<span class="built_in">insert</span>(i);</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; &quot;releasing &quot; &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// busyServers.erase(due);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// abandon the request</span></span><br><span class="line">            <span class="keyword">if</span>(spareServers.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                ++ arrivalIdx;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;abandon!&quot; &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// request distribute, find the server</span></span><br><span class="line">            <span class="type">int</span> tarServer = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">auto</span> itr = spareServers.<span class="built_in">lower_bound</span>(arrivalIdx % k);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;trying to find: &quot; &lt;&lt; arrivalIdx % k &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(itr != spareServers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                tarServer = *itr;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;find tar1: &quot; &lt;&lt; tarServer &lt;&lt; endl;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// search from the start just like search like a cycle</span></span><br><span class="line">                tarServer = *spareServers.<span class="built_in">lower_bound</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;find tar2: &quot; &lt;&lt; tarServer &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            spareServers.<span class="built_in">erase</span>(tarServer);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// set the server to busy</span></span><br><span class="line">            <span class="type">int</span> due = arrival + load[arrivalIdx];</span><br><span class="line">            <span class="keyword">if</span>(busyServers.<span class="built_in">find</span>(due) == busyServers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; tmpVec = &#123;tarServer&#125;;</span><br><span class="line">                busyServers[due] = tmpVec;</span><br><span class="line">                dues.<span class="built_in">push</span>(due);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;init busy due : &quot; &lt;&lt; tarServer &lt;&lt; &quot; to &quot; &lt;&lt; due &lt;&lt; endl;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                busyServers[due].<span class="built_in">push_back</span>(tarServer);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;add busy due : &quot; &lt;&lt; tarServer &lt;&lt; &quot; to &quot; &lt;&lt; due &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            serverSumLoad[tarServer].second ++;</span><br><span class="line"></span><br><span class="line">            ++ arrivalIdx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(serverSumLoad.<span class="built_in">begin</span>(), serverSumLoad.<span class="built_in">end</span>(),[](</span><br><span class="line">            <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; p1, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; p2</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">return</span> p1.second &gt; p2.second;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// for(int ed = 0; ed &lt; serverSumLoad.size(); ++ed) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; &quot;server: &quot; &lt;&lt; serverSumLoad[ed].first &lt;&lt; &quot; &gt; &quot; &lt;&lt; serverSumLoad[ed].second &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="type">int</span> ed = <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res = &#123;serverSumLoad[<span class="number">0</span>].first&#125;;</span><br><span class="line">         </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(; ed &lt; serverSumLoad.<span class="built_in">size</span>(); ++ed) &#123;</span><br><span class="line">            <span class="keyword">if</span>(serverSumLoad[ed].second != serverSumLoad[<span class="number">0</span>].second) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(serverSumLoad[ed].first);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2022/01/12/lcMonostack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/12/lcMonostack/" class="post-title-link" itemprop="url">lcMonostack - 单调栈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-12 14:07:18" itemprop="dateCreated datePublished" datetime="2022-01-12T14:07:18+08:00">2022-01-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>其基本特性：</p>
<ul>
<li>1 单调栈的极值性质：单调递减栈的第一个字符为<strong>目前</strong>最大的元素，单调递增栈则相反; 关于目前的解释，由于单调栈是遍历整个数组出栈入栈的过程，假设目前遍历到节点i，则arr[:i]为目前单调栈遍历过的元素们，单调栈递增递减栈的<strong>第一个数字</strong>分别为arr[:i]的最大最小值</li>
<li>2 单调栈的单调性：单调栈内的元素严格单调</li>
</ul>
<h2 id="1-单调栈写法"><a href="#1-单调栈写法" class="headerlink" title="1 单调栈写法"></a>1 单调栈写法</h2><p>一下为求每个元素左侧最大值的一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; normalOrderMono;</span><br><span class="line"><span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftMax</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!normalOrderMono.<span class="built_in">empty</span>() &amp;&amp; height[normalOrderMono.<span class="built_in">back</span>()] &lt;= height[i]) &#123;</span><br><span class="line">        normalOrderMono.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    leftMax[i] = normalOrderMono.<span class="built_in">empty</span>() ? height[i] : height[normalOrderMono[<span class="number">0</span>]];</span><br><span class="line">    normalOrderMono.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="0000-interview-1712trapWater-接雨水"><a href="#0000-interview-1712trapWater-接雨水" class="headerlink" title="0000_interview_1712trapWater 接雨水"></a>0000_interview_1712trapWater 接雨水</h2><h3 id="1-题目："><a href="#1-题目：" class="headerlink" title="1 题目："></a>1 题目：</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/volume-of-histogram-lcci/">https://leetcode-cn.com/problems/volume-of-histogram-lcci/</a></p>
<h3 id="2-解题思路："><a href="#2-解题思路：" class="headerlink" title="2 解题思路："></a>2 解题思路：</h3><ul>
<li>1 参照提示的一句话：<blockquote>
<p>每个长方形的顶部都有水，水的高度应与左侧最高长方形和右侧最高长方形的较小值相匹配，也就是说，water_on_top[i] = min(tallest_ bar(0-&gt;i), tallest_bar(i, n))。</p>
</blockquote>
</li>
<li>2 使用单调栈计算当前节点左侧(右侧)最大值<ul>
<li>2.1 很简单： 考虑单调栈的性质，单调递减栈的第一个字符为<strong>目前</strong>最大的元素，单调递增栈则相反，为最小元素</li>
<li>2.2 关于目前的解释，由于单调栈是遍历整个数组出栈入栈的过程，遍历到节点i，则arr[:i]为目前单调栈遍历过的元素们，单调栈递增递减栈的第一个数字分别为arr[:i]的最大最小值</li>
<li>2.3 由于需要统计右侧最大值，则我们只需要逆序遍历数组即可，最大值可以使用单调递减获得</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// using descending mono stack to find maxValue in left or right</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; normalOrderMono;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; reverseOrderMono;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftMax</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightMax</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!reverseOrderMono.<span class="built_in">empty</span>() &amp;&amp; height[reverseOrderMono.<span class="built_in">back</span>()] &lt;= height[i]) &#123;</span><br><span class="line">                reverseOrderMono.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            rightMax[i] = reverseOrderMono.<span class="built_in">empty</span>() ? height[i] : height[reverseOrderMono[<span class="number">0</span>]];</span><br><span class="line">            reverseOrderMono.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!normalOrderMono.<span class="built_in">empty</span>() &amp;&amp; height[normalOrderMono.<span class="built_in">back</span>()] &lt;= height[i]) &#123;</span><br><span class="line">                normalOrderMono.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            leftMax[i] = normalOrderMono.<span class="built_in">empty</span>() ? height[i] : height[normalOrderMono[<span class="number">0</span>]];</span><br><span class="line">            normalOrderMono.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res += <span class="built_in">max</span>(<span class="built_in">min</span>(leftMax[i], rightMax[i]) - height[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2030-含特定字母的最小子序列-smallestSubsequence"><a href="#2030-含特定字母的最小子序列-smallestSubsequence" class="headerlink" title="2030. 含特定字母的最小子序列 smallestSubsequence"></a>2030. 含特定字母的最小子序列 smallestSubsequence</h2><h3 id="1-题目：-1"><a href="#1-题目：-1" class="headerlink" title="1 题目："></a>1 题目：</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/">https://leetcode-cn.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/</a></p>
<h3 id="2-解题思路：-1"><a href="#2-解题思路：-1" class="headerlink" title="2 解题思路："></a>2 解题思路：</h3><ul>
<li>1 考虑一个简单化的问题，选出长度为k的最小字典序的字符串，算法如下：<ul>
<li>1.1 采用单调栈维护一个递增栈，自然的保持了最小字典序<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">smallestSubsequence</span><span class="params">(string s, <span class="type">int</span> k, <span class="type">char</span> letter, <span class="type">int</span> repetition)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// first, using monostack to get the min sub arr whose len = k</span></span><br><span class="line">        <span class="comment">// and check if there are rep&#x27;s &#x27;letter&#x27; in sub arr</span></span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; mono; <span class="comment">// abscending chars</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> specialCharCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> avaliableSpeChar = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">            avaliableSpeChar += (c == letter);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!mono.<span class="built_in">empty</span>() &amp;&amp; s[mono.<span class="built_in">back</span>()] &gt;= s[i] &amp;&amp; mono.<span class="built_in">size</span>() - <span class="number">1</span> + n - i &gt;= k) &#123;</span><br><span class="line">                specialCharCnt -= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(s[mono.<span class="built_in">back</span>()] == letter);</span><br><span class="line">                mono.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mono.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(s[i] == letter) &#123;</span><br><span class="line">                --avaliableSpeChar;</span><br><span class="line">                ++specialCharCnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : mono)&#123;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>2 考虑另一个子问题，需要选出含有rep个特殊字符的子序列，可以使用一个队列存储特殊字符的下标，当队列长度达到rep个，则记为一个子序列</li>
<li>3 将两个问题结合起来考虑就是是说：<ul>
<li>3.1 在递增栈构造的过程中，要保证当前位置后面剩余的特殊字符加上当前栈内的字符大于等于repetition，否则将不能出栈特殊字符（因为如果出栈则无法满足有repetition个特殊字符的要求</li>
<li>3.2 经过3.1步骤，单调栈内含有我们的答案，但是一定有一些额外的字符存在，那么如下说明从栈内获得答案的方式：<ul>
<li>3.2.1 eg: 当aaabbbcccddd为输入，则单调栈为aaabbbcccddd，那么我们想要的结果为在至少有2个b的字符串，那么我们获得最终结果的方式为：<strong>在保证有大于repetition个letter的情况下，从尾部开始删除字符串直到单调栈内剩下k个字符即可</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;aaabbbcccddd&quot;</span><br><span class="line">3</span><br><span class="line">&quot;b&quot;</span><br><span class="line">2</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">smallestSubsequence</span><span class="params">(string s, <span class="type">int</span> k, <span class="type">char</span> letter, <span class="type">int</span> repetition)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// first, using monostack to get the min sub arr whose len = k</span></span><br><span class="line">        <span class="comment">// and check if there are rep&#x27;s &#x27;letter&#x27; in sub arr</span></span><br><span class="line">                </span><br><span class="line">        <span class="type">clock_t</span> start,end;　　　<span class="comment">//定义clock_t变量</span></span><br><span class="line">        start = <span class="built_in">clock</span>();  　　　<span class="comment">//开始时间</span></span><br><span class="line"></span><br><span class="line">        string mono; <span class="comment">// abscending chars</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> specialCharCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> avaliableSpeChar = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s) &#123;</span><br><span class="line">            avaliableSpeChar += (c == letter);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!mono.<span class="built_in">empty</span>() &amp;&amp; mono.<span class="built_in">back</span>() &gt; s[i] &amp;&amp; mono.<span class="built_in">size</span>() - <span class="number">1</span> + n - i &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mono.<span class="built_in">back</span>() == letter) &#123;</span><br><span class="line">                    <span class="comment">// when not enough special letter, we do not pop special char</span></span><br><span class="line">                    <span class="keyword">if</span>(avaliableSpeChar &lt;= repetition - specialCharCnt) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    --specialCharCnt;</span><br><span class="line">                &#125;</span><br><span class="line">                mono.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mono.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(s[i] == letter) &#123;</span><br><span class="line">                --avaliableSpeChar;</span><br><span class="line">                ++specialCharCnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        start = <span class="built_in">clock</span>();  　　　<span class="comment">//开始时间</span></span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// eliminate some extra chars reversely</span></span><br><span class="line">        <span class="type">int</span> delNum = mono.<span class="built_in">size</span>() - k;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;letter Cnt: &quot; &lt;&lt; specialCharCnt &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = mono.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="comment">// make sure there are more than rep&#x27;s &#x27;letter&#x27;</span></span><br><span class="line">            <span class="keyword">if</span>(delNum != <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="keyword">if</span>(specialCharCnt &gt; repetition) &#123;</span><br><span class="line">                    specialCharCnt -= (mono[i] == letter);</span><br><span class="line">                    --delNum;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(mono[i] != letter) &#123;</span><br><span class="line">                        --delNum;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// spend: 0.311s</span></span><br><span class="line">            <span class="comment">// res = mono[i] + res; // this spend two much time, ocuppy nearly 100% time! so we change our policy</span></span><br><span class="line">            <span class="comment">// spend: 0.000153s, 1000 times faster!</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(mono[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        end = <span class="built_in">clock</span>();   <span class="comment">//结束时间</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;time = &quot;</span>&lt;&lt;<span class="built_in">double</span>(end-start)/CLOCKS_PER_SEC&lt;&lt;<span class="string">&quot;s&quot;</span>&lt;&lt;endl;  <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-关于string的-和push-back"><a href="#3-关于string的-和push-back" class="headerlink" title="3 关于string的+和push_back"></a>3 关于string的+和push_back</h3><p>如果是一个字符一个字符的话，使用push_back会比+快1000倍！如上代码可以自己尝试统计</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spend: 0.311s</span></span><br><span class="line"><span class="comment">// res = mono[i] + res; // this spend two much time, ocuppy nearly 100% time! so we change our policy</span></span><br><span class="line"><span class="comment">// spend: 0.000153s, 1000 times faster!</span></span><br><span class="line">res.<span class="built_in">push_back</span>(mono[i]);</span><br></pre></td></tr></table></figure>

<h2 id="0321-拼接最大数"><a href="#0321-拼接最大数" class="headerlink" title="0321 拼接最大数"></a>0321 拼接最大数</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-duplicate-substring/">https://leetcode-cn.com/problems/longest-duplicate-substring/</a></p>
<h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 首先分解问题：<ul>
<li>1.1 从长度为m和n(假设m &lt;= n)中的字符串里选出k个，然后这个字串要求最大，遍历的思路：<ul>
<li>1.2 首先一共要选k个，自然想到从m和n中各挑选几个？那就是遍历了，m中的挑选长度的起点为： max(0, k - n)，最少一个不挑，然后从m中挑的个数身下还有k - m个一定能够从n中挑出，所以起点是从0到k-n，(为什么区最大值？因为当n，m均大于k的时候，k-n为负数)，挑选终点：自然是k，或者没有那么多可以调k个，则挑m个，则min(k, m)</li>
<li>1.3 那么已经知道所有从m,n中挑选出k个字符串的方法，那么对于每一个方法，如何获取最大字符串呢？<strong>其实就是分别从该方法的m和n串中各选出他们的最大字串，然后合并即可</strong>，于是问题转化为：从m中如何选出某个长度记为l的最大字串？<ul>
<li>1.3.1 我们考虑一个使用单调递减栈，因为它的栈顶总是当前字符串最大的值，然后后面都是递减的，这正是我们需要的，比如 9 1 2 5 8 3选择3个的时候，使用单调栈可以直接获得9,8,3，但是有个问题，比如从 9 1 2 5 8，单调栈遍历完则为9 5,这3个没选够，所以何时停止从单调栈里弹出呢？遍历位置以及后面剩余的元素刚好够挑选长度的时候，就不再弹出了（即使单调栈内的元素已经不单调了）</li>
</ul>
</li>
<li>1.4 在下一个问题，对于一个挑选方法，m中挑选l个，n中挑选k-l个，分别得到一个最大字串，如何合并成最终字串呢？<ul>
<li>1.4.1 其实很简单，两个字符串分别维护一个head叫ha，hb吧，若ha比hb大，那么就把ha的值压入最终结果，直到ha &lt; hb，同理移动b即可，但是需要考虑ha == hb的情况，直接比较ha,hb对应的尾串即可，参考如下测试样例即可：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eg1: </span><br><span class="line">[<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">0</span>]</span><br><span class="line">[<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">2</span>]</span><br><span class="line"><span class="number">15</span></span><br><span class="line"></span><br><span class="line">eg2:</span><br><span class="line">[<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">[<span class="number">6</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getMaxConcat</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; longVec, vector&lt;<span class="type">int</span>&gt;&amp; shortVec, <span class="type">int</span> lenInLonger, <span class="type">int</span> lenInShorter)</span> </span>&#123;</span><br><span class="line">        string monoLong, monoShort;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// choose biggest lenInLonger&#x27;s subArr from  longer vec</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; longVec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(monoLong.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; monoLong.<span class="built_in">back</span>() - <span class="string">&#x27;0&#x27;</span> &lt; longVec[i] &amp;&amp; monoLong.<span class="built_in">size</span>() + longVec.<span class="built_in">size</span>() - i &gt; lenInLonger) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;pop_long: &quot; &lt;&lt; monoLong.back() &lt;&lt; &quot; monoLong&#x27;s std len: &quot; &lt;&lt; lenInLonger &lt;&lt; &quot; curback: &quot; &lt;&lt; monoLong.back() &lt;&lt; endl;</span></span><br><span class="line">                monoLong.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(monoLong.<span class="built_in">size</span>() &lt; lenInLonger) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;push_long: in &quot; &lt;&lt; static_cast&lt;char&gt;(longVec[i] + &#x27;0&#x27;) &lt;&lt; endl;</span></span><br><span class="line">                monoLong.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(longVec[i] + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; shortVec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// while(monoLong.back() &lt; longVec[i] &amp;&amp; monoLong.size() &lt;= lenInLonger &amp;&amp; monoLong.size() + longVec.size() - i + 1 &lt; lenInLonger) &#123;</span></span><br><span class="line">            <span class="keyword">while</span>(!monoShort.<span class="built_in">empty</span>() &amp;&amp; monoShort.<span class="built_in">back</span>() - <span class="string">&#x27;0&#x27;</span> &lt; shortVec[i] &amp;&amp; monoShort.<span class="built_in">size</span>() + shortVec.<span class="built_in">size</span>() - i &gt; lenInShorter) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;pop_short: &quot; &lt;&lt; monoShort.back() &lt;&lt; &quot; monoLong&#x27;s std len: &quot; &lt;&lt; lenInShorter &lt;&lt; &quot; curback: &quot; &lt;&lt; monoShort.back() &lt;&lt; endl;</span></span><br><span class="line">                monoShort.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(monoShort.<span class="built_in">size</span>() &lt; lenInShorter) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;push_short: in &quot; &lt;&lt; static_cast&lt;char&gt;(longVec[i] + &#x27;0&#x27;) &lt;&lt; endl;</span></span><br><span class="line">                monoShort.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(shortVec[i] + <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// merger the two biggest substr,</span></span><br><span class="line">        string finalRes = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;longMax and shortMax str: &quot; &lt;&lt; monoLong &lt;&lt; &quot; &quot; &lt;&lt; monoShort &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; monoShort.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; monoLong.<span class="built_in">size</span>() &amp;&amp; monoLong[j] &gt; monoShort[i]) &#123;</span><br><span class="line">                finalRes.<span class="built_in">push_back</span>(monoLong[j++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// decided whether to use long str or short when the char compared is true</span></span><br><span class="line">            <span class="keyword">if</span>(monoLong[j] == monoShort[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(monoLong.<span class="built_in">substr</span>(j) &gt; monoShort.<span class="built_in">substr</span>(i)) &#123;</span><br><span class="line">                    finalRes.<span class="built_in">push_back</span>(monoLong[j++]);</span><br><span class="line">                    i--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            finalRes.<span class="built_in">push_back</span>(monoShort[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        finalRes += monoLong.<span class="built_in">substr</span>(j);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;finalRes string is: &quot; &lt;&lt; finalRes &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> finalRes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;m/n&quot; &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// let k split into nums1 and nums2</span></span><br><span class="line">        <span class="function">string <span class="title">maxStr</span><span class="params">(k, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(m &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> lenInShorter = <span class="built_in">max</span>(<span class="number">0</span>, k - n); lenInShorter &lt;= <span class="built_in">min</span>(m, k); ++lenInShorter) &#123;</span><br><span class="line">                <span class="type">int</span> lenInLonger = k - lenInShorter;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;lenInLong/short&quot; &lt;&lt; lenInLonger &lt;&lt; &quot; &quot; &lt;&lt; lenInShorter &lt;&lt; endl;</span></span><br><span class="line">                string curMax = <span class="built_in">getMaxConcat</span>(nums2, nums1, lenInLonger, lenInShorter);</span><br><span class="line">                maxStr = maxStr &gt; curMax ? maxStr : curMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> lenInShorter = <span class="built_in">max</span>(<span class="number">0</span>, k - m); lenInShorter &lt;= <span class="built_in">min</span>(n, k); ++lenInShorter) &#123;</span><br><span class="line">                <span class="type">int</span> lenInLonger = k - lenInShorter;</span><br><span class="line">                string curMax = <span class="built_in">getMaxConcat</span>(nums1, nums2, lenInLonger, lenInShorter);</span><br><span class="line">                maxStr = maxStr &gt; curMax ? maxStr : curMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : maxStr) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="0768-最多能完成排序的块-II-maxChunksToSroted"><a href="#0768-最多能完成排序的块-II-maxChunksToSroted" class="headerlink" title="0768 最多能完成排序的块 II maxChunksToSroted"></a>0768 最多能完成排序的块 II maxChunksToSroted</h2><h3 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii">https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii</a></p>
<h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li><p>1 普通思路：</p>
<ul>
<li>1.1 利用已经排好序的数组，和当前数组进行比较，得到分块方式，也就是题目的提示：<blockquote>
<p>Each k for which some permutation of arr[:k] is equal to sorted(arr)[:k] is where we should cut each chunk.</p>
</blockquote>
</li>
<li>1.2 具体算法：<ul>
<li>记原数组为arr，然后其排序为sortArr，而后遍历arr，如何确定一个下标k是否为chunk的分割点呢？</li>
<li>使用hashA记录arr[:k]子数组中每个元素的出现次数，使用diffCount<strong>记录arr[:k]和sortArr[:k]（在两个数组里出现次数不同的）元素个数</strong></li>
<li>当diffCount为0，就找到一个k，最后返回所有diffCount为0的地方即可</li>
</ul>
</li>
<li>1.3 普通解法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxChunksToSorted</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// monoStack: every ele in mono represent: the biggest value in a chunk</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// diffCnt, the size of those numbers whose cnt are not equal in arr[:k] and sortArr[:k]</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, n = arr.<span class="built_in">size</span>(), diffCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArr</span><span class="params">(arr)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(sortArr.<span class="built_in">begin</span>(), sortArr.<span class="built_in">end</span>(), std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            ++ hash[arr[k]];</span><br><span class="line">            <span class="keyword">if</span>(hash[arr[k]] == <span class="number">1</span>) &#123;</span><br><span class="line">                diffCnt++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(hash[arr[k]] == <span class="number">0</span>)&#123;</span><br><span class="line">                diffCnt--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            -- hash[sortArr[k]];</span><br><span class="line">            <span class="keyword">if</span>(hash[sortArr[k]] == <span class="number">0</span>) &#123;</span><br><span class="line">                diffCnt--;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(hash[sortArr[k]] == <span class="number">-1</span>) &#123; <span class="comment">// sortArr[k] is redundant</span></span><br><span class="line">                diffCnt++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans += diffCnt == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>2 单调栈：</p>
<ul>
<li>2.1 考虑例子： 1 4 3 7 5，很容易发现，就三个分块，然后arr的单调增栈为1 4 7，刚好为每个分块的最大值，所以有这么一个单调栈定义：<strong>单调栈里存入的数字为每个分块的最大值</strong></li>
<li>2.2 当然这也有问题，会涉及到单调栈需要合并分块的情况： 1 4 3 7 5 2，当没检测到2的时候，单调栈为3个分块，最大值分别为1，4，7，当检测到2的时候，我们需要先弹出所有比2大的分块的最大值，因为2在这些分块后面意味着必须将2和这些分块合并，这样才能保证最终从小到大的排序，然后压入合并的这些分块里的最大值，也就是遇到2之前单调栈的栈顶 7，单调栈变成了1，7</li>
<li>2.3 具体看代码：单调栈解法：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/768-zui-duo-neng-wan-cheng-pai-xu-de-kuai-iihua-do/#%E6%96%B9%E6%B3%95-2-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E6%A0%88">可视化参考</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxChunksToSorted</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// monoStack: every ele in mono represent: the biggest value in a chunk</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; mono = &#123;INT_MIN&#125;; <span class="comment">// from small to bigger</span></span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt;= mono.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                mono.<span class="built_in">emplace_back</span>(arr[i]);</span><br><span class="line">            &#125;  <span class="keyword">else</span> &#123; <span class="comment">// arr[i] &lt; mono.back()</span></span><br><span class="line">                <span class="comment">// merge the chunk untill arr[i] &gt; mono.back()</span></span><br><span class="line">                <span class="type">int</span> curChunkMax = mono.<span class="built_in">back</span>();</span><br><span class="line">                <span class="keyword">while</span>(mono.<span class="built_in">back</span>() &gt; arr[i]) &#123;</span><br><span class="line">                    mono.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                mono.<span class="built_in">emplace_back</span>(curChunkMax);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mono.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="1793-好子数组的最大分数-maximumScore"><a href="#1793-好子数组的最大分数-maximumScore" class="headerlink" title="1793 好子数组的最大分数 maximumScore"></a>1793 好子数组的最大分数 maximumScore</h2><h3 id="1-题目：-2"><a href="#1-题目：-2" class="headerlink" title="1 题目："></a>1 题目：</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-score-of-a-good-subarray/">https://leetcode-cn.com/problems/maximum-score-of-a-good-subarray/</a></p>
<p>类似题目： </p>
<ul>
<li>1 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-rectangle/submissions/">https://leetcode-cn.com/problems/maximal-rectangle/submissions/</a></li>
<li>2 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</a></li>
</ul>
<h3 id="2-解题思路：-2"><a href="#2-解题思路：-2" class="headerlink" title="2 解题思路："></a>2 解题思路：</h3><ul>
<li>1 单调栈：<ul>
<li>1.1 想法很简单，遍历上述的柱状图的一列，栈顶总是最大，栈底最小，一旦有小于等于前栈的值，那么栈里面那些小于等于当前栈顶的值都不可能再在遍历的后续位置发生作用了，因为已经有小于等于它的值出现了，所以我们把这些值弹出然后算弹出的这一部分的体积，那么栈里面剩下的就是任然能够为后续遍历的位置贡献面积的值，所以就是这样，具体的看代码吧。</li>
<li>1.2 计算过程中，我们只有当矩形的两边分别位于k的两边才会更新结果</li>
</ul>
</li>
<li>2 强调单调栈的几个特性(以递增单调栈为例子)<ul>
<li>2.1 栈底一定是整个数组最小的</li>
<li>2.2 弹出当前元素记其下标为j后，当前栈顶元素下标记为i，那么i是第一个下标满足： i &lt; j &amp;&amp; arr[i] &lt;= arr[j]</li>
<li>2.3 **TIPS: **注意单调栈会将所有元素都入栈，但并不会都出栈，很多时候我们要求arr中的每个元素都出栈，那么常见操作为在arr末尾加一个比所有元素都要小的值即可</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// k split nums into left and right</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lPart</span><span class="params">(nums.begin(), nums.begin() + k + <span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// construct the monostack, abscending</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; mono;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = nums[k];</span><br><span class="line">        nums.<span class="built_in">emplace_back</span>(<span class="number">0</span>); <span class="comment">// make sure all the heights are used for nums</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!mono.<span class="built_in">empty</span>() &amp;&amp; nums[mono.<span class="built_in">back</span>()] &gt;= nums[r]) &#123;</span><br><span class="line">                <span class="type">int</span> h = nums[mono.<span class="built_in">back</span>()];</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;h: &quot; &lt;&lt; h &lt;&lt; endl;</span></span><br><span class="line">                mono.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="type">int</span> l = mono.<span class="built_in">empty</span>() ? <span class="number">-1</span> : mono.<span class="built_in">back</span>();</span><br><span class="line">                <span class="type">int</span> w = r - l - <span class="number">1</span>;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;w/r/l/h: &quot;</span> &lt;&lt; w &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; r &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; l &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; h &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">if</span>(r - <span class="number">1</span> &gt;= k &amp;&amp; l + <span class="number">1</span> &lt;= k) &#123;</span><br><span class="line">                    res = <span class="built_in">max</span>(res, w * h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mono.<span class="built_in">emplace_back</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2021/12/30/lcDicTree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/30/lcDicTree/" class="post-title-link" itemprop="url">lcDicTree</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-30 21:08:16" itemprop="dateCreated datePublished" datetime="2021-12-30T21:08:16+08:00">2021-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-字典树、前缀树、Trie"><a href="#1-字典树、前缀树、Trie" class="headerlink" title="1 字典树、前缀树、Trie"></a>1 字典树、前缀树、Trie</h1><p>将一个单词列表使用words组装起来，实现如下：（仅含有小写的字典），可以在log(m)时间内查询一个单词是否在字典中。</p>
<h2 id="1-1-可能的小技巧"><a href="#1-1-可能的小技巧" class="headerlink" title="1.1 可能的小技巧"></a>1.1 可能的小技巧</h2><ul>
<li>1 一些可以想到的优化：<ul>
<li>1.1 如果对一个长串反复查询，则使用一个node指针指向当前查询位于Trie里面的位置，避免反复查询相同的前缀</li>
<li>1.2 如果对一个长串反复查询，尝试使用hash记录尾串的目标信息，避免对尾串反复查询</li>
<li>1.3 逆序建树，构建后缀树等等，见本篇最后两个例子</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;Trie *&gt;curLevel;</span><br><span class="line">    <span class="type">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">curLevel</span>(<span class="number">26</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie * curNode = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : word) &#123;</span><br><span class="line">            c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                curNode-&gt;curLevel[c] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// check nextLevel</span></span><br><span class="line">            curNode = curNode-&gt;curLevel[c];</span><br><span class="line">        &#125;</span><br><span class="line">        curNode-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie * curNode = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : word) &#123;</span><br><span class="line">            c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode-&gt;curLevel[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curNode-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie * curNode = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : prefix) &#123;</span><br><span class="line">            c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode-&gt;curLevel[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-例题"><a href="#2-例题" class="headerlink" title="2 例题"></a>2 例题</h1><h2 id="0212-单词搜索-II"><a href="#0212-单词搜索-II" class="headerlink" title="0212 单词搜索 II"></a>0212 单词搜索 II</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search-ii">https://leetcode-cn.com/problems/word-search-ii</a></p>
<h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 要搜索整个字母棋盘，很自然想到使用回溯</li>
<li>2 要知道一个字符串是否在字典里，很自然想到trie</li>
<li>3 具体解答方法<ul>
<li>3.1 如下代码的注释的backTrack函数很清晰的阐述啦思路，称之为old way</li>
<li>3.2 old way的缺陷，对于tmpRes的前面的公共部分反复调用啦startWith函数重复计算啦，</li>
<li>3.3 改进，使用curNode记录tmpRes在前缀树里面的位置，那么只需要根据curNode来判断tmpRes即将加入的新的字符是否为curNode的子节点就可以啦，提升了速度<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;Trie*&gt; curLevel;</span><br><span class="line">        <span class="type">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> hasNext = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">Trie</span>() : <span class="built_in">curLevel</span>(<span class="number">26</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : word) &#123;</span><br><span class="line">                c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    curNode-&gt;curLevel[c] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">                curNode-&gt;hasNext = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">inTrie</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : word) &#123;</span><br><span class="line">                c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;       </span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> curNode-&gt;isEnd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">startWith</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : word) &#123;</span><br><span class="line">                c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;       </span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">endWith</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : word) &#123;</span><br><span class="line">                c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;       </span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> !curNode-&gt;hasNext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// build trie in normal or reverse order</span></span><br><span class="line">        <span class="comment">// std::shared_ptr&lt;Trie&gt; treeNormal = make_shared&lt;Trie&gt;();</span></span><br><span class="line">        Trie* treeNormal = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        <span class="comment">// std::unique_ptr&lt;Trie&gt; treeReverse = new Trie();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> w : words) &#123;</span><br><span class="line">            treeNormal-&gt;<span class="built_in">insert</span>(w);</span><br><span class="line">            <span class="comment">// treeReverse.insert(reverse(w.begin(), w.end()));</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> deltaX[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> deltaY[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="comment">// get the answer</span></span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        unordered_set&lt;string&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="comment">// std::cout &lt;&lt; &quot;check next st point!&quot; &lt;&lt; endl;</span></span><br><span class="line">                string tmpRes = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">exploredFlag</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">                <span class="built_in">backTrack</span>(i, j, board, tmpRes, res, treeNormal,</span><br><span class="line">                    deltaX, deltaY, exploredFlag, hash</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">[[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],</span></span><br><span class="line"><span class="comment"> [&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],</span></span><br><span class="line"><span class="comment"> [&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],</span></span><br><span class="line"><span class="comment"> [&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]]</span></span><br><span class="line"><span class="comment">[&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;,&quot;oathi&quot;,&quot;oathk&quot;,&quot;oathf&quot;,&quot;oate&quot;,&quot;oathii&quot;,&quot;oathfi&quot;,&quot;oathfii&quot;]</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrack</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string&amp; tmpRes, vector&lt;string&gt;&amp; res, Trie* curNode, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">int</span>* deltaX, <span class="type">const</span> <span class="type">int</span>* deltaY,</span></span></span><br><span class="line"><span class="params"><span class="function">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; exploredFlag,</span></span></span><br><span class="line"><span class="params"><span class="function">    unordered_set&lt;string&gt;&amp; hash)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> ch = board[i][j];</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[ch - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// start from i, j</span></span><br><span class="line">        tmpRes.<span class="built_in">push_back</span>(board[i][j]);</span><br><span class="line">        <span class="comment">// Trie* lastNode = curNode;</span></span><br><span class="line">        curNode = curNode-&gt;curLevel[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;a???&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;start : in &quot; &lt;&lt; i &lt;&lt; &quot;-&gt;&quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; board[i][j] &lt;&lt; &quot;with tmpRes : &quot; &lt;&lt; tmpRes &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// we check the tmpRes directly using the trie</span></span><br><span class="line">        <span class="comment">// if(tree-&gt;inTrie(tmpRes) &amp;&amp; 0 == hash.count(tmpRes)) &#123;</span></span><br><span class="line">        <span class="comment">//     res.emplace_back(tmpRes);</span></span><br><span class="line">        <span class="comment">//     hash.insert(tmpRes);</span></span><br><span class="line">        <span class="comment">//     if(tree-&gt;endWith(tmpRes)) &#123;</span></span><br><span class="line">        <span class="comment">//         tmpRes.pop_back();</span></span><br><span class="line">        <span class="comment">//         return;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> != curNode &amp;&amp; curNode-&gt;isEnd == <span class="literal">true</span> &amp;&amp; <span class="number">0</span> == hash.<span class="built_in">count</span>(tmpRes)) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;find! &gt;&gt;&gt;&gt;&gt; &quot; &lt;&lt; tmpRes &lt;&lt; endl;</span></span><br><span class="line">            res.<span class="built_in">emplace_back</span>(tmpRes);</span><br><span class="line">            hash.<span class="built_in">insert</span>(tmpRes);</span><br><span class="line">            <span class="keyword">if</span>(!curNode-&gt;hasNext) &#123;</span><br><span class="line">                tmpRes.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;current[i, j] : in &quot; &lt;&lt; i &lt;&lt; &quot;-&gt;&quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; board[i][j] &lt;&lt; &quot;with tmpRes : &quot; &lt;&lt; tmpRes &lt;&lt; endl;</span></span><br><span class="line">        exploredFlag[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> != curNode) &#123;</span><br><span class="line">            <span class="comment">// not null</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> mvIdx = <span class="number">0</span>; mvIdx &lt; <span class="number">4</span>; ++mvIdx) &#123;</span><br><span class="line">                <span class="type">int</span> nextX = i + deltaX[mvIdx];</span><br><span class="line">                <span class="type">int</span> nextY = j + deltaY[mvIdx];</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;tryStart: [x, y] :&quot; &lt;&lt; nextX &lt;&lt; &quot; &quot; &lt;&lt; nextY &lt;&lt; endl;;</span></span><br><span class="line">                <span class="keyword">if</span>( nextX &lt; board.<span class="built_in">size</span>() &amp;&amp; nextX &gt;= <span class="number">0</span> &amp;&amp; nextY &lt; board[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; nextY &gt;= <span class="number">0</span> &amp;&amp; \</span><br><span class="line">                    ! exploredFlag[nextX][nextY]) &#123;</span><br><span class="line">                    <span class="built_in">backTrack</span>(nextX, nextY, board, tmpRes, res, curNode,</span><br><span class="line">                        deltaX, deltaY, exploredFlag, hash</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;tryFinish: [x, y] :&quot; &lt;&lt; nextX &lt;&lt; &quot; &quot; &lt;&lt; nextY &lt;&lt; endl;;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exploredFlag[i][j] = <span class="literal">false</span>;</span><br><span class="line">        tmpRes.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OLD WAY TO DO, will exceed the time limitation</span></span><br><span class="line">    <span class="comment">// void backTrack(int i, int j, vector&lt;vector&lt;char&gt;&gt;&amp; board, string&amp; tmpRes, vector&lt;string&gt;&amp; res, unique_ptr&lt;Trie&gt;&amp; tree, </span></span><br><span class="line">    <span class="comment">// const int* deltaX, const int* deltaY,</span></span><br><span class="line">    <span class="comment">// vector&lt;vector&lt;bool&gt;&gt;&amp; exploredFlag,</span></span><br><span class="line">    <span class="comment">// unordered_set&lt;string&gt;&amp; hash) &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     // start from i, j</span></span><br><span class="line">    <span class="comment">//     tmpRes.push_back(board[i][j]);</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     // cout &lt;&lt; &quot;start : in &quot; &lt;&lt; i &lt;&lt; &quot;-&gt;&quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; board[i][j] &lt;&lt; &quot;with tmpRes : &quot; &lt;&lt; tmpRes &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//     if(tree-&gt;inTrie(tmpRes) &amp;&amp; 0 == hash.count(tmpRes)) &#123;</span></span><br><span class="line">    <span class="comment">//         res.emplace_back(tmpRes);</span></span><br><span class="line">    <span class="comment">//         hash.insert(tmpRes);</span></span><br><span class="line">    <span class="comment">//         if(tree-&gt;endWith(tmpRes)) &#123;</span></span><br><span class="line">    <span class="comment">//             tmpRes.pop_back();</span></span><br><span class="line">    <span class="comment">//             return;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     // cout &lt;&lt; &quot;current[i, j] : in &quot; &lt;&lt; i &lt;&lt; &quot;-&gt;&quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; board[i][j] &lt;&lt; &quot;with tmpRes : &quot; &lt;&lt; tmpRes &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//     exploredFlag[i][j] = true;</span></span><br><span class="line">    <span class="comment">//     if(tree-&gt;startWith(tmpRes)) &#123;</span></span><br><span class="line">    <span class="comment">//         for(int mvIdx = 0; mvIdx &lt; 4; ++mvIdx) &#123;</span></span><br><span class="line">    <span class="comment">//             int nextX = i + deltaX[mvIdx];</span></span><br><span class="line">    <span class="comment">//             int nextY = j + deltaY[mvIdx];</span></span><br><span class="line">    <span class="comment">//             if( nextX &lt; board.size() &amp;&amp; \</span></span><br><span class="line"><span class="comment">    //                 nextX &gt;= 0 &amp;&amp; \</span></span><br><span class="line"><span class="comment">    //                 nextY &lt; board[0].size() &amp;&amp; \</span></span><br><span class="line"><span class="comment">    //                 nextY &gt;= 0 &amp;&amp; \</span></span><br><span class="line"><span class="comment">    //                 ! exploredFlag[nextX][nextY]) &#123;</span></span><br><span class="line">    <span class="comment">//                 backTrack(nextX, nextY, board, tmpRes, res, tree,</span></span><br><span class="line">    <span class="comment">//                     deltaX, deltaY, exploredFlag, hash</span></span><br><span class="line">    <span class="comment">//                 );</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             // cout &lt;&lt; &quot;tryFinish: [x, y] :&quot; &lt;&lt; nextX &lt;&lt; &quot; &quot; &lt;&lt; nextY &lt;&lt; endl;;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     exploredFlag[i][j] = false;</span></span><br><span class="line">    <span class="comment">//     tmpRes.pop_back();</span></span><br><span class="line">    <span class="comment">//     // cout &lt;&lt; &quot;current[i, j] : exit &quot; &lt;&lt; i &lt;&lt; &quot;-&gt;&quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; board[i][j] &lt;&lt; &quot;with tmpRes : &quot; &lt;&lt; tmpRes &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="0336-回文对"><a href="#0336-回文对" class="headerlink" title="0336. 回文对"></a>0336. 回文对</h2><h3 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-pairs/">https://leetcode-cn.com/problems/palindrome-pairs/</a></p>
<h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 参考官方解答：<strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-pairs/solution/hui-wen-dui-by-leetcode-solution/">https://leetcode-cn.com/problems/palindrome-pairs/solution/hui-wen-dui-by-leetcode-solution/</a></strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;Trie*&gt; curLevel;</span><br><span class="line">        <span class="type">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> wordIdx = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">Trie</span>() : <span class="built_in">curLevel</span>(<span class="number">26</span>), <span class="built_in">wordIdx</span>(<span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; word, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : word) &#123;</span><br><span class="line">                c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    curNode-&gt;curLevel[c] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">            &#125;</span><br><span class="line">            curNode-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">            curNode-&gt;wordIdx = idx;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">inTrie</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : word) &#123;</span><br><span class="line">                c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> curNode-&gt;wordIdx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">inTrie</span><span class="params">(string&amp; word, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = right; i &gt;= left; --i) &#123;</span><br><span class="line">                <span class="type">char</span> c = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> curNode-&gt;wordIdx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">palindromePairs</span>(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        <span class="comment">// travel all prefix and subfix of a word,</span></span><br><span class="line">        <span class="comment">// find the palindrome and check the existence in the words of</span></span><br><span class="line">        <span class="comment">// reverse of the other part</span></span><br><span class="line">        Trie* tree = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        <span class="comment">// Trie* treeReverse = new Trie();</span></span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; strToIdx;</span><br><span class="line">        <span class="comment">// int idx = 0;</span></span><br><span class="line">        <span class="comment">// for(auto word : words) &#123;</span></span><br><span class="line">        <span class="comment">//     tree-&gt;insert(word);</span></span><br><span class="line">        <span class="comment">//     strToIdx[word] = idx++;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// int ans = 0;</span></span><br><span class="line">        <span class="comment">// vector&lt;vector&lt;int&gt;&gt; res = &#123;&#125;;</span></span><br><span class="line">        <span class="comment">// for(auto word : words) &#123;</span></span><br><span class="line">        <span class="comment">//     deque&lt;string&gt; prefix; </span></span><br><span class="line">        <span class="comment">//     deque&lt;string&gt; subfix;</span></span><br><span class="line">        <span class="comment">//     int n = word.size();</span></span><br><span class="line">        <span class="comment">//     for(int st = 0; st &lt;= n; ++st) &#123;</span></span><br><span class="line">        <span class="comment">//         string pre = word.substr(0, st);</span></span><br><span class="line">        <span class="comment">//         string sub = word.substr(st);</span></span><br><span class="line">        <span class="comment">//         // cout &lt;&lt; &quot;p/s : &quot; &lt;&lt; pre &lt;&lt; &quot; / &quot; &lt;&lt; sub &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//         if(checkPalindrome(pre)) &#123;</span></span><br><span class="line">        <span class="comment">//             reverse(sub.begin(), sub.end());</span></span><br><span class="line">        <span class="comment">//             if(tree-&gt;inTrie(sub)) &#123;</span></span><br><span class="line">        <span class="comment">//                 vector&lt;int&gt; resItem = &#123;strToIdx[sub], strToIdx[word]&#125;;</span></span><br><span class="line">        <span class="comment">//                 if(resItem[1] != resItem[0]) &#123;</span></span><br><span class="line">        <span class="comment">//                     // cout &lt;&lt; &quot;push: &quot; &lt;&lt; word + sub &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//                     res.emplace_back(resItem);</span></span><br><span class="line">        <span class="comment">//                 &#125;</span></span><br><span class="line">        <span class="comment">//             &#125;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         if(checkPalindrome(sub) &amp;&amp; pre.size() != n) &#123;</span></span><br><span class="line">        <span class="comment">//             reverse(pre.begin(), pre.end());</span></span><br><span class="line">        <span class="comment">//             if(tree-&gt;inTrie(pre)) &#123;</span></span><br><span class="line">        <span class="comment">//                 vector&lt;int&gt; resItem = &#123;strToIdx[word], strToIdx[pre]&#125;;</span></span><br><span class="line">        <span class="comment">//                 if(resItem[1] != resItem[0]) &#123;</span></span><br><span class="line">        <span class="comment">//                     // cout &lt;&lt; &quot;push: &quot; &lt;&lt; pre + word &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//                     res.emplace_back(vector&lt;int&gt;(resItem));</span></span><br><span class="line">        <span class="comment">//                 &#125;</span></span><br><span class="line">        <span class="comment">//             &#125;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : words) &#123;</span><br><span class="line">            <span class="comment">// tree-&gt;insert(word, idx);</span></span><br><span class="line">            <span class="comment">// reverse(word.begin(), word.end());</span></span><br><span class="line">            tree-&gt;<span class="built_in">insert</span>(word, idx);</span><br><span class="line">            ++idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> curWordIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : words) &#123;</span><br><span class="line">            <span class="type">int</span> n = word.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> st = <span class="number">0</span>; st &lt;= n; ++st) &#123;</span><br><span class="line">                string pre = word.<span class="built_in">substr</span>(<span class="number">0</span>, st);</span><br><span class="line">                string sub = word.<span class="built_in">substr</span>(st);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;p/s : &quot; &lt;&lt; pre &lt;&lt; &quot; / &quot; &lt;&lt; sub &lt;&lt; &quot; curWordIdx : &quot; &lt;&lt; curWordIdx &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">// if(checkPalindrome(pre)) &#123;</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> != st &amp;&amp; <span class="built_in">checkPalindrome</span>(word, <span class="number">0</span>, st<span class="number">-1</span>)) &#123;</span><br><span class="line">                    <span class="comment">// reverse(sub.begin(), sub.end());</span></span><br><span class="line">                    <span class="type">int</span> subIdx = tree-&gt;<span class="built_in">inTrie</span>(word, st, n<span class="number">-1</span>);</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; &quot;subIdx = &quot; &lt;&lt; sub &lt;&lt; &quot;with idx = &quot; &lt;&lt; subIdx &lt;&lt; endl;</span></span><br><span class="line">                    <span class="keyword">if</span>(subIdx != <span class="number">-1</span> &amp;&amp; curWordIdx != subIdx) &#123;</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; &quot;curWordIdx / subIdx&quot; &lt;&lt; curWordIdx &lt;&lt; &quot;/&quot; &lt;&lt; subIdx &lt;&lt; endl;</span></span><br><span class="line">                        <span class="comment">// cout &lt;&lt; &quot;push: &quot; &lt;&lt;  sub &lt;&lt; &quot;+&quot; &lt;&lt; word &lt;&lt; endl;</span></span><br><span class="line">                        res.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;subIdx, curWordIdx&#125;));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">checkPalindrome</span>(word, st, n<span class="number">-1</span>)) &#123;</span><br><span class="line">                    <span class="comment">// reverse(pre.begin(), pre.end());</span></span><br><span class="line">                    <span class="type">int</span> preIdx = tree-&gt;<span class="built_in">inTrie</span>(word, <span class="number">0</span>, st<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(preIdx != <span class="number">-1</span> &amp;&amp; preIdx != curWordIdx) &#123;</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; &quot;curWordIdx / preIdx&quot; &lt;&lt; curWordIdx &lt;&lt; &quot;/&quot; &lt;&lt; preIdx &lt;&lt; endl;</span></span><br><span class="line">                        <span class="comment">// cout &lt;&lt; &quot;push: &quot; &lt;&lt; pre &lt;&lt; &quot;+&quot; + word &lt;&lt; endl;</span></span><br><span class="line">                        res.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;curWordIdx, preIdx&#125;));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            ++curWordIdx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     int m = words[i].size();</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt;= m; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         if (isPalindrome(words[i], j, m - 1)) &#123;</span></span><br><span class="line">        <span class="comment">//             int left_id = findWord(words[i], 0, j - 1);</span></span><br><span class="line">        <span class="comment">//             if (left_id != -1 &amp;&amp; left_id != i) &#123;</span></span><br><span class="line">        <span class="comment">//                 ret.push_back(&#123;i, left_id&#125;);</span></span><br><span class="line">        <span class="comment">//             &#125;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         if (j &amp;&amp; isPalindrome(words[i], 0, j - 1)) &#123;</span></span><br><span class="line">        <span class="comment">//             int right_id = findWord(words[i], j, m - 1);</span></span><br><span class="line">        <span class="comment">//             if (right_id != -1 &amp;&amp; right_id != i) &#123;</span></span><br><span class="line">        <span class="comment">//                 ret.push_back(&#123;right_id, i&#125;);</span></span><br><span class="line">        <span class="comment">//             &#125;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkPalindrome</span><span class="params">(string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left + i] != s[right - i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// bool checkPalindrome(string&amp; s) &#123;</span></span><br><span class="line">    <span class="comment">//     int n = s.size();</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; n / 2; ++i) &#123;</span></span><br><span class="line">    <span class="comment">//         if(s[i] != s[n - i - 1]) &#123;</span></span><br><span class="line">    <span class="comment">//             return false;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return true;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-使用hash表来查前后缀"><a href="#3-使用hash表来查前后缀" class="headerlink" title="3 使用hash表来查前后缀"></a>3 使用hash表来查前后缀</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;Trie*&gt; curLevel;</span><br><span class="line">        <span class="type">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> wordIdx = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">Trie</span>() : <span class="built_in">curLevel</span>(<span class="number">26</span>), <span class="built_in">wordIdx</span>(<span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; word, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : word) &#123;</span><br><span class="line">                c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    curNode-&gt;curLevel[c] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">            &#125;</span><br><span class="line">            curNode-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">            curNode-&gt;wordIdx = idx;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">inTrie</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : word) &#123;</span><br><span class="line">                c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> curNode-&gt;wordIdx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">inTrie</span><span class="params">(string&amp; word, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = right; i &gt;= left; --i) &#123;</span><br><span class="line">                <span class="type">char</span> c = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> curNode-&gt;wordIdx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    vector&lt;string&gt; wordReverse;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; strToIdx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findWord</span><span class="params">(string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        string tmp = s.<span class="built_in">substr</span>(left, right - left + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> it = strToIdx.<span class="built_in">find</span>(tmp);</span><br><span class="line">        <span class="type">int</span> res = it == strToIdx.<span class="built_in">end</span>() ? <span class="number">-1</span> : it-&gt;second;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;finding: &quot; &lt;&lt; tmp &lt;&lt; &quot; with ans = &quot; &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">palindromePairs</span>(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        <span class="comment">// travel all prefix and subfix of a word,</span></span><br><span class="line">        <span class="comment">// find the palindrome and check the existence in the words of</span></span><br><span class="line">        <span class="comment">// reverse of the other part</span></span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : words) &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>());</span><br><span class="line">            wordReverse.<span class="built_in">emplace_back</span>(word);</span><br><span class="line">            strToIdx[word] = idx;</span><br><span class="line">            ++idx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> curWordIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : words) &#123;</span><br><span class="line">            <span class="type">int</span> n = word.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> st = <span class="number">0</span>; st &lt;= n; ++st) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;p/s : &quot; &lt;&lt; &quot; / &quot; &lt;&lt; &quot; curWordIdx : &quot; &lt;&lt; curWordIdx &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> != st &amp;&amp; <span class="built_in">checkPalindrome</span>(word, <span class="number">0</span>, st<span class="number">-1</span>)) &#123;</span><br><span class="line">                    <span class="type">int</span> subIdx = <span class="built_in">findWord</span>(word, st, n<span class="number">-1</span>);</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; &quot;subIdx = &quot; &lt;&lt; subIdx &lt;&lt; endl;</span></span><br><span class="line">                    <span class="keyword">if</span>(subIdx != <span class="number">-1</span> &amp;&amp; curWordIdx != subIdx) &#123;</span><br><span class="line">                        res.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;subIdx, curWordIdx&#125;));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">checkPalindrome</span>(word, st, n<span class="number">-1</span>)) &#123;</span><br><span class="line">                    <span class="type">int</span> preIdx = <span class="built_in">findWord</span>(word, <span class="number">0</span>, st<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(preIdx != <span class="number">-1</span> &amp;&amp; preIdx != curWordIdx) &#123;</span><br><span class="line">                        res.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;curWordIdx, preIdx&#125;));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            ++curWordIdx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkPalindrome</span><span class="params">(string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left + i] != s[right - i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0140-单词拆分-II"><a href="#0140-单词拆分-II" class="headerlink" title="0140. 单词拆分 II"></a>0140. 单词拆分 II</h2><h3 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break-ii/">https://leetcode-cn.com/problems/word-break-ii/</a></p>
<h3 id="2-解题思路-2"><a href="#2-解题思路-2" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 首先确定搜索思路：<ul>
<li>1.1 很显然这个问题的解答思路不会随着问题规模的减小而改变，于是采用递归/回溯方案 </li>
<li>1.2 由于需要确认当前子问题处于什么位置，于是采用回溯</li>
<li>1.3 回溯方法<ul>
<li>1.3.1 每次在头部尝试字符串headWord，直到找到<strong>一个在字典里面的headWord</strong></li>
<li>1.3.2 将原来字符串去掉headWord，然后递归到下一层</li>
<li>1.3.3 当前的headWord的所有可能尝试完毕，则回溯到尝试headWord之前，然后去尝试下一个headWord</li>
</ul>
</li>
<li>1.4 以上可以看出回溯和递归的区别，递归不带有当前搜索状态，而回溯需要维持搜索状态</li>
</ul>
</li>
<li>2 有了大体思路，那么如何解决: 找到<strong>一个在字典里面的headWord</strong>?<ul>
<li>2.1 采用字典前缀树即可快速获得该字符串是否在字典树里面，复杂度为O(m)，m为字典树中的<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;Trie*&gt; curLevel;</span><br><span class="line">        <span class="type">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Trie</span>() : <span class="built_in">curLevel</span>(<span class="number">26</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word )</span> </span>&#123;</span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : word) &#123;</span><br><span class="line">                c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    curNode-&gt;curLevel[c] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">            &#125;</span><br><span class="line">            curNode-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">inTrie</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : word) &#123;</span><br><span class="line">                c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> curNode-&gt;isEnd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">startWith</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : word) &#123;</span><br><span class="line">                c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// implement a trie to sort the word Dict</span></span><br><span class="line">        Trie* tree = <span class="keyword">new</span> Solution::<span class="built_in">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span>(string s : wordDict) &#123;</span><br><span class="line">            tree-&gt;<span class="built_in">insert</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; tmpRes;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="built_in">backTrack</span>(s, tmpRes, res, tree);</span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; finalRes;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; strVec : res) &#123;</span><br><span class="line">            string resItem = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str : strVec) &#123;</span><br><span class="line">                resItem += (str + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            finalRes.<span class="built_in">emplace_back</span>(resItem.<span class="built_in">substr</span>(<span class="number">0</span>, resItem.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalRes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrack</span><span class="params">(string s, vector&lt;string&gt; tmpRes, vector&lt;vector&lt;string&gt;&gt;&amp; res, Trie* trie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(tmpRes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// try every possibility</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            string headWord = s.<span class="built_in">substr</span>(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">            tmpRes.<span class="built_in">emplace_back</span>(headWord);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;head -&gt; &quot; &lt;&lt; headWord &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(trie-&gt;<span class="built_in">inTrie</span>(headWord)) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;in it!&quot; &lt;&lt; endl;</span></span><br><span class="line">                <span class="built_in">backTrack</span>(s.<span class="built_in">substr</span>(i + <span class="number">1</span>), tmpRes, res, trie);</span><br><span class="line">            &#125;</span><br><span class="line">            tmpRes.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="0472-连接词"><a href="#0472-连接词" class="headerlink" title="0472. 连接词"></a>0472. 连接词</h2><h3 id="1-题目-3"><a href="#1-题目-3" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/concatenated-words/">https://leetcode-cn.com/problems/concatenated-words/</a></p>
<h3 id="2-解题思路-3"><a href="#2-解题思路-3" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 首先很容易想到一点：<ul>
<li>1.1 由于需要快速定位一个单词是否在字典里，则采用字典树获取该信息</li>
<li>1.2 对于一个单词，我们对于每个isEnd(也就是搜索前缀对应的单词在字典里)的位置，都从下一个字符从新开始在字典中匹配，然后每个isEnd位置后面的字符，需要继续匹配，eg：[cat, cats, catsdog, dog]，对于catsdog，从sdog和dog分别重新匹配</li>
<li>1.3 对于一个单词，它的构成成分比他小，于是将字符串排序，一边插入，一边找</li>
</ul>
</li>
<li>2 通过后缀记忆剪枝dfs, eg: 对于[“a”, “aa”, “aaaa”, “aaaakaa”]中的aaaakaa，运行代码会有如下日志：<ul>
<li>因为在第一次 a,a,a,a,k的时候记录了k位置往后的后缀无法成功匹配</li>
<li>那么对于后面的 aa,a,a,k以及aaa,a,k等等搜索都会直接跳过k后缀的匹配<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">when checking : aaaakaa the sufix start <span class="keyword">from</span> pos : <span class="number">4</span> has been validated to be failure!</span><br><span class="line">when checking : aaaakaa the sufix start <span class="keyword">from</span> pos : <span class="number">3</span> has been validated to be failure!</span><br><span class="line">when checking : aaaakaa the sufix start <span class="keyword">from</span> pos : <span class="number">2</span> has been validated to be failure!</span><br><span class="line">when checking : aaaakaa the sufix start <span class="keyword">from</span> pos : <span class="number">4</span> has been validated to be failure!</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        vector&lt;Trie*&gt; curLevel;</span><br><span class="line">        <span class="type">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// bool hasNext = false;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">Trie</span>() : <span class="built_in">curLevel</span>(<span class="number">26</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; s, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;inserting : &quot; &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">                c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    curNode-&gt;curLevel[c] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">                <span class="comment">// curNode-&gt;hasNext = true;</span></span><br><span class="line">            &#125;</span><br><span class="line">            curNode-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findAllConcatenatedWordsInADict</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        Trie* tree = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// build trie</span></span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](string&amp; a, string&amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> w : words) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;-------checking &quot; &lt;&lt; w &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// bool ableToConnect = false;</span></span><br><span class="line">            <span class="comment">// findMaxConnectedCnt(w, 0, tree, 0, ableToConnect);</span></span><br><span class="line">            <span class="comment">// if(ableToConnect ) &#123;</span></span><br><span class="line">            <span class="comment">//     ans.emplace_back(w);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">trap</span><span class="params">(w.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfsToCheck</span>(w, <span class="number">0</span>, tree, <span class="number">0</span>, trap)) &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(w);</span><br><span class="line">            &#125;</span><br><span class="line">            tree-&gt;<span class="built_in">insert</span>(words[idx], idx);</span><br><span class="line">            ++idx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// here we search all the possible ways, but we only need one possible way, so we need return early</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findMaxConnectedCnt</span><span class="params">(string&amp; s, <span class="type">int</span> pos, Trie* root, <span class="type">int</span> curCnt, <span class="type">bool</span>&amp; ableToConnect)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == pos) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curCnt &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                ableToConnect = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;&lt;&lt;&lt;&lt;&lt;&lt; finish one!&quot;  &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> curPos = pos;</span><br><span class="line">        Trie* curNode = root;</span><br><span class="line">        <span class="keyword">while</span>(curPos &lt; s.<span class="built_in">size</span>()) &#123; <span class="comment">// serach all prefix</span></span><br><span class="line">            <span class="type">int</span> ch = s[curPos] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> != curNode-&gt;curLevel[ch]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(curNode-&gt;curLevel[ch]-&gt;isEnd) &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt; curPos: &quot; &lt;&lt; curPos &lt;&lt; &quot; char is &quot; &lt;&lt; s[curPos] &lt;&lt; &quot; dive with curCnt: &quot; &lt;&lt; curCnt &lt;&lt; endl;</span></span><br><span class="line">                    <span class="comment">// using this or next end</span></span><br><span class="line">                    <span class="built_in">findMaxConnectedCnt</span>(s, curPos + <span class="number">1</span>, root, curCnt + <span class="number">1</span>, ableToConnect);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;curPos: &quot; &lt;&lt; curPos &lt;&lt; &quot; char is &quot; &lt;&lt; s[curPos] &lt;&lt; &quot; with curCnt: &quot; &lt;&lt; curCnt &lt;&lt; endl;</span></span><br><span class="line">            curNode = curNode-&gt;curLevel[ch];</span><br><span class="line">            ++curPos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfsToCheck</span><span class="params">(string&amp; s, <span class="type">int</span> pos, Trie* root, <span class="type">int</span> curCnt, vector&lt;<span class="type">bool</span>&gt;&amp; trap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == pos) &#123;</span><br><span class="line">            <span class="keyword">return</span> curCnt &gt;= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(trap[pos]) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;when checking : &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot; the sufix start from pos : &quot;</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot; has been validated to be failure!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> curPos = pos;</span><br><span class="line">        Trie* curNode = root;</span><br><span class="line">        <span class="keyword">while</span>(curPos &lt; s.<span class="built_in">size</span>()) &#123; <span class="comment">// serach all prefix</span></span><br><span class="line">            <span class="type">int</span> ch = s[curPos] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> != curNode) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> != curNode-&gt;curLevel[ch]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(curNode-&gt;curLevel[ch]-&gt;isEnd) &#123;</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt; curPos: &quot; &lt;&lt; curPos &lt;&lt; &quot; char is &quot; &lt;&lt; s[curPos] &lt;&lt; &quot; dive with curCnt: &quot; &lt;&lt; curCnt &lt;&lt; endl;</span></span><br><span class="line">                        <span class="comment">// using this or next end</span></span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">dfsToCheck</span>(s, curPos + <span class="number">1</span>, root, curCnt + <span class="number">1</span>, trap)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;curPos: &quot; &lt;&lt; curPos &lt;&lt; &quot; char is &quot; &lt;&lt; s[curPos] &lt;&lt; &quot; with curCnt: &quot; &lt;&lt; curCnt &lt;&lt; endl;</span></span><br><span class="line">            curNode = curNode-&gt;curLevel[ch];</span><br><span class="line">            ++curPos;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        trap[pos] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0745WordFilter-前缀和后缀搜索"><a href="#0745WordFilter-前缀和后缀搜索" class="headerlink" title="0745WordFilter 前缀和后缀搜索"></a>0745WordFilter 前缀和后缀搜索</h2><h3 id="1-题目-4"><a href="#1-题目-4" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/prefix-and-suffix-search/">https://leetcode-cn.com/problems/prefix-and-suffix-search/</a></p>
<h3 id="2-解题思路-4"><a href="#2-解题思路-4" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 构建后缀拼接前缀树<br>1.1 参考解释即可：<blockquote>
<p>  For a word like “test”, consider “#test”, “t#test”, “st#test”, “est#test”, “test#test”. Then if we have a query like prefix = “te”, suffix = “t”, we can find it by searching for something we’ve inserted starting with “t#te”. </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordFilter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// containning suffix</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;Trie*&gt; curLevel;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">Trie</span>() : <span class="built_in">curLevel</span>(<span class="number">27</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; word, <span class="type">int</span> idx, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right; ++i) &#123;</span><br><span class="line">                <span class="type">char</span> c = word[i];</span><br><span class="line">                c = (c == <span class="string">&#x27;#&#x27;</span> ? <span class="number">26</span> : c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    curNode-&gt;curLevel[c] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">                curNode-&gt;idx = idx;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode-&gt;idx = idx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">startWith</span><span class="params">(string&amp; word)</span> </span>&#123;</span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="type">int</span> lastIdx = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : word) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;checking char: &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line">                c = (c == <span class="string">&#x27;#&#x27;</span> ? <span class="number">26</span> : c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> curNode-&gt;idx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Trie* tree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">WordFilter</span>(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> wIdx = <span class="number">0</span>; wIdx &lt; words.<span class="built_in">size</span>(); ++wIdx) &#123;</span><br><span class="line">            <span class="type">int</span> n = words[wIdx].<span class="built_in">size</span>();</span><br><span class="line">            string word = words[wIdx] + <span class="string">&quot;#&quot;</span> + words[wIdx];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="comment">// string tmp = word.substr(j);</span></span><br><span class="line">                <span class="comment">// overwrite those who start with a same suffix and prefix</span></span><br><span class="line">                <span class="comment">// cout &lt;&lt;&quot;insert : &quot; &lt;&lt; tmp &lt;&lt; endl;</span></span><br><span class="line">                tree-&gt;<span class="built_in">insert</span>(word, wIdx, j, <span class="number">2</span>*n +<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(string prefix, string suffix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        string tmp = suffix + <span class="string">&quot;#&quot;</span> + prefix;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;target &gt;&gt; &quot; &lt;&lt; tmp &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> tree-&gt;<span class="built_in">startWith</span>(tmp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1032-字符流-StreamChecke"><a href="#1032-字符流-StreamChecke" class="headerlink" title="1032. 字符流 StreamChecke"></a>1032. 字符流 StreamChecke</h2><h3 id="1-题目-5"><a href="#1-题目-5" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/stream-of-characters/">https://leetcode-cn.com/problems/stream-of-characters/</a></p>
<h3 id="2-解题思路-5"><a href="#2-解题思路-5" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 倒序建立搜索树即可，因为可以观察到，总是从字符流的倒序开始查询<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StreamChecker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;Trie*&gt; curLevel;</span><br><span class="line">        <span class="type">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Trie</span>() : <span class="built_in">curLevel</span>(<span class="number">26</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; word)</span> </span>&#123;</span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="type">int</span> n = word.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="type">char</span> c = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    curNode-&gt;curLevel[c] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">            &#125;</span><br><span class="line">            curNode-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">inTrie</span><span class="params">(string&amp; word)</span> </span>&#123;</span><br><span class="line">            Trie* curNode = <span class="keyword">this</span>;</span><br><span class="line">            <span class="type">int</span> n = word.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="type">char</span> c = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == curNode-&gt;curLevel[c]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curNode-&gt;curLevel[c]-&gt;isEnd) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;curLevel[c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> curNode-&gt;isEnd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Trie* root;</span><br><span class="line">    string curStr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">StreamChecker</span>(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; w : words) &#123;</span><br><span class="line">            root-&gt;<span class="built_in">insert</span>(w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">char</span> letter)</span> </span>&#123;</span><br><span class="line">        curStr += letter;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;<span class="built_in">inTrie</span>(curStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StreamChecker object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StreamChecker* obj = new StreamChecker(words);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;query(letter);</span></span><br><span class="line"><span class="comment"> *</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2021/12/28/alogRabinKarp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/28/alogRabinKarp/" class="post-title-link" itemprop="url">rabinKarp - 拉宾 - 卡普算法 o(n)匹配字符串</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-28 21:24:19" itemprop="dateCreated datePublished" datetime="2021-12-28T21:24:19+08:00">2021-12-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="0-拉宾-卡普算法"><a href="#0-拉宾-卡普算法" class="headerlink" title="0 拉宾-卡普算法"></a>0 拉宾-卡普算法</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8B%89%E5%AE%BE-%E5%8D%A1%E6%99%AE%E7%AE%97%E6%B3%95">来自wiki</a><br>在计算机科学中，拉宾-卡普算法（英語：Rabin–Karp algorithm）或卡普-拉宾算法（Karp–Rabin algorithm），是一种由理查德·卡普与迈克尔·拉宾于1987年提出的、使用散列函数以在文本中搜寻单个模式串的字符串搜索算法单次匹配。该算法先使用旋转哈希以快速筛出无法与给定串匹配的文本位置，此后对剩余位置能否成功匹配进行检验。此算法可推广到用于在文本搜寻单个模式串的所有匹配或在文本中搜寻多个模式串的匹配。</p>
<h2 id="1-算法本身主要思想"><a href="#1-算法本身主要思想" class="headerlink" title="1 算法本身主要思想"></a>1 算法本身主要思想</h2><ul>
<li>1 朴素匹配： text = “abcdefabc”长度为n，去匹配长度为m的模式串abc，<ul>
<li>具体做法则是找出所有长度为m的字串，然后为每一个m字串去匹配模式串abc，复杂度为O(nm)</li>
</ul>
</li>
<li>2 使用拉宾-卡普算法改进：<ul>
<li>2.1 找出了所有长度为m的字串，那么能不能在O(1)的时间内去判断两个长度为m的字串是否相等？</li>
<li>2.2 很自然的想到hash，那么如何计算一个字串的hash？比如abc，使用26进制编码(因为text中只有小写字母)即可： hash(abc) = 26^2 * (‘a’ - ‘a’) + 26^1 * (‘b’ - ‘a’) + 26^0 * (‘c’ - ‘a’);</li>
<li>2.3 很容易注意到上面，若字符串很长，比如100，那么hash值就有26^100，显然太大，需要取模，取模后带来问题，造成hash碰撞，则需要散列，常用的有<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8B%89%E5%AE%BE%E6%8C%87%E7%BA%B9">拉宾指纹</a>，我们可以使用两个不同模算出来一对hash值当做为一个整体hash，降低hash碰撞的概率</li>
<li>2.4 那么计算hash明明需要读取模式串，复杂度为O(m)啊？<ul>
<li>那是因为对于text，我们只需要计算第一个长度为m的字串的hash，后面的字串hash都可以通过O(1)时间获取：</li>
<li>直接看图：<img src="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/rabinKarp.hzik0od3kjc.webp" alt="o(1)算hash">，<a target="_blank" rel="noopener" href="https://coolcao.com/2020/08/20/rabin-karp/">图片来源</a></li>
<li>解释： ft_i为第i个字串的hash，在o(1)时间内得到ft_i+1的方案就如图所示，或者看如下例子的代码的check函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="1044-最长重复子串-longestDupSubstring"><a href="#1044-最长重复子串-longestDupSubstring" class="headerlink" title="1044. 最长重复子串 longestDupSubstring"></a>1044. 最长重复子串 longestDupSubstring</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-duplicate-substring/">https://leetcode-cn.com/problems/longest-duplicate-substring/</a></p>
<h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>0 使用官方思路： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-duplicate-substring/solution/zui-chang-zhong-fu-zi-chuan-by-leetcode-0i9rd/">rabin-karp + binarySearch</a></li>
<li>1 这里需要使用rabin-karp算法，在长度为n的text中寻找长度为m的模式串，其复杂度为o(m)，然后用二分法去确定最长字符串的长度，故整体复杂度为O(n logn)，拉宾-卡普算法参考：<a href="https://xychen5.github.io/2021/12/28/rabinKarp/">https://xychen5.github.io/2021/12/28/rabinKarp/</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">long</span> <span class="type">long</span>&gt; pll;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> big = <span class="number">1000000006</span>;</span><br><span class="line">    <span class="comment">// cal: a^m % mod, when m = 1000, a = 26, there will be overflow</span></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> m, <span class="type">int</span> mod)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> curNum = a;</span><br><span class="line">        <span class="keyword">while</span>(m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(m % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = ans * curNum % mod;       </span><br><span class="line">                <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">if</span>(ans &lt; <span class="number">0</span>) &#123; </span><br><span class="line">                    ans += mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            curNum = curNum * curNum % mod;</span><br><span class="line">            <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">if</span>(curNum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                curNum += mod;</span><br><span class="line">            &#125;</span><br><span class="line">            m /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return st of substr with len = len</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> len, <span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> mod1, <span class="type">int</span> mod2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> powA1 = <span class="built_in">pow</span>(a1, len, mod1);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> powA2 = <span class="built_in">pow</span>(a2, len, mod2);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> hashA1 = <span class="number">0</span>, hashA2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;d2.5&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// cal hash of the first substr</span></span><br><span class="line">        <span class="comment">// hashA1 = arr[0] * a1^(len-1) + arr[1] * a1^(len-2) + ... + arr[len-1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            hashA1 = (hashA1 * a1 % mod1 + arr[i]) % mod1;</span><br><span class="line">            hashA2 = (hashA2 * a2 % mod2 + arr[i]) % mod2;</span><br><span class="line">            hashA1 += hashA1 &gt;= <span class="number">0</span> ? <span class="number">0</span> : mod1;</span><br><span class="line">            hashA2 += hashA2 &gt;= <span class="number">0</span> ? <span class="number">0</span> : mod2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;d3&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// calculate all substr&#x27;s hash with len = len</span></span><br><span class="line">        set&lt;pll&gt; seen;</span><br><span class="line">        seen.<span class="built_in">emplace</span>(hashA1, hashA2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> st = <span class="number">1</span>; st &lt;= n - len; ++st) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;d4&quot; &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// O(1) to cal next hash</span></span><br><span class="line">            hashA1 = (hashA1 * a1 % mod1 - arr[st - <span class="number">1</span>] * powA1 % mod1 + arr[st + len - <span class="number">1</span>]) % mod1;</span><br><span class="line">            hashA2 = (hashA2 * a2 % mod2 - arr[st - <span class="number">1</span>] * powA2 % mod2 + arr[st + len - <span class="number">1</span>]) % mod2;</span><br><span class="line">            hashA1 += hashA1 &gt;= <span class="number">0</span> ? <span class="number">0</span> : mod1;</span><br><span class="line">            hashA2 += hashA2 &gt;= <span class="number">0</span> ? <span class="number">0</span> : mod2;</span><br><span class="line">            <span class="comment">// before cursubstr, there is a same one</span></span><br><span class="line">            <span class="keyword">if</span>(seen.<span class="built_in">count</span>(<span class="built_in">make_pair</span>(hashA1, hashA2))) &#123;</span><br><span class="line">                <span class="keyword">return</span> st;</span><br><span class="line">            &#125;</span><br><span class="line">            seen.<span class="built_in">emplace</span>(hashA1, hashA2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestDupSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// code the string</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            arr[i] = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// two random base and mod</span></span><br><span class="line">        <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="type">int</span> a1 = <span class="built_in">random</span>()%<span class="number">75</span> + <span class="number">26</span>;</span><br><span class="line">        <span class="type">int</span> a2 = <span class="built_in">random</span>()%<span class="number">75</span> + <span class="number">26</span>;</span><br><span class="line">        <span class="type">int</span> mod1 = <span class="built_in">random</span>()%(INT_MAX - big) + big;</span><br><span class="line">        <span class="type">int</span> mod2 = <span class="built_in">random</span>()%(INT_MAX - big) + big;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// bin search the length of longest dup substr</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> finalSt = <span class="number">-1</span>, finalLen = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="comment">// m represents target len</span></span><br><span class="line">            <span class="comment">// int m = (l + r) / 2; </span></span><br><span class="line">            <span class="type">int</span> m = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>; </span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;d1&quot; &lt;&lt; endl;</span></span><br><span class="line">            <span class="type">int</span> st = <span class="built_in">check</span>(arr, m, a1, a2, mod1, mod2);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;d2&quot; &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(st != <span class="number">-1</span>) &#123;</span><br><span class="line">                finalLen = m;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">                finalSt = st;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalLen == <span class="number">-1</span> ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(finalSt, finalLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2021/12/19/dataStructure-SegmentTree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/19/dataStructure-SegmentTree/" class="post-title-link" itemprop="url">dataStructure_SegmentTree - 线段树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-19 19:49:30" itemprop="dateCreated datePublished" datetime="2021-12-19T19:49:30+08:00">2021-12-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-线段树原理"><a href="#1-线段树原理" class="headerlink" title="1 线段树原理"></a>1 线段树原理</h2><h3 id="1-1-数组实现"><a href="#1-1-数组实现" class="headerlink" title="1.1 数组实现"></a>1.1 数组实现</h3><h3 id="1-2-线段树树形实现"><a href="#1-2-线段树树形实现" class="headerlink" title="1.2 线段树树形实现"></a>1.2 线段树树形实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SegTree</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="keyword">struct</span> <span class="title class_">SegNode</span> &#123;</span><br><span class="line">           <span class="type">long</span> <span class="type">long</span>  leftBound = <span class="number">0</span>, rightBound = <span class="number">0</span>, curSum = <span class="number">0</span>;</span><br><span class="line">           SegNode* lChild = <span class="literal">nullptr</span>;</span><br><span class="line">           SegNode* rChild = <span class="literal">nullptr</span>;</span><br><span class="line">           <span class="built_in">SegNode</span>(<span class="type">long</span> <span class="type">long</span> lb, <span class="type">long</span> <span class="type">long</span> rb) :</span><br><span class="line">               <span class="built_in">leftBound</span>(lb),</span><br><span class="line">               <span class="built_in">rightBound</span>(rb),</span><br><span class="line">               <span class="built_in">curSum</span>(<span class="number">0</span>),</span><br><span class="line">               <span class="built_in">lChild</span>(<span class="literal">nullptr</span>),</span><br><span class="line">               <span class="built_in">rChild</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       SegNode* root;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">SegTree</span>(<span class="type">long</span> <span class="type">long</span>  left, <span class="type">long</span> <span class="type">long</span>  right) &#123;</span><br><span class="line">           root = <span class="built_in">build</span>(left, right);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">SegTree</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="function">SegNode* <span class="title">build</span><span class="params">(<span class="type">long</span> <span class="type">long</span>  l, <span class="type">long</span> <span class="type">long</span>  r)</span> </span>&#123;</span><br><span class="line">           SegNode* node = <span class="keyword">new</span> <span class="built_in">SegNode</span>(l, r);</span><br><span class="line">           <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="type">long</span> <span class="type">long</span>  mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">           node-&gt;lChild = <span class="built_in">build</span>(l, mid);</span><br><span class="line">           node-&gt;rChild = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">           <span class="keyword">return</span> node;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(SegNode* root, <span class="type">long</span> <span class="type">long</span>  tarIdx, <span class="type">long</span> <span class="type">long</span>  val)</span> </span>&#123;</span><br><span class="line">           root-&gt;curSum += val; </span><br><span class="line">           <span class="keyword">if</span>(root-&gt;leftBound == root-&gt;rightBound) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">long</span> <span class="type">long</span>  mid = (root-&gt;leftBound + root-&gt;rightBound) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="comment">// long long  mid = (root-&gt;leftBound + root-&gt;rightBound) / 2;</span></span><br><span class="line">           <span class="comment">// there are identicial difference between them two:</span></span><br><span class="line">           <span class="comment">// eg: when left == -1, right = 0;</span></span><br><span class="line">           <span class="comment">//     case1 =&gt; (left + right) / 2 == 0</span></span><br><span class="line">           <span class="comment">//     case1 =&gt; (left + right) &gt;&gt; 1 == -1</span></span><br><span class="line">           <span class="keyword">if</span>(tarIdx &lt;= mid) &#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="literal">nullptr</span> == root-&gt;lChild) &#123;</span><br><span class="line">                   root-&gt;lChild = <span class="keyword">new</span> <span class="built_in">SegNode</span>(root-&gt;leftBound, mid);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="built_in">insert</span>(root-&gt;lChild, tarIdx, val);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="literal">nullptr</span> == root-&gt;rChild) &#123;</span><br><span class="line">                   root-&gt;rChild = <span class="keyword">new</span> <span class="built_in">SegNode</span>(mid + <span class="number">1</span>, root-&gt;rightBound);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="built_in">insert</span>(root-&gt;rChild, tarIdx, val);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="type">long</span> <span class="type">long</span>  <span class="title">getSum</span><span class="params">(SegNode* root, <span class="type">long</span> <span class="type">long</span>  left, <span class="type">long</span> <span class="type">long</span>  right)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(<span class="literal">nullptr</span> == root) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 当前节点位于目标区间外</span></span><br><span class="line">           <span class="keyword">if</span>(left &gt; root-&gt;rightBound || right &lt; root-&gt;leftBound) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 当前节点位于目标区间内</span></span><br><span class="line">           <span class="keyword">if</span>(left &lt;= root-&gt;leftBound &amp;&amp; right &gt;= root-&gt;rightBound) &#123;</span><br><span class="line">               <span class="keyword">return</span> root-&gt;curSum;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">getSum</span>(root-&gt;lChild, left, right) + <span class="built_in">getSum</span>(root-&gt;rChild, left, right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0327-区间和的个数"><a href="#0327-区间和的个数" class="headerlink" title="0327. 区间和的个数"></a>0327. 区间和的个数</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-of-range-sum/">https://leetcode-cn.com/problems/count-of-range-sum/</a></p>
<p>题和逆序数对的计算方式相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</a><br>就是做了一个小改变而已，很多统计区间值的，st-ed &lt; tar, 本来是让你找一个st，ed的对子的，那么就会转换思路为：<br>对于每一个ed找st，什么样的呢？ st &lt; ed + tar<br>然后找这样的st就有很多方法，比如hash，前缀和，bitree，priority_queue</p>
<h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 求逆序对的思路：<ul>
<li>1.1 首先注意到：对于数组{5，5,2,3,6}而言，得到每个value的个数的统计：<ul>
<li>index  -&gt;  1 2 3 4 5 6 7 8 9</li>
<li>value  -&gt;  0 1 1 0 2 1 0 0 0</li>
</ul>
</li>
<li>1.2 那么上述过程中，比如对于5，其贡献的逆序数对为5之前所有数字出现次数的和，也就是value数组中2之前的前缀和！</li>
</ul>
</li>
<li>2 那么如何快速获得前缀和呢？考虑使用BST来获取，参考:<a href="https://xychen5.github.io/2021/12/15/dataStructure-BinaryIndexedTree/">https://xychen5.github.io/2021/12/15/dataStructure-BinaryIndexedTree/</a><ul>
<li>2.1 整体思路如下：<ul>
<li>a 使用数字在数组中的排名来代替数字（这不会对逆序数对的个数产生影响）</li>
<li>b 对数组nums中的元素nums[i]从右到左构建BITree（i 从 n-1 到 0），注意，BITree所对应的前缀和是数组里数字出现次数的和<ul>
<li>比如进行到nums[i]，那么nums[i]右边的数字都已经统计了他们的出现次数，而后获取nums[i] - 1的前缀和，即可获取所有 &lt; nums[i]的数字在nums[i:n]中的出现次数之和，也就是nums[i]贡献的逆序数对的个数</li>
<li><strong>之所以是逆序遍历构建BITree，是因为对于nums[i]，它能够贡献的逆序数对的个数仅仅出现在它的右侧，所以需要在右侧进行</strong></li>
</ul>
</li>
</ul>
</li>
<li>2.2 额外说一下数组离散化，也就是不关系数字大小本身，只关心他们之间的相对排位</li>
</ul>
</li>
<li>3 使用线段树解题</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SegTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">SegNode</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span>  leftBound = <span class="number">0</span>, rightBound = <span class="number">0</span>, curSum = <span class="number">0</span>;</span><br><span class="line">            SegNode* lChild = <span class="literal">nullptr</span>;</span><br><span class="line">            SegNode* rChild = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="built_in">SegNode</span>(<span class="type">long</span> <span class="type">long</span> lb, <span class="type">long</span> <span class="type">long</span> rb) :</span><br><span class="line">                <span class="built_in">leftBound</span>(lb),</span><br><span class="line">                <span class="built_in">rightBound</span>(rb),</span><br><span class="line">                <span class="built_in">curSum</span>(<span class="number">0</span>),</span><br><span class="line">                <span class="built_in">lChild</span>(<span class="literal">nullptr</span>),</span><br><span class="line">                <span class="built_in">rChild</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        SegNode* root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">SegTree</span>(<span class="type">long</span> <span class="type">long</span>  left, <span class="type">long</span> <span class="type">long</span>  right) &#123;</span><br><span class="line">            root = <span class="built_in">build</span>(left, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">SegTree</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">SegNode* <span class="title">build</span><span class="params">(<span class="type">long</span> <span class="type">long</span>  l, <span class="type">long</span> <span class="type">long</span>  r)</span> </span>&#123;</span><br><span class="line">            SegNode* node = <span class="keyword">new</span> <span class="built_in">SegNode</span>(l, r);</span><br><span class="line">            <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span>  mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            node-&gt;lChild = <span class="built_in">build</span>(l, mid);</span><br><span class="line">            node-&gt;rChild = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(SegNode* root, <span class="type">long</span> <span class="type">long</span>  tarIdx, <span class="type">long</span> <span class="type">long</span>  val)</span> </span>&#123;</span><br><span class="line">            root-&gt;curSum += val; </span><br><span class="line">            <span class="keyword">if</span>(root-&gt;leftBound == root-&gt;rightBound) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span>  mid = (root-&gt;leftBound + root-&gt;rightBound) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(tarIdx &lt;= mid) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;d2&quot; &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">nullptr</span> == root-&gt;lChild) &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; &quot;d2.5&quot; &lt;&lt; endl;</span></span><br><span class="line">                    root-&gt;lChild = <span class="keyword">new</span> <span class="built_in">SegNode</span>(root-&gt;leftBound, mid);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">insert</span>(root-&gt;lChild, tarIdx, val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;d3&quot; &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">nullptr</span> == root-&gt;rChild) &#123;</span><br><span class="line">                    root-&gt;rChild = <span class="keyword">new</span> <span class="built_in">SegNode</span>(mid + <span class="number">1</span>, root-&gt;rightBound);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">insert</span>(root-&gt;rChild, tarIdx, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">long</span> <span class="type">long</span>  <span class="title">getSum</span><span class="params">(SegNode* root, <span class="type">long</span> <span class="type">long</span>  left, <span class="type">long</span> <span class="type">long</span>  right)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> == root) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前节点位于目标区间外</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt; root-&gt;rightBound || right &lt; root-&gt;leftBound) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前节点位于目标区间内</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt;= root-&gt;leftBound &amp;&amp; right &gt;= root-&gt;rightBound) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;left/right&quot; &lt;&lt; left &lt;&lt; &quot;/&quot; &lt;&lt; right &lt;&lt; &quot; =&gt; &quot; &lt;&lt; root-&gt;curSum &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">return</span> root-&gt;curSum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getSum</span>(root-&gt;lChild, left, right) + <span class="built_in">getSum</span>(root-&gt;rChild, left, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countRangeSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; numToIdx;</span><br><span class="line">        set&lt;<span class="type">long</span> <span class="type">long</span>&gt; tmpNums;</span><br><span class="line">        vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; prefixSum = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            prefixSum.<span class="built_in">emplace_back</span>(nums[i] + prefixSum.<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ps : prefixSum) &#123;</span><br><span class="line">            tmpNums.<span class="built_in">insert</span>(ps);</span><br><span class="line">            tmpNums.<span class="built_in">insert</span>(ps - lower);</span><br><span class="line">            tmpNums.<span class="built_in">insert</span>(ps - upper);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : tmpNums) &#123;</span><br><span class="line">            numToIdx[num] = i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for a valid s(i, j) we shall find:</span></span><br><span class="line">        <span class="comment">//     preSum[j] - ub &lt;= preSum[i] &lt;= preSum[j] - lb</span></span><br><span class="line">        <span class="comment">// we just need to statistic those preSum[i] for each j</span></span><br><span class="line">        <span class="type">int</span> n = tmpNums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// BITree tree(n + 1);</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we do not do the deserialization</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> minLeft = LLONG_MAX, maxRight = LLONG_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> x : prefixSum) &#123;</span><br><span class="line">            minLeft = <span class="built_in">min</span>(&#123;minLeft, x, x - lower, x - upper&#125;);</span><br><span class="line">            maxRight = <span class="built_in">max</span>(&#123;maxRight, x, x - lower, x - upper&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;minL, maxR&quot; &lt;&lt; minLeft &lt;&lt; &quot; &quot; &lt;&lt; maxRight &lt;&lt;endl; </span></span><br><span class="line">        SegTree tree;</span><br><span class="line">        tree.root = <span class="keyword">new</span> SegTree::<span class="built_in">SegNode</span>(minLeft, maxRight);</span><br><span class="line">        <span class="comment">// reason why we insert the prefixSum of 0, because for the first ele:</span></span><br><span class="line">        <span class="comment">// if it statisfy the interval, then it will be statisticed because the 0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> x : prefixSum) &#123;</span><br><span class="line">            ans += tree.<span class="built_in">getSum</span>(tree.root, x - upper, x - lower);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;lb, rb = &quot; &lt;&lt; x - upper&lt;&lt; &quot; &quot; &lt;&lt; x - lower &lt;&lt; &quot; ==&gt; ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">            tree.<span class="built_in">insert</span>(tree.root, x, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;insert: &quot; &lt;&lt;  x &lt;&lt; &quot;curRoot: &quot; &lt;&lt; tree.root-&gt;curSum &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-可能发生的问题"><a href="#5-可能发生的问题" class="headerlink" title="5 可能发生的问题"></a>5 可能发生的问题</h2><p>注意其中很重要的一点：</p>
<blockquote>
<p>对于线段树中插入一个节点时，需要对沿路所有节点的sum加上要插入的节点的值，找这个节点位置的时候，<br>需要找到root左右管辖范围的中间值mid，此时务必使用&gt;&gt;1去做，因为获得mid我们要求其为 floor(left + right),<br>(cpp和python对于移位和除法的逻辑是相同的)，这里就显示出了2者的区别，<br>当然在数字都为正数的时候不会出错！</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>((-<span class="number">1</span> + <span class="number">0</span>) / <span class="number">2</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>((-<span class="number">1</span> + <span class="number">0</span>)  &gt;&gt; <span class="number">1</span>)</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xychen5</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
