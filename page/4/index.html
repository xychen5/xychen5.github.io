<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=victor+mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"xychen5.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12,"width":300},"copycode":false,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"changyan":{"text":"Load Disqus","order":-2},"gitalk":{"order":-1}}},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"zoomIn","post_header":"zoomIn","post_body":"zoomIn","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

  <meta name="description" content="Freiheit Weht">
<meta property="og:type" content="website">
<meta property="og:title" content="LuftBallon">
<meta property="og:url" content="https://xychen5.github.io/page/4/index.html">
<meta property="og:site_name" content="LuftBallon">
<meta property="og:description" content="Freiheit Weht">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="xychen5">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://xychen5.github.io/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LuftBallon</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LuftBallon</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-arrow-right fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="xychen5"
      src="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
  <p class="site-author-name" itemprop="name">xychen5</p>
  <div class="site-description" itemprop="description">Freiheit Weht</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">69</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/xychen5?tab=repositories" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xychen5?tab&#x3D;repositories" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cxynash5@gmail.com" title="E-Mail → mailto:cxynash5@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2021/12/15/dataStructure-BinaryIndexedTree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/15/dataStructure-BinaryIndexedTree/" class="post-title-link" itemprop="url">dataStructure_BinaryIndexedTree - 二叉索引树（树状数组）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-15 13:13:06" itemprop="dateCreated datePublished" datetime="2021-12-15T13:13:06+08:00">2021-12-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="BITree-详解"><a href="#BITree-详解" class="headerlink" title="BITree 详解"></a>BITree 详解</h1><h2 id="1-Binary-Indexed-Tree-二元索引树-树状数组"><a href="#1-Binary-Indexed-Tree-二元索引树-树状数组" class="headerlink" title="1 Binary Indexed Tree(二元索引树)(树状数组)"></a>1 Binary Indexed Tree(二元索引树)(树状数组)</h2><ul>
<li>1 用途：以O(log n)时间复杂度得到任意区间和。同时支持在O(log n)时间内支持动态单点值的修改。空间复杂度O(n)。</li>
<li>2 出处：Peter M. Fenwick. A new data structure for cumulative frequency tables. Software: Practice and Experience. 1994, 24 (3): 327–336. doi:10.1002/spe.4380240306.</li>
<li>3 原理：按照Peter M. Fenwick的说法，正如所有的整数都可以表示成2的幂和，我们也可以把一串序列表示成一系列子序列的和。采用这个想法，我们可将一个前缀和划分成多个子序列的和，而划分的方法与数的2的幂和具有极其相似的方式。一方面，<strong>子序列的个数是其二进制表示中1的个数</strong>，另一方面，<strong>子序列代表的f[i]的个数也是2的幂</strong>。<br>如下说明也很贴切：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">How does Binary Indexed Tree work? </span><br><span class="line">The idea is based on the fact that all positive integers can be represented as the sum of powers of 2. For example 19 can be represented as 16 + 2 + 1. Every node of the BITree stores the sum of n elements where n is a power of 2. For example, in the first diagram above (the diagram for getSum()), the sum of the first 12 elements can be obtained by the sum of the last 4 elements (from 9 to 12) plus the sum of 8 elements (from 1 to 8). The number of set bits in the binary representation of a number n is O(Logn). Therefore, we traverse at-most O(Logn) nodes in both getSum() and update() operations. The time complexity of the construction is O(nLogn) as it calls update() for all n elements. </span><br></pre></td></tr></table></figure>
<h2 id="2-直观解释"><a href="#2-直观解释" class="headerlink" title="2 直观解释"></a>2 直观解释</h2></li>
<li>1 C[i]表示f[1]…f[i]的和，而用tree[idx]表示某些子序列的和</li>
<li>2 实际上tree[idx]是<strong>那些indexes from (idx - 2^r + 1) to idx的f[index]的和,其中r是idx最右边的那个非零位到右边末尾的0的个数</strong>，比如：<ul>
<li>eg 2.0 当idx=8 decimal = 1000,有r=3，则，tree[8] = f[1] + … + f[8],</li>
<li>eg 2.1 当idx=11 decimal = 1011,有r=0，则，tree[11] = f[11],</li>
<li>eg 2.2 当idx=12 decimal = 1100,有r=2，则，tree[12] = f[9] + f[10] + f[11] + f[12],</li>
<li>eg 2.3 当idx=14 decimal = 1110,有r=1，则，tree[14] = f[13] + f[14]</li>
</ul>
</li>
<li>3 有了上面tree这个数组(也就是bit本体)，我们可以得到： C[13] = tree[13] + tree[12] + tree[8]<ul>
<li>从上述例子可以得出一个重要结论：<strong>求前idx个和，也就是求C[idx]的时候，idx中1的个数即为构成C[idx]的子序列的个数，也就是有多少个tree中的元素加起来</strong><blockquote>
<p>C1 = f1 <br><br>C2 = f1 + f2 <br><br>C3 = f3 <br><br>C4 = f1 + f2 + f3 + f4 <br><br>C5 = f5 <br><br>C6 = f5 + f6 <br><br>C7 = f7 <br><br>C8 = f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8 <br><br>… <br><br>C16 = f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8 + f9 + f10 + f11 + f12 + f13 + f14 + f15 + f16</p>
</blockquote>
</li>
</ul>
</li>
<li>4 有了3作为基础，求前缀和过程如下：<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/">4,5参考</a><br><img src="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/BITSum.3uh1v2dddp40.png" alt="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/BITSum.3uh1v2dddp40.png"><ul>
<li>4.1 tree[y] 是 tree[x] 的父节点，当且仅当可以通过从 x 的二进制表示中去除最后一个设置位(即数位为1的位)来获得 y，即 y = x – (x &amp; (-x))。<ul>
<li>lowbit函数 就是 取最后一个设置位的函数，lowbit = [](int x) int {return (x &amp; (-x));}</li>
<li>eg: tree[8]是tree[10]的父节点，因为  10 - (10&amp;(-10)) == 8 为true</li>
</ul>
</li>
<li>4.2 节点 tree[y] 的子节点 tree[x] 存储了 y(inclusive) 和 x(exclusive) 之间元素的总和：arr[y,…,x)。</li>
<li>4.3 实际例子：求C[11] = C[1011]：<ul>
<li>4.3.1 看下图即可，很显然我们需要沿着路径一直加到dummy node(tree[0]其值为0，方便运算而已)为止，从这里能够再一次看出，为何其前缀和的算法时间复杂度为O(log n)，因为路径上的node个数就是C[1011]中的1的个数</li>
<li>C[1011] = C[11] = tree[11] + tree[10] + tree[8]</li>
<li>4.3.2具体代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> BITree[], <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// Initialize result</span></span><br><span class="line">    <span class="comment">// index in BITree[] is 1 more than the index in arr[]</span></span><br><span class="line">    index = index + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Traverse ancestors of BITree[index]</span></span><br><span class="line">    <span class="keyword">while</span> (index&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add current element of BITree to sum</span></span><br><span class="line">        sum += BITree[index];</span><br><span class="line">        <span class="comment">// Move index to parent node in getSum View</span></span><br><span class="line">        index -= index &amp; (-index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>5 更新BITree<ul>
<li>5.1 类似4中的求和，更改一个节点需要更改所有被当前节点所影响的子节点</li>
<li>5.2 子节点的获取： parent of idx = idx + (idx &amp; (-idx));</li>
<li>5.3 举个例子，如4中的图：对于idx = 2这个点，需要更新节点4,8<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateBIT</span><span class="params">(<span class="type">int</span> BITree[], <span class="type">int</span> n, <span class="type">int</span> index, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// index in BITree[] is 1 more than the index in arr[]</span></span><br><span class="line">    index = index + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Traverse all ancestors and add &#x27;val&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add &#x27;val&#x27; to current node of BI Tree</span></span><br><span class="line">        BITree[index] += val;</span><br><span class="line">        <span class="comment">// Update index to that of parent in update View</span></span><br><span class="line">        index += index &amp; (-index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="3-整体实现"><a href="#3-整体实现" class="headerlink" title="3 整体实现"></a>3 整体实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ code to demonstrate operations of Binary Index Tree</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*		 n --&gt; No. of elements present in input array.</span></span><br><span class="line"><span class="comment">	BITree[0..n] --&gt; Array that represents Binary Indexed Tree.</span></span><br><span class="line"><span class="comment">	arr[0..n-1] --&gt; Input array for which prefix sum is evaluated. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns sum of arr[0..index]. This function assumes</span></span><br><span class="line"><span class="comment">// that the array is preprocessed and partial sums of</span></span><br><span class="line"><span class="comment">// array elements are stored in BITree[].</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> BITree[], <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// Initialize result</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// index in BITree[] is 1 more than the index in arr[]</span></span><br><span class="line">	index = index + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Traverse ancestors of BITree[index]</span></span><br><span class="line">	<span class="keyword">while</span> (index&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Add current element of BITree to sum</span></span><br><span class="line">		sum += BITree[index];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Move index to parent node in getSum View</span></span><br><span class="line">		index -= index &amp; (-index);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Updates a node in Binary Index Tree (BITree) at given index</span></span><br><span class="line"><span class="comment">// in BITree. The given value &#x27;val&#x27; is added to BITree[i] and</span></span><br><span class="line"><span class="comment">// all of its ancestors in tree.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateBIT</span><span class="params">(<span class="type">int</span> BITree[], <span class="type">int</span> n, <span class="type">int</span> index, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// index in BITree[] is 1 more than the index in arr[]</span></span><br><span class="line">	index = index + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Traverse all ancestors and add &#x27;val&#x27;</span></span><br><span class="line">	<span class="keyword">while</span> (index &lt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">// Add &#x27;val&#x27; to current node of BI Tree</span></span><br><span class="line">	BITree[index] += val;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update index to that of parent in update View</span></span><br><span class="line">	index += index &amp; (-index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructs and returns a Binary Indexed Tree for given</span></span><br><span class="line"><span class="comment">// array of size n.</span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">constructBITree</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Create and initialize BITree[] as 0</span></span><br><span class="line">	<span class="type">int</span> *BITree = <span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		BITree[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Store the actual values in BITree[] using update()</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		<span class="built_in">updateBIT</span>(BITree, n, i, arr[i]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Uncomment below lines to see contents of BITree[]</span></span><br><span class="line">	<span class="comment">//for (int i=1; i&lt;=n; i++)</span></span><br><span class="line">	<span class="comment">//	 cout &lt;&lt; BITree[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> BITree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver program to test above functions</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> freq[] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">sizeof</span>(freq)/<span class="built_in">sizeof</span>(freq[<span class="number">0</span>]);</span><br><span class="line">	<span class="type">int</span> *BITree = <span class="built_in">constructBITree</span>(freq, n);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Sum of elements in arr[0..5] is &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">getSum</span>(BITree, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Let use test the update operation</span></span><br><span class="line">	freq[<span class="number">3</span>] += <span class="number">6</span>;</span><br><span class="line">	<span class="built_in">updateBIT</span>(BITree, n, <span class="number">3</span>, <span class="number">6</span>); <span class="comment">//Update BIT for above change in arr[]</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\nSum of elements in arr[0..5] after update is &quot;</span></span><br><span class="line">		&lt;&lt; <span class="built_in">getSum</span>(BITree, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="实际例题"><a href="#实际例题" class="headerlink" title="实际例题"></a>实际例题</h1><h2 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a>剑指 Offer 51. 数组中的逆序对</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</a></p>
<h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 思路：<ul>
<li>1.1 首先注意到：对于数组{5，5,2,3,6}而言，得到每个value的个数的统计：<ul>
<li>index  -&gt;  1 2 3 4 5 6 7 8 9</li>
<li>value  -&gt;  0 1 1 0 2 1 0 0 0</li>
</ul>
</li>
<li>1.2 那么上述过程中，比如对于5，其贡献的逆序数对为5之前所有数字出现次数的和，也就是value数组中2之前的前缀和！</li>
</ul>
</li>
<li>2 那么如何快速获得前缀和呢？考虑使用BST来获取，参考:<a href=""></a><ul>
<li>2.1 整体思路如下：<ul>
<li>a 使用数字在数组中的排名来代替数字（这不会对逆序数对的个数产生影响）</li>
<li>b 对数组nums中的元素nums[i]从右到左构建BITree（i 从 n-1 到 0），注意，BITree所对应的前缀和是数组里数字出现次数的和<ul>
<li>比如进行到nums[i]，那么nums[i]右边的数字都已经统计了他们的出现次数，而后获取nums[i] - 1的前缀和，即可获取所有 &lt; nums[i]的数字在nums[i:n]中的出现次数之和，也就是nums[i]贡献的逆序数对的个数</li>
<li><strong>之所以是逆序遍历构建BITree，是因为对于nums[i]，它能够贡献的逆序数对的个数仅仅出现在它的右侧，所以需要在右侧进行</strong></li>
</ul>
</li>
</ul>
</li>
<li>2.2 额外说一下数组离散化，也就是不关系数字大小本身，只关心他们之间的相对排位<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(sortNoNums.<span class="built_in">begin</span>(), sortNoNums.<span class="built_in">end</span>(), std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    num = <span class="built_in">lower_bound</span>(sortNoNums.<span class="built_in">begin</span>(), sortNoNums.<span class="built_in">end</span>(), num) - sortNoNums.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
相似题目：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/</a></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">BIT</span>(<span class="type">int</span> _n): <span class="built_in">n</span>(_n) , <span class="built_in">tree</span>(_n + <span class="number">1</span>)&#123;cout &lt;&lt; <span class="string">&quot;init Done!&quot;</span> &lt;&lt; endl;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find prefixSum with index x</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum += tree[x];</span><br><span class="line">                x -= (x&amp;(-x));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update x with delta val v</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;d1&quot;</span>&lt;&lt; endl;</span><br><span class="line">            <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">                tree[x] += v;</span><br><span class="line">                x += (x&amp;(-x));</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;d2&quot;</span>&lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// desrialization, using sort no to denote the value</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; sortNoNums = nums;</span><br><span class="line">        <span class="built_in">sort</span>(sortNoNums.<span class="built_in">begin</span>(), sortNoNums.<span class="built_in">end</span>(), std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            num = <span class="built_in">lower_bound</span>(sortNoNums.<span class="built_in">begin</span>(), sortNoNums.<span class="built_in">end</span>(), num) - sortNoNums.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// using binary indexed tree to statistic the reversePair num</span></span><br><span class="line">        <span class="comment">// start from the end of nums, so that the prefix in BIT means the reversePiar num</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">BIT <span class="title">bit</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans += bit.<span class="built_in">query</span>(nums[i] - <span class="number">1</span>); <span class="comment">// cause only elements right than current num[i] will contribute to the ans</span></span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// statistic frequence of nums[i]</span></span><br><span class="line">            bit.<span class="built_in">update</span>(nums[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0315-计算右侧小于当前元素的个数"><a href="#0315-计算右侧小于当前元素的个数" class="headerlink" title="0315. 计算右侧小于当前元素的个数"></a>0315. 计算右侧小于当前元素的个数</h2><h3 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/</a></p>
<p>题和逆序数对的计算方式相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</a></p>
<h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 思路：<ul>
<li>1.1 首先注意到：对于数组{5，5,2,3,6}而言，得到每个value的个数的统计：<ul>
<li>index  -&gt;  1 2 3 4 5 6 7 8 9</li>
<li>value  -&gt;  0 1 1 0 2 1 0 0 0</li>
</ul>
</li>
<li>1.2 那么上述过程中，比如对于5，其贡献的逆序数对为5之前所有数字出现次数的和，也就是value数组中2之前的前缀和！</li>
</ul>
</li>
<li>2 那么如何快速获得前缀和呢？考虑使用BST来获取，参考:<a href="https://xychen5.github.io/2021/12/15/dataStructure-BinaryIndexedTree/">https://xychen5.github.io/2021/12/15/dataStructure-BinaryIndexedTree/</a><ul>
<li>2.1 整体思路如下：<ul>
<li>a 使用数字在数组中的排名来代替数字（这不会对逆序数对的个数产生影响）</li>
<li>b 对数组nums中的元素nums[i]从右到左构建BITree（i 从 n-1 到 0），注意，BITree所对应的前缀和是数组里数字出现次数的和<ul>
<li>比如进行到nums[i]，那么nums[i]右边的数字都已经统计了他们的出现次数，而后获取nums[i] - 1的前缀和，即可获取所有 &lt; nums[i]的数字在nums[i:n]中的出现次数之和，也就是nums[i]贡献的逆序数对的个数</li>
<li><strong>之所以是逆序遍历构建BITree，是因为对于nums[i]，它能够贡献的逆序数对的个数仅仅出现在它的右侧，所以需要在右侧进行</strong></li>
</ul>
</li>
</ul>
</li>
<li>2.2 额外说一下数组离散化，也就是不关系数字大小本身，只关心他们之间的相对排位<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(sortNoNums.<span class="built_in">begin</span>(), sortNoNums.<span class="built_in">end</span>(), std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    num = <span class="built_in">lower_bound</span>(sortNoNums.<span class="built_in">begin</span>(), sortNoNums.<span class="built_in">end</span>(), num) - sortNoNums.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如下的过程并没有使用离散化，但是空间浪费也不是很多，超过百分之83吧</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">BIT</span>(<span class="type">int</span> _n): <span class="built_in">n</span>(_n) , <span class="built_in">tree</span>(_n + <span class="number">1</span>)&#123;cout &lt;&lt; <span class="string">&quot;init Done!&quot;</span> &lt;&lt; endl;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find prefixSum with index x</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum += tree[x];</span><br><span class="line">                x -= (x&amp;(-x));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update x with delta val v</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;d1&quot;</span>&lt;&lt; endl;</span><br><span class="line">            <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">                tree[x] += v;</span><br><span class="line">                x += (x&amp;(-x));</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;d2&quot;</span>&lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// desrialization, using sort no to denote the value</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; sortNoNums = nums;</span><br><span class="line">        <span class="built_in">sort</span>(sortNoNums.<span class="built_in">begin</span>(), sortNoNums.<span class="built_in">end</span>(), std::<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            num = <span class="built_in">lower_bound</span>(sortNoNums.<span class="built_in">begin</span>(), sortNoNums.<span class="built_in">end</span>(), num) - sortNoNums.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// using binary indexed tree to statistic the reversePair num</span></span><br><span class="line">        <span class="comment">// start from the end of nums, so that the prefix in BIT means the reversePiar num</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">BIT <span class="title">bit</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans += bit.<span class="built_in">query</span>(nums[i] - <span class="number">1</span>); <span class="comment">// cause only elements right than current num[i] will contribute to the ans</span></span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// statistic frequence of nums[i]</span></span><br><span class="line">            bit.<span class="built_in">update</span>(nums[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0327-区间和的个数"><a href="#0327-区间和的个数" class="headerlink" title="0327. 区间和的个数"></a>0327. 区间和的个数</h2><h3 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-of-range-sum/">https://leetcode-cn.com/problems/count-of-range-sum/</a></p>
<p>题和逆序数对的计算方式相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</a><br>就是做了一个小改变而已，很多统计区间值的，st-ed &lt; tar, 本来是让你找一个st，ed的对子的，那么就会转换思路为：<br>对于每一个ed找st，什么样的呢？ st &lt; ed + tar<br>然后找这样的st就有很多方法，比如hash，前缀和，bitree，priority_queue</p>
<h3 id="2-解题思路-2"><a href="#2-解题思路-2" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 求逆序对的思路：<ul>
<li>1.1 首先注意到：对于数组{5，5,2,3,6}而言，得到每个value的个数的统计：<ul>
<li>index  -&gt;  1 2 3 4 5 6 7 8 9</li>
<li>value  -&gt;  0 1 1 0 2 1 0 0 0</li>
</ul>
</li>
<li>1.2 那么上述过程中，比如对于5，其贡献的逆序数对为5之前所有数字出现次数的和，也就是value数组中2之前的前缀和！</li>
</ul>
</li>
<li>2 那么如何快速获得前缀和呢？考虑使用BST来获取，参考:<a href="https://xychen5.github.io/2021/12/15/dataStructure-BinaryIndexedTree/">https://xychen5.github.io/2021/12/15/dataStructure-BinaryIndexedTree/</a><ul>
<li>2.1 整体思路如下：<ul>
<li>a 使用数字在数组中的排名来代替数字（这不会对逆序数对的个数产生影响）</li>
<li>b 对数组nums中的元素nums[i]从右到左构建BITree（i 从 n-1 到 0），注意，BITree所对应的前缀和是数组里数字出现次数的和<ul>
<li>比如进行到nums[i]，那么nums[i]右边的数字都已经统计了他们的出现次数，而后获取nums[i] - 1的前缀和，即可获取所有 &lt; nums[i]的数字在nums[i:n]中的出现次数之和，也就是nums[i]贡献的逆序数对的个数</li>
<li><strong>之所以是逆序遍历构建BITree，是因为对于nums[i]，它能够贡献的逆序数对的个数仅仅出现在它的右侧，所以需要在右侧进行</strong></li>
</ul>
</li>
</ul>
</li>
<li>2.2 额外说一下数组离散化，也就是不关系数字大小本身，只关心他们之间的相对排位</li>
</ul>
</li>
<li>3 那么小改变在哪里呢？<ul>
<li>就是查一次查不出来了，要查两次做一个差</li>
<li>还有一点就是，注意将所有要query和update的值，都用序号表示，这样避免tree过大<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> a valid <span class="title">s</span><span class="params">(i, j)</span> we shall find:</span></span><br><span class="line"><span class="function">     preSum[j] - ub &lt;=</span> preSum[i] &lt;= preSum[j] - lb</span><br><span class="line">we just need to statistic those preSum[i] <span class="keyword">for</span> each j</span><br></pre></td></tr></table></figure>
实现代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// when count the num, try to use BItree to count the appeared num, prefixSum to </span></span><br><span class="line">    <span class="comment">// get how many &lt; curNum will be fast</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">BITree</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line">        <span class="built_in">BITree</span> (<span class="type">int</span> _n) : <span class="built_in">n</span>(_n), <span class="built_in">tree</span>(_n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">lowBit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum += tree[x];</span><br><span class="line">                x -= <span class="built_in">lowBit</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;x and tree[x] &quot; &lt;&lt; x &lt;&lt; &quot;-&gt;&quot; &lt;&lt; tree[x] &lt;&lt; endl;</span></span><br><span class="line">                tree[x] += val;</span><br><span class="line">                x += <span class="built_in">lowBit</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countRangeSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; numToIdx;</span><br><span class="line">        set&lt;<span class="type">long</span> <span class="type">long</span>&gt; tmpNums;</span><br><span class="line">        vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; prefixSum = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            prefixSum.<span class="built_in">emplace_back</span>(nums[i] + prefixSum.<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ps : prefixSum) &#123;</span><br><span class="line">            tmpNums.<span class="built_in">insert</span>(ps);</span><br><span class="line">            tmpNums.<span class="built_in">insert</span>(ps - lower);</span><br><span class="line">            tmpNums.<span class="built_in">insert</span>(ps - upper);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : tmpNums) &#123;</span><br><span class="line">            numToIdx[num] = i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for a valid s(i, j) we shall find:</span></span><br><span class="line">        <span class="comment">//     preSum[j] - ub &lt;= preSum[i] &lt;= preSum[j] - lb</span></span><br><span class="line">        <span class="comment">// we just need to statistic those preSum[i] for each j</span></span><br><span class="line">        <span class="type">int</span> n = tmpNums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">BITree <span class="title">tree</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; prefixSum.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="type">int</span> leftBound = numToIdx[prefixSum[j] - upper];</span><br><span class="line">            <span class="type">int</span> rightBound = numToIdx[prefixSum[j] - lower];</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;lb, rb = &quot; &lt;&lt; leftBound &lt;&lt; &quot; &quot; &lt;&lt; rightBound &lt;&lt; endl;</span></span><br><span class="line">            ans += (tree.<span class="built_in">query</span>(rightBound) - tree.<span class="built_in">query</span>(leftBound - <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; &quot;preFixSumSize = &quot; &lt;&lt; prefixSum.size() &lt;&lt; endl;</span></span><br><span class="line">            tree.<span class="built_in">update</span>(numToIdx[prefixSum[j]], <span class="number">1</span>); <span class="comment">// avoid 0 to produce dead loop</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-使用线段树解题"><a href="#3-使用线段树解题" class="headerlink" title="3 使用线段树解题"></a>3 使用线段树解题</h3><p>注意其中很重要的一点：<br>对于线段树中插入一个节点时，需要对沿路所有节点的sum加上要插入的节点的值，找这个节点位置的时候，<br>需要找到root左右管辖范围的中间值mid，此时务必使用&gt;&gt;1去做，因为获得mid我们要求其为 floor(left + right),<br>但是：(cpp和python对于移位和除法的逻辑是相同的)，这里就显示出了2者的区别，<br>当然在数字都为正数的时候不会出错！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>((-<span class="number">1</span> + <span class="number">0</span>) / <span class="number">2</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>((-<span class="number">1</span> + <span class="number">0</span>)  &gt;&gt; <span class="number">1</span>)</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SegTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">SegNode</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span>  leftBound = <span class="number">0</span>, rightBound = <span class="number">0</span>, curSum = <span class="number">0</span>;</span><br><span class="line">            SegNode* lChild = <span class="literal">nullptr</span>;</span><br><span class="line">            SegNode* rChild = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="built_in">SegNode</span>(<span class="type">long</span> <span class="type">long</span> lb, <span class="type">long</span> <span class="type">long</span> rb) :</span><br><span class="line">                <span class="built_in">leftBound</span>(lb),</span><br><span class="line">                <span class="built_in">rightBound</span>(rb),</span><br><span class="line">                <span class="built_in">curSum</span>(<span class="number">0</span>),</span><br><span class="line">                <span class="built_in">lChild</span>(<span class="literal">nullptr</span>),</span><br><span class="line">                <span class="built_in">rChild</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        SegNode* root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">SegTree</span>(<span class="type">long</span> <span class="type">long</span>  left, <span class="type">long</span> <span class="type">long</span>  right) &#123;</span><br><span class="line">            root = <span class="built_in">build</span>(left, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">SegTree</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">SegNode* <span class="title">build</span><span class="params">(<span class="type">long</span> <span class="type">long</span>  l, <span class="type">long</span> <span class="type">long</span>  r)</span> </span>&#123;</span><br><span class="line">            SegNode* node = <span class="keyword">new</span> <span class="built_in">SegNode</span>(l, r);</span><br><span class="line">            <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span>  mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            node-&gt;lChild = <span class="built_in">build</span>(l, mid);</span><br><span class="line">            node-&gt;rChild = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(SegNode* root, <span class="type">long</span> <span class="type">long</span>  tarIdx, <span class="type">long</span> <span class="type">long</span>  val)</span> </span>&#123;</span><br><span class="line">            root-&gt;curSum += val; </span><br><span class="line">            <span class="keyword">if</span>(root-&gt;leftBound == root-&gt;rightBound) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span>  mid = (root-&gt;leftBound + root-&gt;rightBound) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// long long  mid = (root-&gt;leftBound + root-&gt;rightBound) / 2;</span></span><br><span class="line">            <span class="comment">// there are identicial difference between them two:</span></span><br><span class="line">            <span class="comment">// eg: when left == -1, right = 0;</span></span><br><span class="line">            <span class="comment">//     case1 =&gt; (left + right) / 2 == 0</span></span><br><span class="line">            <span class="comment">//     case1 =&gt; (left + right) &gt;&gt; 1 == -1</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;d1 &quot; &lt;&lt; tarIdx &lt;&lt; &quot; mid: &quot; &lt;&lt; mid &lt;&lt; &quot; root:l/r: &quot; &lt;&lt; root-&gt;leftBound &lt;&lt; &quot;/&quot; &lt;&lt; root-&gt;rightBound &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(tarIdx &lt;= mid) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;d2&quot; &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">nullptr</span> == root-&gt;lChild) &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; &quot;d2.5&quot; &lt;&lt; endl;</span></span><br><span class="line">                    root-&gt;lChild = <span class="keyword">new</span> <span class="built_in">SegNode</span>(root-&gt;leftBound, mid);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">insert</span>(root-&gt;lChild, tarIdx, val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;d3&quot; &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">nullptr</span> == root-&gt;rChild) &#123;</span><br><span class="line">                    root-&gt;rChild = <span class="keyword">new</span> <span class="built_in">SegNode</span>(mid + <span class="number">1</span>, root-&gt;rightBound);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">insert</span>(root-&gt;rChild, tarIdx, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">long</span> <span class="type">long</span>  <span class="title">getSum</span><span class="params">(SegNode* root, <span class="type">long</span> <span class="type">long</span>  left, <span class="type">long</span> <span class="type">long</span>  right)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> == root) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前节点位于目标区间外</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt; root-&gt;rightBound || right &lt; root-&gt;leftBound) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前节点位于目标区间内</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt;= root-&gt;leftBound &amp;&amp; right &gt;= root-&gt;rightBound) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;left/right&quot; &lt;&lt; left &lt;&lt; &quot;/&quot; &lt;&lt; right &lt;&lt; &quot; =&gt; &quot; &lt;&lt; root-&gt;curSum &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">return</span> root-&gt;curSum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getSum</span>(root-&gt;lChild, left, right) + <span class="built_in">getSum</span>(root-&gt;rChild, left, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countRangeSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; numToIdx;</span><br><span class="line">        set&lt;<span class="type">long</span> <span class="type">long</span>&gt; tmpNums;</span><br><span class="line">        vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; prefixSum = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            prefixSum.<span class="built_in">emplace_back</span>(nums[i] + prefixSum.<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ps : prefixSum) &#123;</span><br><span class="line">            tmpNums.<span class="built_in">insert</span>(ps);</span><br><span class="line">            tmpNums.<span class="built_in">insert</span>(ps - lower);</span><br><span class="line">            tmpNums.<span class="built_in">insert</span>(ps - upper);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : tmpNums) &#123;</span><br><span class="line">            numToIdx[num] = i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for a valid s(i, j) we shall find:</span></span><br><span class="line">        <span class="comment">//     preSum[j] - ub &lt;= preSum[i] &lt;= preSum[j] - lb</span></span><br><span class="line">        <span class="comment">// we just need to statistic those preSum[i] for each j</span></span><br><span class="line">        <span class="type">int</span> n = tmpNums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// BITree tree(n + 1);</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// for(int j = 0; j &lt; prefixSum.size(); ++j) &#123;</span></span><br><span class="line">        <span class="comment">//     int leftBound = numToIdx[prefixSum[j] - upper];</span></span><br><span class="line">        <span class="comment">//     int rightBound = numToIdx[prefixSum[j] - lower];</span></span><br><span class="line">        <span class="comment">//     // cout &lt;&lt; &quot;lb, rb = &quot; &lt;&lt; leftBound &lt;&lt; &quot; &quot; &lt;&lt; rightBound &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//     ans += (tree.query(rightBound) - tree.query(leftBound - 1));</span></span><br><span class="line">        <span class="comment">//     // cout &lt;&lt; &quot;ans = &quot; &lt;&lt; ans &lt;&lt; &quot;preFixSumSize = &quot; &lt;&lt; prefixSum.size() &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//     tree.update(numToIdx[prefixSum[j]], 1); // avoid 0 to produce dead loop</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// try to use segnode tree to sovle the problem, this will exceed the time limitation</span></span><br><span class="line">        <span class="comment">// SegTree tree(0, n + 1);</span></span><br><span class="line">        <span class="comment">// for(int j = 0; j &lt; prefixSum.size(); ++j) &#123;</span></span><br><span class="line">        <span class="comment">//     int left = numToIdx[prefixSum[j] - upper];</span></span><br><span class="line">        <span class="comment">//     int right = numToIdx[prefixSum[j] - lower];</span></span><br><span class="line">        <span class="comment">//     ans += tree.getSum(tree.root, left, right);</span></span><br><span class="line">        <span class="comment">//     // cout &lt;&lt; &quot;lb, rb = &quot; &lt;&lt; left&lt;&lt; &quot; &quot; &lt;&lt; right&lt;&lt; &quot; ==&gt; &quot; &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//     tree.insert(tree.root, numToIdx[prefixSum[j]], 1);</span></span><br><span class="line">        <span class="comment">//     // cout &lt;&lt; &quot;insert: &quot; &lt;&lt; numToIdx[prefixSum[j]]  &lt;&lt; &quot;curRoot: &quot; &lt;&lt; tree.root-&gt;curSum &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// we do not do the deserialization</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> minLeft = LLONG_MAX, maxRight = LLONG_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> x : prefixSum) &#123;</span><br><span class="line">            minLeft = <span class="built_in">min</span>(&#123;minLeft, x, x - lower, x - upper&#125;);</span><br><span class="line">            maxRight = <span class="built_in">max</span>(&#123;maxRight, x, x - lower, x - upper&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;minL, maxR&quot; &lt;&lt; minLeft &lt;&lt; &quot; &quot; &lt;&lt; maxRight &lt;&lt;endl; </span></span><br><span class="line">        SegTree tree;</span><br><span class="line">        tree.root = <span class="keyword">new</span> SegTree::<span class="built_in">SegNode</span>(minLeft, maxRight);</span><br><span class="line">        <span class="comment">// reason why we insert the prefixSum of 0, because for the first ele:</span></span><br><span class="line">        <span class="comment">// if it statisfy the interval, then it will be statisticed because the 0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> x : prefixSum) &#123;</span><br><span class="line">            ans += tree.<span class="built_in">getSum</span>(tree.root, x - upper, x - lower);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;lb, rb = &quot; &lt;&lt; x - upper&lt;&lt; &quot; &quot; &lt;&lt; x - lower &lt;&lt; &quot; ==&gt; ans = &quot; &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">            tree.<span class="built_in">insert</span>(tree.root, x, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;insert: &quot; &lt;&lt;  x &lt;&lt; &quot;curRoot: &quot; &lt;&lt; tree.root-&gt;curSum &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0493-翻转对"><a href="#0493-翻转对" class="headerlink" title="0493 翻转对"></a>0493 翻转对</h2><h3 id="1-题目-3"><a href="#1-题目-3" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-pairs/">https://leetcode-cn.com/problems/reverse-pairs/</a></p>
<p>题和逆序数对的计算方式相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</a><br>就是做了一个小改变而已，很多统计区间值的，st-ed &lt; tar, 本来是让你找一个st，ed的对子的，那么就会转换思路为：<br>对于每一个ed找st，什么样的呢？ st &lt; ed + tar<br>然后找这样的st就有很多方法，比如hash，前缀和，bitree，priority_queue</p>
<h3 id="2-解题思路-3"><a href="#2-解题思路-3" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 求逆序对的思路：<ul>
<li>1.1 首先注意到：对于数组{5，5,2,3,6}而言，得到每个value的个数的统计：<ul>
<li>index  -&gt;  1 2 3 4 5 6 7 8 9</li>
<li>value  -&gt;  0 1 1 0 2 1 0 0 0</li>
</ul>
</li>
<li>1.2 那么上述过程中，比如对于5，其贡献的逆序数对为5之前所有数字出现次数的和，也就是value数组中2之前的前缀和！</li>
</ul>
</li>
<li>2 那么如何快速获得前缀和呢？考虑使用BST来获取，参考:<a href="https://xychen5.github.io/2021/12/15/dataStructure-BinaryIndexedTree/">https://xychen5.github.io/2021/12/15/dataStructure-BinaryIndexedTree/</a><ul>
<li>2.1 整体思路如下：<ul>
<li>a 使用数字在数组中的排名来代替数字（这不会对逆序数对的个数产生影响）</li>
<li>b 对数组nums中的元素nums[i]从右到左构建BITree（i 从 n-1 到 0），注意，BITree所对应的前缀和是数组里数字出现次数的和<ul>
<li>比如进行到nums[i]，那么nums[i]右边的数字都已经统计了他们的出现次数，而后获取nums[i] - 1的前缀和，即可获取所有 &lt; nums[i]的数字在nums[i:n]中的出现次数之和，也就是nums[i]贡献的逆序数对的个数</li>
<li><strong>之所以是逆序遍历构建BITree，是因为对于nums[i]，它能够贡献的逆序数对的个数仅仅出现在它的右侧，所以需要在右侧进行</strong></li>
</ul>
</li>
</ul>
</li>
<li>2.2 额外说一下数组离散化，也就是不关系数字大小本身，只关心他们之间的相对排位</li>
</ul>
</li>
<li>3 那么小改变在哪里呢？<ul>
<li>对于每个j，找位于它之前的数字，满足：nums[i] &gt; 2*nums[j]</li>
<li>找的方法为用总体减去目标的补集：用nums[j]之前所有的数字的个数，减去小于等于nums[j] * 2的数字就行<blockquote>
<p>for each j, find those nums[i]:<br>which satisty: i &lt; j &amp;&amp; nums[i] &gt; 2*nums[j]</p>
<p>so, we can get this by: using all to sub those nums[i] &lt;= nums[j] * 2 to get the res<br>preSum[1 -&gt; 2*n] - preSum[1 -&gt; 2*nums[j]]</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">BITree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line">        vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; tree;</span><br><span class="line">        <span class="built_in">BITree</span>(<span class="type">long</span> <span class="type">long</span> _n) : <span class="built_in">n</span>(_n), <span class="built_in">tree</span>(_n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">lowBit</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum += tree[x];</span><br><span class="line">                x -= <span class="built_in">lowBit</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">                tree[x] += val;</span><br><span class="line">                x += <span class="built_in">lowBit</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// deserialization</span></span><br><span class="line">        vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; tmpNums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            tmpNums.<span class="built_in">emplace_back</span>(num);</span><br><span class="line">            tmpNums.<span class="built_in">emplace_back</span>(num * <span class="number">2LL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(tmpNums.<span class="built_in">begin</span>(), tmpNums.<span class="built_in">end</span>(), [](<span class="type">long</span> a, <span class="type">long</span> b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a &lt; b;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(auto&amp; num : tmpNums) &#123; cout &lt;&lt; &quot;tmp: &quot; &lt;&lt; num &lt;&lt; endl;&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// for(auto&amp; num : nums) &#123;</span></span><br><span class="line">        <span class="comment">//     num = lower_bound(tmpNums.begin(), tmpNums.end(), num) - tmpNums.begin() + 1; //  +1 to avoid update(0, 1) failure</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123; cout &lt;&lt; <span class="string">&quot;num No: &quot;</span> &lt;&lt; num &lt;&lt; endl;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// deserialization</span></span><br><span class="line">        <span class="type">int</span> idx = <span class="number">1</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">long</span> <span class="type">long</span>&gt; numToIdx;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : tmpNums) &#123;</span><br><span class="line">            numToIdx[num] = idx ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">BITree <span class="title">tree</span><span class="params">(<span class="number">2</span> * n)</span></span>;</span><br><span class="line">        <span class="comment">// for each j, find those nums[i]:</span></span><br><span class="line">        <span class="comment">// which satisty: i &lt; j &amp;&amp; nums[i] &gt; 2*nums[j]</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="comment">// so, we can get this by: using all to sub those nums[i] &lt;= nums[j] * 2 to get the res</span></span><br><span class="line">        <span class="comment">// preSum[1 -&gt; 2*n] - preSum[1 -&gt; 2*nums[j]]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;counting: &quot; &lt;&lt; nums[i] &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// attention the diff between 2LL and 2</span></span><br><span class="line">            ans += (tree.<span class="built_in">query</span>( <span class="number">2LL</span>*n ) - tree.<span class="built_in">query</span>(numToIdx[<span class="number">2LL</span> * nums[i]]));</span><br><span class="line">            tree.<span class="built_in">update</span>(numToIdx[nums[i]], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2021/12/14/lcBinarySearchTreeAndRecursiveWay/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/14/lcBinarySearchTreeAndRecursiveWay/" class="post-title-link" itemprop="url">lcBinarySearchTreeAndRecursiveWay</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-14 20:24:25" itemprop="dateCreated datePublished" datetime="2021-12-14T20:24:25+08:00">2021-12-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="0-递归和bst"><a href="#0-递归和bst" class="headerlink" title="0 递归和bst"></a>0 递归和bst</h1><h2 id="1-构建bst-0108-将有序数组转换为二叉搜索树"><a href="#1-构建bst-0108-将有序数组转换为二叉搜索树" class="headerlink" title="1 构建bst 0108. 将有序数组转换为二叉搜索树"></a>1 构建bst 0108. 将有序数组转换为二叉搜索树</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/</a></p>
<h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 AVL tree最主要的特性在于，任何子树的左子树和右子树的高度差不超过1，所以方法为：<ul>
<li>1.1 每次找到数组中间的值作为root，然后两边分别作为左右子树，左边都比root小，右边都大，刚好满足AVL要求<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// find root whose left size and right size shall equal</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(nums.begin(), nums.begin() + n / <span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(nums.begin() + n / <span class="number">2</span> + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(</span><br><span class="line">            nums[n/<span class="number">2</span>]</span><br><span class="line">            <span class="built_in">sortedArrayToBST</span>(left),</span><br><span class="line">            <span class="built_in">sortedArrayToBST</span>(right)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="2-select-k-from-n-C-n-k"><a href="#2-select-k-from-n-C-n-k" class="headerlink" title="2 select k from n: C(n, k)"></a>2 select k from n: C(n, k)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectKFromN</span><span class="params">(<span class="type">int</span> st, <span class="type">int</span> k, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; tmpRes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(tmpRes);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = st; i &lt; nums.<span class="built_in">size</span>() - k + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        tmpRes.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">selectKFromN</span>(i + <span class="number">1</span>, k - <span class="number">1</span>, res, nums, tmpRes);</span><br><span class="line">        tmpRes.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1-递归"><a href="#1-递归" class="headerlink" title="1 递归"></a>1 递归</h1><h2 id="0025-最大因数联通分量大小"><a href="#0025-最大因数联通分量大小" class="headerlink" title="0025 最大因数联通分量大小"></a>0025 最大因数联通分量大小</h2><h3 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">https://leetcode-cn.com/problems/reverse-nodes-in-k-group/</a></p>
<h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 个人思路：<ul>
<li>首先很明显能够发现子问题的痕迹，子问题就是翻转长度为k的链表</li>
<li>翻转用长度为k的栈去模拟即可</li>
</ul>
</li>
<li>2 优化： 使用常数空间：<ul>
<li>使用三个指针，a-&gt;b-&gt;c的链表的话，那么就是说(三个指针相当于滑动窗口的感觉)：</li>
<li>记录下a,b,c的指针，然后把a&lt;-b&lt;-c,然后移动这三个指针即可</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return headK -&gt; reverse(afterHeadK, k);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(head, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head, <span class="type">int</span> k )</span> </span>&#123;</span><br><span class="line">        ListNode* tmp = head;</span><br><span class="line">        vector&lt;ListNode*&gt; vec = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                vec.<span class="built_in">emplace_back</span>(tmp);</span><br><span class="line">                tmp = tmp -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(vec.<span class="built_in">size</span>() != k) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* nextHead = vec.<span class="built_in">back</span>()-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k<span class="number">-1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot;**&quot; &lt;&lt; endl;</span></span><br><span class="line">            vec[i]-&gt;next = vec[i<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">// cout &lt;&lt; vec[i]-&gt;val &lt;&lt; &quot; -&gt; &quot; &lt;&lt; vec[i-1]-&gt;val &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        vec[<span class="number">0</span>]-&gt;next = <span class="built_in">reverse</span>(nextHead, k);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;asdf**&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> vec.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><h2 id="0761-makeLargestSpecial-特殊的二进制序列"><a href="#0761-makeLargestSpecial-特殊的二进制序列" class="headerlink" title="0761 makeLargestSpecial 特殊的二进制序列"></a>0761 makeLargestSpecial 特殊的二进制序列</h2><h3 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/special-binary-string">https://leetcode-cn.com/problems/special-binary-string</a></p>
<h3 id="2-解题思路-2"><a href="#2-解题思路-2" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 个人思路：<ul>
<li>首先这个特殊子序列，采用合理的括号串去理解特殊子序列就好了</li>
<li>然后大致的递归思路：<ul>
<li>1.1 首先找到原来串里所有特殊的子序列</li>
<li>1.2 将这些子序列按照字典序排序</li>
<li>1.3 排序后加起来得到结果</li>
<li>1.4 eg： 10 1100 111000，这个串可以分成三个特殊子序列：那么最大字典序显然就是 111000 1100 10</li>
</ul>
</li>
<li>上面的还有其他问题，若子串一开始不能分为特殊子序列呢？<ul>
<li>eg：1 10 1100 0， 那么首先剥去外壳，然后再递归进去，对10 1100采用上述子序列方法</li>
</ul>
</li>
<li>递归返回？当子序列长度小于等于2，就直接返回字符串北盛即可</li>
<li>有个很容易出错误的示例需要注意：<blockquote>
<p>we shall reArrange first and then sort,<br>because when we reArrage, we my produce bigger subStr,<br>if we sort first and reArrange all subpart we could get false res: eg:<br>input:        “11100011010101100100”<br>false Result: “111000 11100101010100” // part2 is bigger subStr, so we shall reArrange all sub first and then sort<br>std result:   “11100101010100 111000” </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">makeLargestSpecial</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res = <span class="built_in">reArrange</span>(s);</span><br><span class="line">        <span class="comment">// string lastRes = &quot;&quot;;</span></span><br><span class="line">        <span class="comment">// while(res != reArrange(res))&#123;</span></span><br><span class="line">        <span class="comment">//     res = reArrange(res);</span></span><br><span class="line">        <span class="comment">// &#125;;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reArrange</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;c1-&gt;&quot;  &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;less than 2: &quot; &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// firstly, get all special subStr and sort as the lexical order</span></span><br><span class="line">        vector&lt;string&gt; subStr;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> st = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cntRedundantNumberOne = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = st + <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cntRedundantNumberOne += (s[i] == <span class="string">&#x27;1&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == cntRedundantNumberOne) &#123;</span><br><span class="line">                subStr.<span class="built_in">emplace_back</span>(s.<span class="built_in">substr</span>(st, i - st + <span class="number">1</span>));</span><br><span class="line">                st = i + <span class="number">1</span>;</span><br><span class="line">                cntRedundantNumberOne = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == subStr.<span class="built_in">size</span>()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> s.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">1</span>) + <span class="built_in">reArrange</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>, n<span class="number">-2</span>)) + s.<span class="built_in">substr</span>(n<span class="number">-2</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(auto i : subStr) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// secondly, sort all sub part and sum up</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;a&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; subStr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            subStr[i] = <span class="built_in">reArrange</span>(subStr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// we shall reArrange first and then sort,</span></span><br><span class="line">        <span class="comment">// because when we reArrage, we my produce bigger subStr, </span></span><br><span class="line">        <span class="comment">// if we sort first and reArrange all subpart we could get false res: eg: </span></span><br><span class="line">        <span class="comment">// input:        &quot;11100011010101100100&quot;</span></span><br><span class="line">        <span class="comment">// false Result: &quot;111000 11100101010100&quot; // part2 is bigger subStr, so we shall reArrange all sub first and then sort</span></span><br><span class="line">        <span class="comment">// std result:   &quot;11100101010100 111000&quot; </span></span><br><span class="line">        <span class="built_in">sort</span>(subStr.<span class="built_in">begin</span>(), subStr.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;string&gt;());</span><br><span class="line"></span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s : subStr) &#123;</span><br><span class="line">            res += s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;c2&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="0010-isMatch-正则表达式匹配"><a href="#0010-isMatch-正则表达式匹配" class="headerlink" title="0010 isMatch 正则表达式匹配"></a>0010 isMatch 正则表达式匹配</h2><h3 id="1-题目-3"><a href="#1-题目-3" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching">https://leetcode-cn.com/problems/regular-expression-matching</a></p>
<h3 id="2-解题思路-3"><a href="#2-解题思路-3" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>0 心得：<ul>
<li>递归适用于减小规模后问题的处理方式不会发生改变的场景</li>
<li>对于递归，得明白当层递归处理会如何将问题规模减小</li>
</ul>
</li>
<li>1 个人思路：<ul>
<li>首先这个字符串匹配，需要理解每一次能够用p去匹配什么？然后怎么匹配</li>
<li>1.1 首先每次递归，p的规模减小肯定是在p的头部： 对于p的匹配类型，有3种：<ul>
<li>1.1.1 s = ab, p = ab, 那么就用p的第一个字母去匹配</li>
<li>1.1.2 s = a, p = ., 同样需要用p的第一个字幕去匹配</li>
<li>1.1.3 带*的，这个需要将p的头两个拿去和s匹配：<ul>
<li>s = a, p1 = .*, p2 = a*,这两种情况，都是满足需要的</li>
<li>s = a, p1 = c*.*，<strong>那么第一个c*是不匹配的，同样的还有.*是否需要匹配的问题</strong></li>
</ul>
</li>
</ul>
</li>
<li>然后大致的递归思路：<ul>
<li>1.1 首先从p的头部分析是哪种子模式</li>
<li>1.2 按照该种子模式匹配</li>
<li>1.3 递归到下层的p和s，这样p和s都因为1.1~1.2的过程中变小了，完成了使用递归解决问题的思路</li>
</ul>
</li>
<li>递归返回？<ul>
<li>1.1 s的长度为0？</li>
<li>1.2 p的长度为0？</li>
</ul>
</li>
<li>对于上述过程不清楚的请以下面两个结果作为例子：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;bcabac&quot;</span><br><span class="line">&quot;a*a*.*b*b*&quot;</span><br><span class="line">return: true</span><br><span class="line"></span><br><span class="line">&quot;a&quot;</span><br><span class="line">&quot;.*..a*&quot;</span><br><span class="line">return false</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">greadyMatch</span>(s, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">greadyMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sLen = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> pLen = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;sLen &amp; pLen =&gt; &quot; &lt;&lt; sLen &lt;&lt; &quot; &quot; &lt;&lt; pLen &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(pLen == <span class="number">2</span> &amp;&amp; p[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pLen == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sLen != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> ? <span class="literal">true</span> : p[<span class="number">0</span>] == s[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sLen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pLen == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pLen == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">greadyMatch</span>(s, p.<span class="built_in">substr</span>(<span class="number">2</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pLen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sLen == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// match as much as possible</span></span><br><span class="line">        <span class="type">char</span> head0 = p[<span class="number">0</span>];</span><br><span class="line">        <span class="type">char</span> head1 = p[<span class="number">1</span>];</span><br><span class="line">        <span class="type">bool</span> res = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// match any len &gt;= 1 of s, when len == 0, then not match</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">0</span>; len &lt;= sLen; ++len) &#123;</span><br><span class="line">                    res = res || <span class="built_in">greadyMatch</span>(s.<span class="built_in">substr</span>(len), p.<span class="built_in">substr</span>(<span class="number">2</span>));</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; &quot;tried: &quot; &lt;&lt; s.substr(len) &lt;&lt; &quot; &quot; &lt;&lt; p.substr(2) &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">greadyMatch</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>), p.<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// p[0] = a~z</span></span><br><span class="line">            <span class="keyword">if</span>(p[<span class="number">0</span>] != s[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; p.substr(2) &lt;&lt; &quot;\nculled!&quot; &lt;&lt;endl;</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">greadyMatch</span>(s, p.<span class="built_in">substr</span>(<span class="number">2</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> sameLen = s.<span class="built_in">find_first_not_of</span>(p[<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">if</span>(sameLen == <span class="number">-1</span>) &#123;</span><br><span class="line">                        sameLen = sLen;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; &quot;sameLen2 -&gt; &quot; &lt;&lt; sameLen &lt;&lt; s.substr(1) &lt;&lt; p.substr(2) &lt;&lt; endl;</span></span><br><span class="line">                    <span class="comment">// when len = 0, not use this * to match</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">0</span>; len &lt;= sameLen; ++len) &#123;</span><br><span class="line">                        res = res || <span class="built_in">greadyMatch</span>(s.<span class="built_in">substr</span>(len), p.<span class="built_in">substr</span>(<span class="number">2</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">greadyMatch</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>), p.<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// never be executed</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-二叉搜索树-平衡意味着任意两个子树高度差不应该大于1"><a href="#2-二叉搜索树-平衡意味着任意两个子树高度差不应该大于1" class="headerlink" title="2 二叉搜索树(平衡意味着任意两个子树高度差不应该大于1)"></a>2 二叉搜索树(平衡意味着任意两个子树高度差不应该大于1)</h1><h2 id="1373-maxSumBST-二叉搜索子树的最大键值和"><a href="#1373-maxSumBST-二叉搜索子树的最大键值和" class="headerlink" title="1373 maxSumBST 二叉搜索子树的最大键值和"></a>1373 maxSumBST 二叉搜索子树的最大键值和</h2><h3 id="1-题目-4"><a href="#1-题目-4" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/">https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/</a></p>
<h3 id="2-解题思路-4"><a href="#2-解题思路-4" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 采用后续遍历，(前中后遍历的前中后是针对root节点的访问时期和左右子树的比较)</li>
<li>2 对于每个节点，维持该节点的4个值：<ul>
<li>int sum = 0; // 子树的所有和</li>
<li>int isBST = false; // 该节点为root的子树是否为BST</li>
<li>int maxVal = INT_MIN; // 该节点对应子树最大值</li>
<li>int minVal = INT_MAX; // 该节点对应子树最小值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">entry</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> isBST = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> maxVal = INT_MIN;</span><br><span class="line">        <span class="type">int</span> minVal = INT_MAX;</span><br><span class="line">        <span class="built_in">entry</span>() &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    map&lt;<span class="type">void</span>*, entry&gt; bstRec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, res);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// curRoot</span></span><br><span class="line">        entry tmp;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> != root-&gt;left &amp;&amp; <span class="literal">nullptr</span> != root-&gt;right) &#123;</span><br><span class="line">            tmp.sum = root-&gt;val + bstRec[root-&gt;right].sum + bstRec[root-&gt;left].sum;</span><br><span class="line">            tmp.isBST = bstRec[root-&gt;right].isBST &amp;&amp; \ </span><br><span class="line">                root-&gt;val &lt; bstRec[root-&gt;right].minVal &amp;&amp; \</span><br><span class="line">                root-&gt;val &gt; bstRec[root-&gt;left].maxVal;</span><br><span class="line">            tmp.maxVal = <span class="built_in">max</span>(root-&gt;val, bstRec[root-&gt;left].maxVal);</span><br><span class="line">            tmp.maxVal = <span class="built_in">max</span>(tmp.maxVal, bstRec[root-&gt;right].maxVal);</span><br><span class="line">            tmp.minVal = <span class="built_in">min</span>(root-&gt;val, bstRec[root-&gt;left].minVal);</span><br><span class="line">            tmp.minVal = <span class="built_in">min</span>(tmp.minVal, bstRec[root-&gt;right].minVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">nullptr</span> == root-&gt;left &amp;&amp; <span class="literal">nullptr</span> != root-&gt;right) &#123;</span><br><span class="line">            tmp.sum = root-&gt;val + bstRec[root-&gt;right].sum;</span><br><span class="line">            tmp.isBST = bstRec[root-&gt;right].isBST &amp;&amp; root-&gt;val &lt; bstRec[root-&gt;right].minVal;</span><br><span class="line">            tmp.maxVal = <span class="built_in">max</span>(root-&gt;val, bstRec[root-&gt;right].maxVal);</span><br><span class="line">            tmp.minVal = <span class="built_in">min</span>(root-&gt;val, bstRec[root-&gt;right].minVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">nullptr</span> != root-&gt;left &amp;&amp; <span class="literal">nullptr</span> == root-&gt;right) &#123;</span><br><span class="line">            tmp.sum = root-&gt;val + bstRec[root-&gt;left].sum;</span><br><span class="line">            tmp.isBST = bstRec[root-&gt;left].isBST &amp;&amp; root-&gt;val &gt; bstRec[root-&gt;left].maxVal;</span><br><span class="line">            tmp.maxVal = <span class="built_in">max</span>(root-&gt;val, bstRec[root-&gt;left].maxVal);</span><br><span class="line">            tmp.minVal = <span class="built_in">min</span>(root-&gt;val, bstRec[root-&gt;left].minVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp.sum = root-&gt;val;</span><br><span class="line">            tmp.isBST = <span class="literal">true</span>;</span><br><span class="line">            tmp.maxVal = root-&gt;val;</span><br><span class="line">            tmp.minVal = root-&gt;val;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(tmp.isBST) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, tmp.sum);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// cout &lt;&lt; root-&gt;val &lt;&lt; &quot; -&gt; &quot; &lt;&lt; tmp.sum &lt;&lt; endl;;</span></span><br><span class="line">        bstRec[root] = tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="1569-将子数组重新排序得到同一个二叉查找树的方案数"><a href="#1569-将子数组重新排序得到同一个二叉查找树的方案数" class="headerlink" title="1569. 将子数组重新排序得到同一个二叉查找树的方案数"></a>1569. 将子数组重新排序得到同一个二叉查找树的方案数</h2><h3 id="1-题目-5"><a href="#1-题目-5" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/">https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/</a></p>
<h3 id="2-解题思路-5"><a href="#2-解题思路-5" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 阅读提示即可，大致思路如下：<ul>
<li>1.1 首先，意识到第一个数必然为二叉树的root，那么找出左边的节点和右边的节点分别记为lt，和rt</li>
<li>1.2 首先假设我们知道了以lt和rt的不改变子树结构的重排序方案数字为findWays(lt), findWays(rt)</li>
<li>1.3 那么我们只需要思考，如何利用1.2的结果来获得当前root的结果：<ul>
<li>很显然，我们只需要确定lt和rt在root对应的整个序列(长度记录为n)中放置方法有多少种方案？进一步分析：在不改变lt序列内部相对顺序的情况下，找出有多少繁殖lt序列的方法？那么不就是n-1中选出lt长度记为k个位置的方法数字吗？</li>
<li>上述答案显而易见： c(n-1, k) = (n-1)!/(n-1-k)!/(k)!;</li>
</ul>
</li>
</ul>
</li>
<li>2 接着就是大数问题：由于n最大为1000，它的阶乘显然溢出，于是上面的直接计算阶乘的方案就失效，采用动动态规划的方法去算阶乘：<ul>
<li>c(n, k) = c(n-1, k) + c(n-1, k-1)</li>
<li>直观上来看假设原来只有n-1个物品选择k个，现在多加了一个物品，还是选择k个，那么方案数增加了：从 n 个物品中选择 k 个的方案数，等于从前 n-1 个物品中选择 k 个的方案数，加上从前 n-1 个物品中选择 k-1个（再选上第 nn 个物品）的方案数之和。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">long</span> <span class="type">long</span> largePrime = <span class="number">1000000007</span>;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; factorial;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numOfWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        factorial.<span class="built_in">resize</span>(<span class="number">1000</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// for(long long i = 1; i &lt; 1000; ++i) &#123;</span></span><br><span class="line">        <span class="comment">//     factorial[i] = i * (factorial[i-1] % largePrime);</span></span><br><span class="line">        <span class="comment">//     // cout &lt;&lt; i &lt;&lt; &quot;-&gt;&quot; &lt;&lt; factorial[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//     factorial[i] %= largePrime;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        c.<span class="built_in">assign</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cal c(n, m) = c(n-1, m) + c(n-1, m-1);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                c[i][j] = (c[i<span class="number">-1</span>][j] + c[i<span class="number">-1</span>][j<span class="number">-1</span>]) % largePrime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">findWays</span>(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">findWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> root = nums[<span class="number">0</span>];</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; left;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; right;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; root) &#123;</span><br><span class="line">                left.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// that means:</span></span><br><span class="line">        <span class="comment">// for the left tree, all nodes shall seat in the other places(and not change the relative order)</span></span><br><span class="line">        <span class="comment">// except root pos find the way out(the way shall equal: </span></span><br><span class="line">        <span class="comment">//     pick nodes size seat from all seats, that is c(n, m-1);</span></span><br><span class="line">        <span class="comment">// ) and mutiply the two subTree arrange way num</span></span><br><span class="line">        <span class="type">int</span> seats = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> nodesToSeat = left.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;c(n, k) &quot; &lt;&lt; seats &lt;&lt; &quot; -&gt; &quot; &lt;&lt; nodesToSeat &lt;&lt; &quot; = &quot; &lt;&lt; c[seats][nodesToSeat] &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;l r : &quot; &lt;&lt; findWays(left) &lt;&lt; &quot;  &quot; &lt;&lt; findWays(right) &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// return ((findWays(left)  % largePrime )* (findWays(right) % largePrime)) * (getWaysForCurLevel(seats, nodesToSeat) % largePrime);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findWays</span>(left)  % largePrime * <span class="built_in">findWays</span>(right) % largePrime * c[seats][nodesToSeat] % largePrime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">getWaysForCurLevel</span><span class="params">(<span class="type">int</span> seats, <span class="type">int</span> nodesToSeat)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c(n, k)2 :&quot;</span> &lt;&lt; factorial[seats] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; factorial[nodesToSeat] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; factorial[seats - nodesToSeat] &lt;&lt; endl;; </span><br><span class="line">        <span class="keyword">return</span> factorial[seats] / factorial[nodesToSeat] / factorial[seats - nodesToSeat];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0095-不同的二叉搜索树-II"><a href="#0095-不同的二叉搜索树-II" class="headerlink" title="0095. 不同的二叉搜索树 II"></a>0095. 不同的二叉搜索树 II</h2><h3 id="1-题目-6"><a href="#1-题目-6" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">https://leetcode-cn.com/problems/unique-binary-search-trees-ii/</a></p>
<h3 id="2-解题思路-6"><a href="#2-解题思路-6" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 首先明确一点，递归的主体为，从nums的数组中返回对应的所有可能的bst树<ul>
<li>1.1 输入： vector<int></li>
<li>1.2 返回： vector&lt;treeNode*&gt;</li>
</ul>
</li>
<li>2 于是递归思路的想法就来了：<ul>
<li>2.1 对于一个node如何生成其所有可能的二叉树呢？我们只考虑第1层到第2层的(因为其他所有层的递归都是一样的逻辑，除非返回层不太一样)<ul>
<li>2.1.1 从nums中选择一个作为root，左边的numsLeft和右边的numsRight分别获取root的所有左右子树</li>
<li>2.1.2 递归调用函数从numsLeft得到leftTrees，相应的得到rightTrees</li>
<li>2.1.3 得到leftTrees和rightTrees以后，采用2层for循环和root拼装，得到最后的树</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nodes;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            nodes.<span class="built_in">emplace_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getTreesFromArray</span>(nodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">getTreesFromArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nodes)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nodes.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;TreeNode*&gt; tmpRes;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> rootVal = nodes[i];</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmpLeft</span><span class="params">(nodes.begin(), nodes.begin() + i)</span></span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmpRight</span><span class="params">(nodes.begin() + i + <span class="number">1</span>, nodes.end())</span></span>;</span><br><span class="line">            vector&lt;TreeNode*&gt; left = <span class="built_in">getTreesFromArray</span>(tmpLeft);</span><br><span class="line">            vector&lt;TreeNode*&gt; right = <span class="built_in">getTreesFromArray</span>(tmpRight);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">0</span>; m &lt; left.<span class="built_in">size</span>(); ++m) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; right.<span class="built_in">size</span>(); ++n) &#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal, left[m], right[n]); </span><br><span class="line">                    tmpRes.<span class="built_in">emplace_back</span>(root); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmpRes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0000-面试题-04-09-二叉搜索树序列"><a href="#0000-面试题-04-09-二叉搜索树序列" class="headerlink" title="0000 面试题 04.09. 二叉搜索树序列"></a>0000 面试题 04.09. 二叉搜索树序列</h2><h3 id="1-题目-7"><a href="#1-题目-7" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bst-sequences-lcci/">https://leetcode-cn.com/problems/bst-sequences-lcci/</a></p>
<h3 id="2-解题思路-7"><a href="#2-解题思路-7" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 首先明确一点，递归的主体为，从root对应的tree中获取所有可能的bst子树序列<ul>
<li>1.1 输入： treeNode*</li>
<li>1.2 返回： vector&lt;vector<int>&gt;</li>
</ul>
</li>
<li>2 于是递归思路的想法就来了：<ul>
<li>2.1 对于一个root如何生成其所有可能的二叉树序列呢？我们只考虑第1层到第2层的(因为其他所有层的递归都是一样的逻辑，除非返回层不太一样)<ul>
<li>2.1.1 从root的左右子树获取其所有的左边子树序列lSeqs和右边子树序列rSeqs</li>
<li>2.1.2 对lSeqs和rSeqs里的数据进行两两拼接，得到一组合合并序列，那么每一个两两拼接，可以获得很多个序列，具体拼接如下：</li>
<li>2.1.3 那么很显然，记lSeqs和rSeqs中的一个两两拼接来自：lSeq，rSeq的长度分别为l和r，总长度为n，则有从n中选择l个的拼接方法，类似题目如下：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/">1569. 将子数组重新排序得到同一个二叉查找树的方案数https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>经典写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectKFromN</span><span class="params">(<span class="type">int</span> st, <span class="type">int</span> k, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; tmpRes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(tmpRes);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = st; i &lt; nums.<span class="built_in">size</span>() - k + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        tmpRes.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">selectKFromN</span>(i + <span class="number">1</span>, k - <span class="number">1</span>, res, nums, tmpRes);</span><br><span class="line">        tmpRes.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">BSTSequences</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getSequencesFromRoot</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">getSequencesFromRoot</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == root) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#123;&#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; sequences;</span><br><span class="line">        <span class="comment">// for(auto seq : s) &#123;</span></span><br><span class="line">        <span class="comment">//     s.emplace_back(root-&gt;val);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// get left sequences and right</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; lSeqs = <span class="built_in">getSequencesFromRoot</span>(root-&gt;left);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; rSeqs = <span class="built_in">getSequencesFromRoot</span>(root-&gt;right);</span><br><span class="line">        <span class="type">int</span> lSize = lSeqs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> rSize = rSeqs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;d0&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// select lSize&#x27;s positions in lSize + rSize + 1 &#x27;s vector</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lSize + rSize; ++i) &#123;</span><br><span class="line">            nums.<span class="built_in">emplace_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmpRes;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;d1&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">selectKFromN</span>(<span class="number">0</span>, lSize, res, nums, tmpRes);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> seqLen = lSeqs[<span class="number">0</span>].<span class="built_in">size</span>() + rSeqs[<span class="number">0</span>].<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;d2 &quot; &lt;&lt; lSize &lt;&lt; &quot;@&quot; &lt;&lt; rSize &lt;&lt; &quot;=&quot; &lt;&lt; seqLen &lt;&lt; endl;</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; lSeq : lSeqs) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; rSeq : rSeqs) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;d3&quot; &lt;&lt; endl;</span></span><br><span class="line">                <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmpSeq</span><span class="params">(seqLen)</span></span>;</span><br><span class="line">                tmpSeq[<span class="number">0</span>] = root-&gt;val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; idxVecForLeft : res) &#123;</span><br><span class="line">                    <span class="type">int</span> curLeft = <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> curRight = <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> lastLeft = <span class="number">1</span>;</span><br><span class="line">                    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">forRight</span><span class="params">(seqLen, <span class="literal">true</span>)</span></span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// cout &lt;&lt; &quot;d4&quot; &lt;&lt; endl;</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> lIdx : idxVecForLeft) &#123;</span><br><span class="line">                        tmpSeq[lIdx] = lSeq[curLeft++];</span><br><span class="line">                        forRight[lIdx] = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; seqLen; ++i) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(forRight[i]) &#123;</span><br><span class="line">                            tmpSeq[i] = rSeq[curRight++];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sequences.<span class="built_in">emplace_back</span>(tmpSeq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sequences;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selectKFromN</span><span class="params">(<span class="type">int</span> st, <span class="type">int</span> k, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; tmpRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(tmpRes);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = st; i &lt; nums.<span class="built_in">size</span>() - k + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            tmpRes.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">selectKFromN</span>(i + <span class="number">1</span>, k - <span class="number">1</span>, res, nums, tmpRes);</span><br><span class="line">            tmpRes.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2021/12/06/lcDisjointSetUnion1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/06/lcDisjointSetUnion1/" class="post-title-link" itemprop="url">lcDisjointSetUnion1 - 并查集1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-06 09:25:55" itemprop="dateCreated datePublished" datetime="2021-12-06T09:25:55+08:00">2021-12-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-并查集"><a href="#1-并查集" class="headerlink" title="1 并查集"></a>1 并查集</h2><p>关键理解： 并：是通过一条边将两个没有公共子集的集合合并，查：每个子集的所有子项对应的root是相同的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DSU</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; subTreeSize;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">            parent.<span class="built_in">resize</span>(n);</span><br><span class="line">            subTreeSize.<span class="built_in">resize</span>(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                subTreeSize[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(x != parent[x]) &#123;</span><br><span class="line">                parent[x] = parent[parent[x]];</span><br><span class="line">                x = parent[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">unionMerge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> findX = <span class="built_in">find</span>(x);</span><br><span class="line">            <span class="type">int</span> findY = <span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span>(findX != findY) &#123;</span><br><span class="line">                parent[findX] = findY;</span><br><span class="line">                subTreeSize[findY] += subTreeSize[findX];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">maxComponentSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="built_in">max</span>(subTreeSize.<span class="built_in">begin</span>(), subTreeSize.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0952-最大因数联通分量大小"><a href="#0952-最大因数联通分量大小" class="headerlink" title="0952 最大因数联通分量大小"></a>0952 最大因数联通分量大小</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-component-size-by-common-factor">https://leetcode-cn.com/problems/largest-component-size-by-common-factor</a></p>
<h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><p>个人体悟： 当需要判断两个节点是否位于同一个连通子图时，首选并查集</p>
<ul>
<li>1 普通思路：<ul>
<li>1.1 很简单，暴力的去检测两两节点之间的连接性，然后构建并查集，求解最大的分量值即可；</li>
</ul>
</li>
<li>2 优化思路：<ul>
<li>1 中需要o(n^2)的复杂度去计算结点之间的链接性，我们不去计算节点的连接性，改为计算他们质数因子的连接性</li>
<li>2 对于每个数字提取出质因子列表，然后因为这个数的存在，可以将这些质因子联系起来，将所有数字的质因子计作L</li>
<li>3 而后我们统计每个数字，他对应的属于哪个质因子的联通分量，然后对该联通分量的root计数加1即可，最后找出所有的质因子联通分量最大的计数即可。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DSU</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; subTreeSize;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">            parent.<span class="built_in">resize</span>(n);</span><br><span class="line">            subTreeSize.<span class="built_in">resize</span>(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                subTreeSize[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(x != parent[x]) &#123;</span><br><span class="line">                parent[x] = parent[parent[x]];</span><br><span class="line">                x = parent[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">unionMerge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> findX = <span class="built_in">find</span>(x);</span><br><span class="line">            <span class="type">int</span> findY = <span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span>(findX != findY) &#123;</span><br><span class="line">                parent[findX] = findY;</span><br><span class="line">                subTreeSize[findY] += subTreeSize[findX];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">maxComponentSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="built_in">max</span>(subTreeSize.<span class="built_in">begin</span>(), subTreeSize.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getGreatestCommonDivisor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mod = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            mod = x % y;</span><br><span class="line">            x = y;</span><br><span class="line">            y = mod;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span>(mod != <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestComponentSize</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxComponentSize = INT_MIN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DSU* dsu = new DSU(n);</span></span><br><span class="line">        <span class="comment">// travel all pairs and construct the dsu, o(n ** 2), too slow</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; n; ++i) &#123;</span></span><br><span class="line">        <span class="comment">//     for(int j = i; j &lt; n; ++j) &#123;</span></span><br><span class="line">        <span class="comment">//         if(getGreatestCommonDivisor(nums[i], nums[j]) != 1) &#123;</span></span><br><span class="line">        <span class="comment">//             dsu-&gt;unionMerge(i, j);</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="comment">// return *max_element(dsu-&gt;subTreeSize.begin(), dsu-&gt;subTreeSize.end());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// we shall understand the fact that:</span></span><br><span class="line">        <span class="comment">// union: union by edeg, but edge denote two set</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// find a number&#x27;s prime factors:</span></span><br><span class="line">        map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; numberToPrimes;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; primes;</span><br><span class="line">            <span class="type">int</span> x = num;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> d = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span>(d * d &lt;= num) &#123;</span><br><span class="line">                <span class="keyword">if</span>(num % d == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// cull out all d</span></span><br><span class="line">                    <span class="keyword">while</span>(num % d == <span class="number">0</span>) &#123;</span><br><span class="line">                        num = num / d;</span><br><span class="line">                    &#125;</span><br><span class="line">                    primes.<span class="built_in">emplace_back</span>(d);</span><br><span class="line">                &#125;</span><br><span class="line">                ++d;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">1</span> || primes.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                primes.<span class="built_in">emplace_back</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">            numberToPrimes[x] = primes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// form all the factors and numbers into nodes</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; factors;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : numberToPrimes) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; fac : p.second) &#123;</span><br><span class="line">                factors.<span class="built_in">insert</span>(fac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; facToNode;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> fac : factors) &#123;</span><br><span class="line">            facToNode[fac] = i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DSU* dsu = <span class="keyword">new</span> <span class="built_in">DSU</span>(factors.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">// union those numbers by factors</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : numberToPrimes) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; primes = p.second;</span><br><span class="line">            <span class="comment">// union a number&#x27;s all factors, we need union action: primes.size() times</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> prime : primes) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; p.first &lt;&lt; &quot;-&gt;&quot; &lt;&lt; prime &lt;&lt; endl;</span></span><br><span class="line">                dsu-&gt;<span class="built_in">unionMerge</span>(facToNode[primes[<span class="number">0</span>]], facToNode[prime]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for each number, find the union root of this number</span></span><br><span class="line">        <span class="comment">// all numbers who are connected will share the same root</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(factors.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : numberToPrimes) &#123;</span><br><span class="line">            cnt[dsu-&gt;<span class="built_in">find</span>(facToNode[p.second[<span class="number">0</span>]])]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// return *max_element(dsu-&gt;subTreeSize.begin(), dsu-&gt;subTreeSize.end());</span></span><br><span class="line">        <span class="comment">// return dsu-&gt;maxComponentSize();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0928-minMalwareSpread-最少病毒传播"><a href="#0928-minMalwareSpread-最少病毒传播" class="headerlink" title="0928 minMalwareSpread 最少病毒传播"></a>0928 minMalwareSpread 最少病毒传播</h2><h3 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimize-malware-spread-ii/">https://leetcode-cn.com/problems/minimize-malware-spread-ii/</a></p>
<h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><p>个人体悟： 当需要判断两个节点是否位于同一个连通子图时，首选并查集</p>
<ul>
<li>1 普通思路1<ul>
<li>1.1 使用dfs，对于每个initial，则计算仅仅由他能传播到的节点有多少</li>
</ul>
</li>
<li>2 使用并查集：<ul>
<li> 明确目标：对于每个initial，则计算仅仅由他能传播到的节点有多少</li>
<li> 那么就首先构造不含initial的一个图G</li>
<li> 遍历initial中的每个顶点，那么G中每个root都可以知道会被哪些initial所影响</li>
<li> 于是每个initial的贡献为仅仅被自己所连接的root（也就是仅由自己才能传播过去）（换句话说，若G中的一个连通子图，会被好几个initial传播，那么只删除一个initial是没办法改变这个联通子图会被传播的下场）</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != parent[x]) &#123;</span><br><span class="line">            parent[x] = parent[parent[x]];</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unionMerge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, vector&lt;<span class="type">int</span>&gt;&amp; subTreeSize, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> findX = <span class="built_in">find</span>(parent, x);</span><br><span class="line">        <span class="type">int</span> findY = <span class="built_in">find</span>(parent, y);</span><br><span class="line">        <span class="keyword">if</span>(findX != findY) &#123;</span><br><span class="line">            parent[findX] = findY;</span><br><span class="line">            subTreeSize[findY] += subTreeSize[findX];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMalwareSpread</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="type">int</span>&gt;&amp; initial)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对于每个initial计数的方式发生了改变，考虑一个不含有inital 的图，initial的得分应该是单独被他影响的子集</span></span><br><span class="line">        <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isInitial</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : initial) &#123;</span><br><span class="line">            isInitial[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">subTreeSize</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 构造union find set</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isInitial[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">1</span> == graph[i][j] &amp;&amp; !isInitial[j]) &#123;</span><br><span class="line">                    <span class="built_in">unionMerge</span>(parent, subTreeSize, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; n; ++i) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; &quot;root &quot; &lt;&lt; i &lt;&lt; &quot; -&gt; size &quot; &lt;&lt; subTreeSize[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// find componets infected by a initial</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, unordered_set&lt;<span class="type">int</span>&gt;&gt; initialToComponents;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; rootToInitial;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : initial) &#123;</span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt; components;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; ++v) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!isInitial[v]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(graph[i][v] == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> root = <span class="built_in">find</span>(parent, v);</span><br><span class="line">                        components.<span class="built_in">insert</span>(root);</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; &quot; ||| &quot; &lt;&lt; i &lt;&lt; &quot; &gt;&gt; &quot; &lt;&lt; root &lt;&lt; endl;</span></span><br><span class="line">                        <span class="comment">// no occupied by single initial</span></span><br><span class="line">                        <span class="keyword">if</span>(rootToInitial.<span class="built_in">find</span>(root) != rootToInitial.<span class="built_in">end</span>() &amp;&amp; \</span><br><span class="line">                        rootToInitial[root] != i) &#123;</span><br><span class="line">                            rootToInitial[root] = <span class="number">-1</span>;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        rootToInitial[root] = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            initialToComponents[i] = components;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// cal scores for each initial</span></span><br><span class="line">        <span class="type">int</span> resInit = INT_MAX;</span><br><span class="line">        <span class="type">int</span> maxScore = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : initialToComponents) &#123;</span><br><span class="line">            <span class="type">int</span> curInit = p.first;</span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt; components = p.second;</span><br><span class="line">            <span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; root : components) &#123;</span><br><span class="line">                <span class="comment">// std::cout &lt;&lt; curInit &lt;&lt; &quot; -&gt; &quot; &lt;&lt; score  &lt;&lt; &quot; with com: &quot; &lt;&lt; root &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span>(rootToInitial[root] != <span class="number">-1</span>) &#123;</span><br><span class="line">                    score += subTreeSize[root];</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; &quot;added!&quot; &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(score &gt; maxScore || (score == maxScore &amp;&amp; curInit &lt; resInit)) &#123;</span><br><span class="line">                maxScore = score;</span><br><span class="line">                resInit = curInit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resInit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0924-minMalwareSpread-最少病毒传播"><a href="#0924-minMalwareSpread-最少病毒传播" class="headerlink" title="0924 minMalwareSpread 最少病毒传播"></a>0924 minMalwareSpread 最少病毒传播</h2><h3 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimize-malware-spread/">https://leetcode-cn.com/problems/minimize-malware-spread/</a></p>
<h3 id="2-解题思路-2"><a href="#2-解题思路-2" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><p>个人体悟： 当需要判断两个节点是否位于同一个连通子图时，首选并查集</p>
<ul>
<li>1 普通思路1<ul>
<li>1.1 考虑每个候选移除顶点，bfs看它能传播多少，如果传播的过程中遇到任何其他候选点，这说明减少该候选点和其位于同一个子图的候选点都是无法减少病毒传播的</li>
<li>1.2 之后我们得到那些候选移除顶点，他们各自的连通子图中就没有其他候选点，我们看连通子图大小，找出子图最大的那个候选点，作为结果输出。</li>
<li>1.3 若没有1.2中的候选点，则根本无法减少传播，于是直接输出所有候选点中的最小值即可。</li>
</ul>
</li>
<li>2 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimize-malware-spread/solution/jin-liang-jian-shao-e-yi-ruan-jian-de-chuan-bo-b-2/">使用并查集或者bfs来上色</a><blockquote>
<p>同 方法一 一样，也得找出图中所有的连通分量，不同的是这一步用并查集来做。</p>
<p>在并查集中会额外计算连通分量的大小，当合并两个连通分量的时候，会把它们的大小进行累加。</p>
<p>借助并查集，可以用 方法一 中一样的思路处理：对于 initial 中每个颜色唯一的节点，都去计算连通分量的大小，从中找到最优解。如果 initial 中没有颜色唯一的节点，直接返回 min(initial)。</p>
<p>简洁起见，实现的并查集没有根据 rank 合并，这会让渐进复杂度变大一点。</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != parent[x]) &#123;</span><br><span class="line">            parent[x] = parent[parent[x]];</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unionMerge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, vector&lt;<span class="type">int</span>&gt;&amp; subTreeSize, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> findX = <span class="built_in">find</span>(parent, x);</span><br><span class="line">        <span class="type">int</span> findY = <span class="built_in">find</span>(parent, y);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(findX != findY) &#123;</span><br><span class="line">            parent[findX] = findY;</span><br><span class="line">            subTreeSize[findY] += subTreeSize[findX];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMalwareSpread</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="type">int</span>&gt;&amp; initial)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">subTreeSize</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            subTreeSize[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; connectSizeToInitial; </span><br><span class="line">        <span class="comment">// cal each connected component&#x27;s size, attach initial with a component&#x27;s &quot;color&quot;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">unionMerge</span>(parent, subTreeSize, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; rootToInit;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if two initial number in same connected component, then remove one of them</span></span><br><span class="line">        <span class="comment">// will cause the same malware spread result</span></span><br><span class="line">        <span class="comment">// each color pick a smallest idx as res candidate in initial, finally pick the max connect size</span></span><br><span class="line">        <span class="comment">// find max connected size</span></span><br><span class="line">        <span class="type">int</span> maxConnectSize = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : initial) &#123;</span><br><span class="line">            <span class="type">int</span> curRoot = <span class="built_in">find</span>(parent, i);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; -&gt;&gt; &quot; &lt;&lt; curRoot &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(rootToInit.<span class="built_in">find</span>(curRoot) != rootToInit.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                rootToInit[curRoot] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            rootToInit[curRoot] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> hasLonelyInitial = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : initial) &#123;</span><br><span class="line">            <span class="comment">// those initial who do not share root</span></span><br><span class="line">            <span class="keyword">if</span>(rootToInit[<span class="built_in">find</span>(parent, i)] != <span class="number">-1</span>) &#123; </span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;valid!&quot; &lt;&lt; endl;</span></span><br><span class="line">                hasLonelyInitial = <span class="literal">true</span>;</span><br><span class="line">                <span class="type">int</span> curSubSize = subTreeSize[<span class="built_in">find</span>(parent, i)];</span><br><span class="line">                <span class="keyword">if</span>(connectSizeToInitial.<span class="built_in">find</span>(curSubSize) != connectSizeToInitial.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    connectSizeToInitial[curSubSize] = <span class="built_in">min</span>(connectSizeToInitial[curSubSize], i);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                connectSizeToInitial[curSubSize] = i;</span><br><span class="line">                maxConnectSize = <span class="built_in">max</span>(maxConnectSize, curSubSize);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; maxConnectSize &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(auto&amp; p : connectSizeToInitial) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; p.first &lt;&lt; &quot; -&lt;&lt;&gt; &quot; &lt;&lt; p.second &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(auto&amp; p : rootToInit) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; p.first &lt;&lt; &quot; -&gt; &quot; &lt;&lt; p.second &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(hasLonelyInitial) &#123;</span><br><span class="line">            <span class="keyword">return</span> connectSizeToInitial[maxConnectSize];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(initial.<span class="built_in">begin</span>(), initial.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0778-泳池游泳上升泳池"><a href="#0778-泳池游泳上升泳池" class="headerlink" title="0778 泳池游泳上升泳池"></a>0778 泳池游泳上升泳池</h2><h3 id="1-题目-3"><a href="#1-题目-3" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swim-in-rising-water/">https://leetcode-cn.com/problems/swim-in-rising-water/</a></p>
<h3 id="2-解题思路-3"><a href="#2-解题思路-3" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 普通思路1<ul>
<li>对于每一个水位，采用bfs算法看是否能够到达，那么对于水位可以用二分法加速o(logn),bfs要o(n^2)，所以o(n^2logn)</li>
</ul>
</li>
<li>2 普通思路2<ul>
<li><strong>仔细理解改题目，问的是a和b什么时候能够连通的问题？那么自然就想到并查集</strong>，反复说一句哈：并查集并的子树，查的是子树的root</li>
<li>对于水位从低到高遍历，每次更新和当前水位相同高度的格子(注意，题目说的非常清除，所有的格子的值在0到n^2，且不同)和周围联通情况</li>
<li>每次更新完连通情况我们看一下是否能够使得左上角和右下角的两个节点相互连通即可。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != parent[x]) &#123;</span><br><span class="line">            parent[x] = parent[parent[x]];</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unionMerge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> findX = <span class="built_in">find</span>(parent, x);</span><br><span class="line">        <span class="type">int</span> findY = <span class="built_in">find</span>(parent, y);</span><br><span class="line">        <span class="keyword">if</span>(findX != findY) &#123;</span><br><span class="line">            parent[findX] = findY</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">swimInWater</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// for each threshold, maintain a unionFind</span></span><br><span class="line">        <span class="comment">// everytime increase thres, we modify the connection of unionFind</span></span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(n * n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Each value grid[i][j] is unique.</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">elevationToIdx</span>(n * n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                elevationToIdx[grid[i][j]][<span class="number">0</span>] = i;</span><br><span class="line">                elevationToIdx[grid[i][j]][<span class="number">1</span>] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; moves = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> thres = <span class="number">0</span>; thres &lt; n * n; ++thres) &#123;</span><br><span class="line">            <span class="comment">// when the rain rise, process the exact the same height grid</span></span><br><span class="line">            <span class="type">int</span> tarX = elevationToIdx[thres][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> tarY = elevationToIdx[thres][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> deltaXY : moves) &#123;</span><br><span class="line">                <span class="type">int</span> newX = tarX + deltaXY[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newY = tarY + deltaXY[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(newX &gt;= <span class="number">0</span> &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newX &lt; n &amp;&amp; newY &lt; n &amp;&amp; grid[newX][newY] &lt;= thres) &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; newX &lt;&lt; &quot; &quot; &lt;&lt; newY &lt;&lt; &quot;  -&gt;&quot; &lt;&lt; thres &lt;&lt;endl;</span></span><br><span class="line">                    <span class="built_in">unionMerge</span>(parent, grid[newX][newY], grid[tarX][tarY]);</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">find</span>(parent, grid[<span class="number">0</span>][<span class="number">0</span>]) == <span class="built_in">find</span>(parent, grid[n - <span class="number">1</span>][n - <span class="number">1</span>])) &#123;</span><br><span class="line">                        <span class="keyword">return</span> thres;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n*n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2021/11/30/shortestPath/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/30/shortestPath/" class="post-title-link" itemprop="url">shortestPath</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-30 18:01:52" itemprop="dateCreated datePublished" datetime="2021-11-30T18:01:52+08:00">2021-11-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-dijstra算法"><a href="#1-dijstra算法" class="headerlink" title="1 dijstra算法"></a>1 dijstra算法</h2><p>自<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95">wiki</a>:<br><img src="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/dijstra.107hdh232p9s.png" alt="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/dijstra.107hdh232p9s.png"><br>对于没有任何优化的戴克斯特拉算法，实际上等价于每次遍历了整个图的所有结点来找到Q(为图的点集)中满足条件的元素（即寻找最小的頂點是${\displaystyle O(|V|)}$的，此外实际上还需要遍历所有的边一遍，因此算法的复杂度是${\displaystyle O(|V|^{2}+|E|)}$<br>一个基于堆优化的实现：<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-priority_queue-stl/">https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-priority_queue-stl/</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INF 0x3f3f3f3f </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// iPair ==&gt; Integer Pair（整数对）</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; iPair; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 加边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(vector &lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; adj[], <span class="type">int</span> u, </span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">int</span> v, <span class="type">int</span> wt)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    adj[u].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(v, wt)); </span><br><span class="line">    adj[v].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(u, wt)); </span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 计算最短路</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shortestPath</span><span class="params">(vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; adj[], <span class="type">int</span> V, <span class="type">int</span> src)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 关于stl中的优先队列如何实现，参考下方网址：</span></span><br><span class="line">    <span class="comment">// http://geeksquiz.com/implement-min-heap-using-stl/ </span></span><br><span class="line">    priority_queue&lt; iPair, vector &lt;iPair&gt; , greater&lt;iPair&gt; &gt; pq; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 距离置为正无穷大</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(V, INF)</span></span>; </span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(V, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入源点，距离为0</span></span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, src)); </span><br><span class="line">    dist[src] = <span class="number">0</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 循环直到优先队列为空 */</span></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 每次从优先队列中取出顶点事实上是这一轮最短路径权值确定的点</span></span><br><span class="line">        <span class="type">int</span> u = pq.<span class="built_in">top</span>().second; </span><br><span class="line">        pq.<span class="built_in">pop</span>(); </span><br><span class="line">        <span class="keyword">if</span> (visited[u]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 遍历所有边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : adj[u]) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 得到顶点边号以及边权</span></span><br><span class="line">            <span class="type">int</span> v = x.first; </span><br><span class="line">            <span class="type">int</span> weight = x.second; </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//可以松弛</span></span><br><span class="line">            <span class="keyword">if</span> (dist[v] &gt; dist[u] + weight) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">// 松弛 </span></span><br><span class="line">                dist[v] = dist[u] + weight; </span><br><span class="line">                pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dist[v], v)); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 打印最短路</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Vertex Distance from Source\n&quot;</span>); </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; ++i) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \t\t %d\n&quot;</span>, i, dist[i]); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> V = <span class="number">9</span>; </span><br><span class="line">    vector&lt;iPair &gt; adj[V]; </span><br><span class="line">    <span class="built_in">addEdge</span>(adj, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>); </span><br><span class="line">    <span class="built_in">addEdge</span>(adj, <span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>); </span><br><span class="line">    <span class="built_in">addEdge</span>(adj, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>); </span><br><span class="line">    <span class="built_in">addEdge</span>(adj, <span class="number">1</span>, <span class="number">7</span>, <span class="number">11</span>); </span><br><span class="line">    <span class="built_in">addEdge</span>(adj, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>); </span><br><span class="line">    <span class="built_in">addEdge</span>(adj, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>); </span><br><span class="line">    <span class="built_in">addEdge</span>(adj, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>); </span><br><span class="line">    <span class="built_in">addEdge</span>(adj, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>); </span><br><span class="line">    <span class="built_in">addEdge</span>(adj, <span class="number">3</span>, <span class="number">5</span>, <span class="number">14</span>); </span><br><span class="line">    <span class="built_in">addEdge</span>(adj, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>); </span><br><span class="line">    <span class="built_in">addEdge</span>(adj, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>); </span><br><span class="line">    <span class="built_in">addEdge</span>(adj, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>); </span><br><span class="line">    <span class="built_in">addEdge</span>(adj, <span class="number">6</span>, <span class="number">8</span>, <span class="number">6</span>); </span><br><span class="line">    <span class="built_in">addEdge</span>(adj, <span class="number">7</span>, <span class="number">8</span>, <span class="number">7</span>); </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">shortestPath</span>(adj, V, <span class="number">0</span>); </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Floyd算法"><a href="#2-Floyd算法" class="headerlink" title="2 Floyd算法"></a>2 Floyd算法</h2><p>空间o(n^2)，时间o(n^3):<br>自<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95">wiki</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 let dist be a |V| × |V| array of minimum distances initialized to ∞ (infinity)</span><br><span class="line">2 for each vertex v</span><br><span class="line">3    dist[v][v] ← 0</span><br><span class="line">4 for each edge (u,v)</span><br><span class="line">5    dist[u][v] ← w(u,v)  // the weight of the edge (u,v)</span><br><span class="line">6 for k from 1 to |V|</span><br><span class="line">7    for i from 1 to |V|</span><br><span class="line">8       for j from 1 to |V|</span><br><span class="line">9          if dist[i][j] &gt; dist[i][k] + dist[k][j] </span><br><span class="line">10             dist[i][j] ← dist[i][k] + dist[k][j]</span><br><span class="line">11     end if</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2021/11/29/lcGraphUndirected1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/29/lcGraphUndirected1/" class="post-title-link" itemprop="url">lcGraphUndirected1 - 无向图题集1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-29 21:00:58" itemprop="dateCreated datePublished" datetime="2021-11-29T21:00:58+08:00">2021-11-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="0-一些基础"><a href="#0-一些基础" class="headerlink" title="0 一些基础"></a>0 一些基础</h1><h2 id="判断整个图是否连通"><a href="#判断整个图是否连通" class="headerlink" title="判断整个图是否连通"></a>判断整个图是否连通</h2><p>使用dfs判断整个图是否连通：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if not connected, return false</span></span><br><span class="line">vecctor&lt;<span class="type">int</span>&gt; stack = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(graph.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> visCnt = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// dfs to check if connected</span></span><br><span class="line"><span class="keyword">while</span>(!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> top = stack.<span class="built_in">back</span>();</span><br><span class="line">    <span class="type">bool</span> allVisited = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[top].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[graph[top][i]]) &#123;</span><br><span class="line">            stack.<span class="built_in">emplace_back</span>(graph[top][i]);</span><br><span class="line">            vis[graph[top][i]] = <span class="literal">true</span>;</span><br><span class="line">            allVisited = <span class="literal">false</span>;</span><br><span class="line">            visCnt++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(allVisited) &#123;</span><br><span class="line">        stack.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(visCnt != n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>使用bfs也是可以的，比如下面的<a href="#0684-%E5%86%97%E4%BD%99%E9%93%BE%E6%8E%A5">0684-冗余链接</a></p>
<h2 id="并查集的使用"><a href="#并查集的使用" class="headerlink" title="并查集的使用"></a>并查集的使用</h2><p>主要是将有关联的边聚合到同一个root里去，可以压缩路径加速find过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> curNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(parent[curNode] != curNode) &#123;</span><br><span class="line">        parent[curNode] = parent[parent[curNode]];</span><br><span class="line">        curNode = parent[curNode];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionMerge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">find</span>(parent, from);</span><br><span class="line">    <span class="type">int</span> y = <span class="built_in">find</span>(parent, to);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(x != y) &#123;</span><br><span class="line">        parent[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分图判断"><a href="#二分图判断" class="headerlink" title="二分图判断"></a>二分图判断</h2><ul>
<li><p>1 普通思路<br>使用bfs遍历，考虑奇偶层级，奇层级为节点集合A，偶层级为节点集合B，最后扫描一遍所有的边，判断是否有边位于AB而不是横跨AB的，<br>有的话返回false，不然则true</p>
</li>
<li><p>2 并查集</p>
</li>
<li><p>3 dfs</p>
</li>
</ul>
<h1 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h1><h2 id="0785-是否二分图"><a href="#0785-是否二分图" class="headerlink" title="0785 是否二分图"></a>0785 是否二分图</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/is-graph-bipartite/">https://leetcode-cn.com/problems/is-graph-bipartite/</a></p>
<h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 普通思路<br>使用bfs遍历，考虑奇偶层级，奇层级为节点集合A，偶层级为节点集合B，最后扫描一遍所有的边，判断是否有边位于AB而不是横跨AB的，<br>有的话返回false，不然则true；<br>同时注意邻接表的判空，所有边个数为0为空的图，是可以二分的哦！<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> edgeNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; ++u) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">0</span>; v &lt; graph[u].<span class="built_in">size</span>(); ++v) &#123;</span><br><span class="line">                ++edgeNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(edgeNum == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if not connected, return false</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; stack = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// vector&lt;bool&gt; vis(graph.size(), false);</span></span><br><span class="line">        <span class="comment">// vis[0] = true;</span></span><br><span class="line">        <span class="comment">// int visCnt = 1;</span></span><br><span class="line">        <span class="comment">// // dfs to check if connected</span></span><br><span class="line">        <span class="comment">// while(!stack.empty()) &#123;</span></span><br><span class="line">        <span class="comment">//     int top = stack.back();</span></span><br><span class="line">        <span class="comment">//     bool allVisited = true;</span></span><br><span class="line">        <span class="comment">//     for(int i = 0; i &lt; graph[top].size(); ++i) &#123;</span></span><br><span class="line">        <span class="comment">//         if(!vis[graph[top][i]]) &#123;</span></span><br><span class="line">        <span class="comment">//             stack.emplace_back(graph[top][i]);</span></span><br><span class="line">        <span class="comment">//             vis[graph[top][i]] = true;</span></span><br><span class="line">        <span class="comment">//             allVisited = false;</span></span><br><span class="line">        <span class="comment">//             visCnt++;</span></span><br><span class="line">        <span class="comment">//             break;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     if(allVisited) &#123;</span></span><br><span class="line">        <span class="comment">//         stack.pop_back();</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(visCnt != n) return false;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// bfs to judge biPartitable</span></span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; q = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis2</span><span class="params">(graph.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt; biPart1 = &#123;&#125;;</span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt; biPart2;</span><br><span class="line">            deque&lt;<span class="type">int</span>&gt; level = &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> bfsNum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(bfsNum != n) &#123;        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis2[i]) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                    level.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">                    biPart1.<span class="built_in">insert</span>(i);</span><br><span class="line">                    ++bfsNum;</span><br><span class="line">                    vis2[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> front = q.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[front].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!vis2[graph[front][i]]) &#123;</span><br><span class="line">                        q.<span class="built_in">emplace_back</span>(graph[front][i]);</span><br><span class="line">                        ++bfsNum;</span><br><span class="line">                        level.<span class="built_in">emplace_back</span>(level.<span class="built_in">front</span>() + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span>(level.<span class="built_in">front</span>() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                            biPart2.<span class="built_in">insert</span>(graph[front][i]);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            biPart1.<span class="built_in">insert</span>(graph[front][i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        vis2[graph[front][i]] = <span class="literal">true</span>;          </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">                level.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// for(auto&amp; i : biPart1) &#123;</span></span><br><span class="line">            <span class="comment">//     std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// for(auto&amp; i : biPart2) &#123;</span></span><br><span class="line">            <span class="comment">//     std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; ++u) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">0</span>; v &lt; graph[u].<span class="built_in">size</span>(); ++v) &#123;</span><br><span class="line">                    <span class="keyword">if</span>((biPart2.<span class="built_in">count</span>(u) == <span class="number">1</span> &amp;&amp; biPart2.<span class="built_in">count</span>(graph[u][v]) == <span class="number">1</span>) || \</span><br><span class="line">                    (biPart1.<span class="built_in">count</span>(u) == <span class="number">1</span> &amp;&amp; biPart1.<span class="built_in">count</span>(graph[u][v]) == <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="0765minSwapsCouple"><a href="#0765minSwapsCouple" class="headerlink" title="0765minSwapsCouple"></a>0765minSwapsCouple</h2><h3 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/couples-holding-hands/">https://leetcode-cn.com/problems/couples-holding-hands/</a></p>
<h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>0 一句话：找连通子图，每个连通子图节点数－1之和即为结果</li>
<li>1 普通思路<br>对于每一个2k - 2， 2k - 1的连续两个座位去找，2k - 2上的人的情侣，把它换到2k - 1位置上，遍历k即可 o(n**2)</li>
<li>2 改进思路<br>考虑到这样一个事实：<br>如果有8个座位，然后所有情侣都没办法相邻而坐，则考虑：将在2k-2和2k-1座位上的相邻两人但不是情侣创建一条边，节点则是情侣的cp序号<br>(比如4,5序号的情侣对应一个节点，为5/2 == 4/2 == 2)<br>然后我们可以知道，这个图只有一个连通子图，然后其节点数量为4，那么需要交换的次数为4-1 = 3，<blockquote>
<p>容易被迷惑的地方： 一次交换至少能够完成一对情侣，只有最后的一次交换能够完成两队情侣，其余均只能完成一次<br>所以说这个最小交换次数，其实别反复换，算出来的就是最小的</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSwapsCouples</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; row)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 容易被迷惑的地方： 一次交换至少能够完成一对情侣，只有最后的一次交换能够完成两队情侣，其余均只能完成一次</span></span><br><span class="line">        <span class="comment">// 所以说这个最小交换次数，其实别反复换，算出来的就是最小的</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 首先注意到，将2个情侣看成一个节点，如果不属于一对的情侣坐在2k - 2, 2k - 1的两个位置上，则连一条线</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(row.size() / <span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; row.<span class="built_in">size</span>() / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; row.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> nodeIdx = i / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">unionMerge</span>(parent, row[i] / <span class="number">2</span>, row[i + <span class="number">1</span>] / <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; row[i] / 2&lt;&lt; &quot; -&gt; &quot; &lt;&lt; row[i + 1] / 2 &lt;&lt; std::endl;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出上图所有连通子图, 所有连通子图的边的节点个数减去1得到一个子图所有情侣相邻而坐需要的交换次数</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; rootIdxToCnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; row.<span class="built_in">size</span>() / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            rootIdxToCnt[<span class="built_in">find</span>(parent, i)] ++;</span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; i &lt;&lt; &quot; -&gt; &quot; &lt;&lt; find(parent, i) &lt;&lt; std::endl;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it : rootIdxToCnt) &#123;</span><br><span class="line">            res += it.second - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> curNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(parent[curNode] != curNode) &#123;</span><br><span class="line">            parent[curNode] = parent[parent[curNode]];</span><br><span class="line">            curNode = parent[curNode];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionMerge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; parent, <span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(parent, from);</span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">find</span>(parent, to);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(x != y) &#123;</span><br><span class="line">            parent[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="0684-冗余链接"><a href="#0684-冗余链接" class="headerlink" title="0684 冗余链接"></a>0684 冗余链接</h2><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1 题目描述"></a>1 题目描述</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/redundant-connection">https://leetcode-cn.com/problems/redundant-connection</a></p>
<h3 id="2-解题思路-2"><a href="#2-解题思路-2" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><p>使用并查集，将每一条边都看做一个子树，然后一条边一条边加入这个树，当加入的边的两个顶点属于同一个子树时，就认为有回环，则返回这个冗余边。<br>见如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        tree.<span class="built_in">resize</span>(edges.<span class="built_in">size</span>() * <span class="number">2</span> + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        subTreeSize.<span class="built_in">resize</span>(edges.<span class="built_in">size</span>() * <span class="number">2</span> + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">unionMerge</span>(c[<span class="number">0</span>], c[<span class="number">1</span>], tree)) &#123;</span><br><span class="line">                res = c;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> tar, vector&lt;<span class="type">int</span>&gt;&amp; tree)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curFather = tree[tar];</span><br><span class="line">        <span class="keyword">if</span> (curFather &lt; <span class="number">0</span>) &#123; <span class="comment">// tar has no father, so he is the root</span></span><br><span class="line">            tree[tar] = tar;</span><br><span class="line">            <span class="keyword">return</span> tar;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tar != curFather) &#123;</span><br><span class="line">            tree[tar] = <span class="built_in">find</span>(curFather, tree); <span class="comment">// compress the data path</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tree[tar];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unionMerge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, vector&lt;<span class="type">int</span>&gt;&amp; tree)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">find</span>(x, tree);</span><br><span class="line">        <span class="type">int</span> fy = <span class="built_in">find</span>(y, tree);</span><br><span class="line">        <span class="keyword">if</span>(fx == fy) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// x, y are in the same tree, need no merge</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(subTreeSize[fx] &gt;= subTreeSize[fy])&#123; <span class="comment">// merge by rank of the sub Tree</span></span><br><span class="line">            tree[fy] = fx;</span><br><span class="line">            subTreeSize[fx] += subTreeSize[fy];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tree[fx] = fy;</span><br><span class="line">            subTreeSize[fy] += subTreeSize[fx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; subTreeSize;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2021/11/26/lcDictOrderAndPermutation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/26/lcDictOrderAndPermutation/" class="post-title-link" itemprop="url">lcDictOrderAndPermutation - 字典序和全排列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-26 13:06:20" itemprop="dateCreated datePublished" datetime="2021-11-26T13:06:20+08:00">2021-11-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="0-全排列算法"><a href="#0-全排列算法" class="headerlink" title="0 全排列算法"></a>0 全排列算法</h2><h3 id="0-1-全排列实现"><a href="#0-1-全排列实现" class="headerlink" title="0.1 全排列实现"></a>0.1 全排列实现</h3><ul>
<li>1 一个排列，其优先交换靠右的位置的数字来获得下一个排列，比如1 2 3，他下一个必定是交换2 3,1不会参与其中，</li>
<li>2 意识到一个排列，左侧属于高位，打个比方，若全排列对应的都有一个数字表示该排列的大小，那么左侧值越大，那么排列越大</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ref: https://blog.51cto.com/u_4925054/884291</span></span><br><span class="line">全排列（非递归求顺序）算法  </span><br><span class="line">1、建立位置数组，即对位置进行排列，排列成功后转换为元素的排列；  </span><br><span class="line">2、按如下算法求全排列：  </span><br><span class="line">    设P是1～n(位置编号)的一个全排列：p = p1,p2...pn = p1,p2...pj-1,pj,pj+1...pk-1,pk,pk+1...pn  </span><br><span class="line">    (1)从排列的尾部开始，找出第一个比右边位置编号小的索引j（j从首部开始计算），即j = max&#123;i | pi &lt; pi+1&#125;  </span><br><span class="line">    (2)在pj的右边的位置编号中，找出最后一个比pj大的位置编号索引k，即 k = max&#123;i | pi &gt; pj&#125; (k &gt; j)</span><br><span class="line">    (3)交换pj与pk  </span><br><span class="line">    (4)再将pj+1...pk-1,pk,pk+1...pn翻转得到排列p<span class="string">&#x27; = p1,p2...pj-1,pj,pn...pk+1,pk,pk-1...pj+1  </span></span><br><span class="line"><span class="string">    (5)p&#x27;</span>便是排列p的下一个排列  </span><br><span class="line"></span><br><span class="line">例如：  </span><br><span class="line">24310是位置编号0～4的一个排列，求它下一个排列的步骤如下：  </span><br><span class="line">(1)从右至左找出排列中第一个比右边数字小的数字2；  </span><br><span class="line">(2)在该数字后的数字中找出比2大的数中编号最大的3；  </span><br><span class="line">(3)将2与3交换得到34210；  </span><br><span class="line">(4)将原来2（当前3）后面的所有数字翻转，即翻转4210，得30124；  </span><br><span class="line">(5)求得24310的下一个排列为30124。  </span><br></pre></td></tr></table></figure>

<p>这里给出官方的可能实现：<br>5 6 1 2 3 4的下一个排列是： 6 1 2 3 4 5</p>
<h3 id="0-2-迭代实现"><a href="#0-2-迭代实现" class="headerlink" title="0.2 迭代实现"></a>0.2 迭代实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如求 6 5 4 2 3 1的下一个排列</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BidirIt&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">next_permutation</span><span class="params">(BidirIt first, BidirIt last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    BidirIt i = last;</span><br><span class="line">    <span class="keyword">if</span> (first == --i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        BidirIt i1, i2;</span><br><span class="line"> </span><br><span class="line">        i1 = i;</span><br><span class="line">        <span class="keyword">if</span> (*--i &lt; *i1) &#123; <span class="comment">// i = prev(i1), 找到了一个 i &lt; i1的(2 &lt; 3)相邻对子</span></span><br><span class="line">            i2 = last;</span><br><span class="line">            <span class="keyword">while</span> (!(*i &lt; *--i2)) <span class="comment">// 从i的右边找最后一个比i大的数字</span></span><br><span class="line">                ;</span><br><span class="line">            std::<span class="built_in">iter_swap</span>(i, i2); <span class="comment">// 交换 i和i2 (2,3),变成6 5 4 3 2 1</span></span><br><span class="line">            std::<span class="built_in">reverse</span>(i1, last); <span class="comment">// 从i1(原始数据中的3处)到最后，得到 6 5 4 3 1 2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == first) &#123; <span class="comment">// 若果找不到两个相邻的数，使得右边&lt;左边,则认为是最大排列</span></span><br><span class="line">            std::<span class="built_in">reverse</span>(first, last);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2 回溯<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">chooseN3</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; dq, <span class="type">int</span> n, priority_queue&lt;string, vector&lt;string&gt;, std::function&lt;<span class="type">bool</span>(string, string)&gt;&gt;&amp; res, string&amp; tmpRes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push</span>(tmpRes);</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;-d2 &quot; &lt;&lt; tmpRes &lt;&lt; &quot; with n = &quot; &lt;&lt; tmpRes.size() &lt;&lt;std::endl;</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; dq.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        tmpRes.<span class="built_in">push_back</span>(dq[i]);</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; tmpDq;</span><br><span class="line">        tmpDq.<span class="built_in">insert</span>(tmpDq.<span class="built_in">end</span>(), dq.<span class="built_in">begin</span>(), dq.<span class="built_in">begin</span>() + i);</span><br><span class="line">        tmpDq.<span class="built_in">insert</span>(tmpDq.<span class="built_in">end</span>(), dq.<span class="built_in">begin</span>() + i + <span class="number">1</span>, dq.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">chooseN3</span>(tmpDq, n - <span class="number">1</span>, res, tmpRes);</span><br><span class="line">        tmpRes.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2014-重复-K-次的最长子序列"><a href="#2014-重复-K-次的最长子序列" class="headerlink" title="2014 重复 K 次的最长子序列"></a>2014 重复 K 次的最长子序列</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph/">https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph/</a></p>
<h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 自己的思路： 首先查出来哪些字符有k个，压入dq中，若一个字符有2k个，则压入两次(代表最终结果里可以有两个该字符)，而后将其逆序排序</li>
<li>2 那么最后的结果一定是从dq中来，我们可以枚举dq的所有子序列即可(枚举子序列需要按照逆序字典序，这样找到的第一个子序列即为我们的目标)</li>
<li>关键: 如何获得逆序子序列呢？ <ul>
<li>1.1 最简单的想法，从dq(已经是最大的子序列了)中选择长度为n(7到1)的子序列，获取每个子序列(由于父序列为最大序列，那么子序列也一定是最大序列)所有的全排列</li>
<li>1.2 但是这样做有问题，比如 有fd，fe两个子序列，那么优先对于fe去看其所有的排列是否满足要求，然而若是ef满足要求，那么其检测顺序在fd前面，</li>
<li>这样就没有满足按照逆序字典序的方法去检测，于是对于长度为n的子序列，需要先生成所有的全排列，然后按照字典序排序，<br>最后中实现总代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestSubsequenceRepeatedK</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找出大于等于k的字符记作kSet</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; dq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> charNo = s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            ++cnt[charNo];</span><br><span class="line">            <span class="keyword">if</span>(cnt[charNo] % k == <span class="number">0</span>) &#123;</span><br><span class="line">                dq.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将kSet按照逆序字典序排序</span></span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="type">char</span> a, <span class="type">char</span> b) &#123;<span class="keyword">return</span> a &gt; b;&#125;;</span><br><span class="line">        <span class="built_in">sort</span>(dq.<span class="built_in">begin</span>(), dq.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// string tmp = &quot;&quot;;</span></span><br><span class="line">            <span class="comment">// for(char&amp; c : dq) tmp += c;</span></span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; &quot;-d1 &quot; &lt;&lt; tmp &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到第一个满足的最大长度为dq的字典序逆序的子序列的排列即为结果</span></span><br><span class="line">        <span class="comment">// 从子模式串的最大长度dq.size()一直遍历到1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len = dq.<span class="built_in">size</span>(); len &gt;= <span class="number">1</span>; --len) &#123;</span><br><span class="line">            <span class="comment">// vector&lt;char&gt; tmp;</span></span><br><span class="line">            <span class="comment">// vector&lt;vector&lt;char&gt;&gt; res;</span></span><br><span class="line">            <span class="comment">// chooseN(dq, len, 0, res, tmp);</span></span><br><span class="line">            <span class="comment">// string tmp;</span></span><br><span class="line">            <span class="comment">// vector&lt;string&gt; res;</span></span><br><span class="line">            <span class="comment">// chooseN2(dq, len, 0, res, tmp);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// // 构建出同len的所有permutaion，然后sort然后再来以此比较</span></span><br><span class="line">            <span class="comment">// vector&lt;string&gt; sameLenStr;</span></span><br><span class="line">            <span class="comment">// for(int i = 0; i &lt; res.size(); ++i) &#123;</span></span><br><span class="line">            <span class="comment">//     do &#123;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//         // string tmp4 = &quot;&quot;;</span></span><br><span class="line">            <span class="comment">//         // for(char&amp; c : res[i]) tmp4 += c;</span></span><br><span class="line">            <span class="comment">//         // std::cout &lt;&lt; &quot;-d4 &quot; &lt;&lt; tmp4 &lt;&lt; &quot; with n = &quot; &lt;&lt; len &lt;&lt;std::endl;</span></span><br><span class="line">            <span class="comment">//         sameLenStr.push_back(res[i]);</span></span><br><span class="line">            <span class="comment">//     &#125;while(prev_permutation(res[i].begin(), res[i].end()));</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// sort(sameLenStr.begin(), sameLenStr.end(), [](string a, string b)&#123;return a &gt; b;&#125;);</span></span><br><span class="line">                        <span class="comment">// for(int subIdx = 0; subIdx &lt; sameLenStr.size(); ++subIdx) &#123;</span></span><br><span class="line">            <span class="comment">//     // do &#123;</span></span><br><span class="line">            <span class="comment">//     // 构造seq*k</span></span><br><span class="line">            <span class="comment">//     string tmpDq;</span></span><br><span class="line">            <span class="comment">//     for(int i = 0; i &lt; k; ++i) &#123;</span></span><br><span class="line">            <span class="comment">//         tmpDq += sameLenStr[subIdx];</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">            <span class="comment">//     // string tmp3 = &quot;&quot;;</span></span><br><span class="line">            <span class="comment">//     // for(char&amp; c : tmpDq) tmp3 += c;</span></span><br><span class="line">            <span class="comment">//     // std::cout &lt;&lt; &quot;-d3 &quot; &lt;&lt; tmp3 &lt;&lt; &quot; with n = &quot; &lt;&lt; tmpDq.size() &lt;&lt;std::endl;</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">            <span class="comment">//     // 判断构造的seq*k是否存在于s中</span></span><br><span class="line">            <span class="comment">//     int tmpIdx = 0;</span></span><br><span class="line">            <span class="comment">//     int realIdx = 0;</span></span><br><span class="line">            <span class="comment">//     int cnt = 0;</span></span><br><span class="line">            <span class="comment">//     for(; tmpIdx &lt; tmpDq.size(); ++tmpIdx) &#123;</span></span><br><span class="line">            <span class="comment">//         for(; realIdx &lt; n; ++realIdx) &#123;</span></span><br><span class="line">            <span class="comment">//             if(s[realIdx] == tmpDq[tmpIdx]) &#123;</span></span><br><span class="line">            <span class="comment">//                 ++cnt;</span></span><br><span class="line">            <span class="comment">//                 ++realIdx;</span></span><br><span class="line">            <span class="comment">//                 break;</span></span><br><span class="line">            <span class="comment">//             &#125;</span></span><br><span class="line">            <span class="comment">//         &#125;</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">            <span class="comment">//     </span></span><br><span class="line">            <span class="comment">//     if(cnt == tmpDq.size()) &#123;</span></span><br><span class="line">            <span class="comment">//         return sameLenStr[subIdx];</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">//         </span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            string tmp;</span><br><span class="line">            std::function&lt;<span class="type">bool</span>(string, string)&gt; cmp = [](string a, string b)-&gt;<span class="type">bool</span>&#123;<span class="keyword">return</span> a &lt; b;&#125;;</span><br><span class="line">            priority_queue&lt;string, vector&lt;string&gt;, std::function&lt;<span class="type">bool</span>(string, string)&gt;&gt; <span class="built_in">sameLenStr</span>(cmp);</span><br><span class="line">            <span class="built_in">chooseN3</span>(dq, len, sameLenStr, tmp);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 看该子序列是否可以</span></span><br><span class="line">            <span class="keyword">while</span>(!sameLenStr.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                string curStr = sameLenStr.<span class="built_in">top</span>();</span><br><span class="line">                sameLenStr.<span class="built_in">pop</span>();</span><br><span class="line">                string tmpDq;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                    tmpDq += curStr;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// string tmp3 = &quot;&quot;;</span></span><br><span class="line">                <span class="comment">// for(char&amp; c : tmpDq) tmp3 += c;</span></span><br><span class="line">                <span class="comment">// if(curStr.size() &lt;= 10)std::cout &lt;&lt; &quot;-d3 &quot; &lt;&lt; curStr &lt;&lt; &quot; with n = &quot; &lt;&lt; tmpDq.size() &lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断构造的seq*k是否存在于s中</span></span><br><span class="line">                <span class="type">int</span> tmpIdx = <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> realIdx = <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(; tmpIdx &lt; tmpDq.<span class="built_in">size</span>(); ++tmpIdx) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(; realIdx &lt; n; ++realIdx) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(s[realIdx] == tmpDq[tmpIdx]) &#123;</span><br><span class="line">                            ++cnt;</span><br><span class="line">                            ++realIdx;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cnt == tmpDq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> curStr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">chooseN2</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; dq, <span class="type">int</span> n, <span class="type">int</span> st, vector&lt;string&gt;&amp; res, string&amp; tmpRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmpRes);</span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; &quot;-d2 &quot; &lt;&lt; tmpRes &lt;&lt; &quot; with n = &quot; &lt;&lt; tmpRes.size() &lt;&lt;std::endl;</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = st; i &lt; dq.<span class="built_in">size</span>() - n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            tmpRes.<span class="built_in">push_back</span>(dq[i]);</span><br><span class="line">            <span class="built_in">chooseN2</span>(dq, n - <span class="number">1</span>, i + <span class="number">1</span>, res, tmpRes);</span><br><span class="line">            tmpRes.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">chooseN3</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; dq, <span class="type">int</span> n, priority_queue&lt;string, vector&lt;string&gt;, std::function&lt;<span class="type">bool</span>(string, string)&gt;&gt;&amp; res, string&amp; tmpRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push</span>(tmpRes);</span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; &quot;-d2 &quot; &lt;&lt; tmpRes &lt;&lt; &quot; with n = &quot; &lt;&lt; tmpRes.size() &lt;&lt;std::endl;</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; dq.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            tmpRes.<span class="built_in">push_back</span>(dq[i]);</span><br><span class="line">            vector&lt;<span class="type">char</span>&gt; tmpDq;</span><br><span class="line">            tmpDq.<span class="built_in">insert</span>(tmpDq.<span class="built_in">end</span>(), dq.<span class="built_in">begin</span>(), dq.<span class="built_in">begin</span>() + i);</span><br><span class="line">            tmpDq.<span class="built_in">insert</span>(tmpDq.<span class="built_in">end</span>(), dq.<span class="built_in">begin</span>() + i + <span class="number">1</span>, dq.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">chooseN3</span>(tmpDq, n - <span class="number">1</span>, res, tmpRes);</span><br><span class="line">            tmpRes.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="0047-全排列去重"><a href="#0047-全排列去重" class="headerlink" title="0047 全排列去重"></a>0047 全排列去重</h2></li>
</ul>
</li>
</ul>
<h3 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/">https://leetcode-cn.com/problems/permutations-ii/</a></p>
<h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_set&lt;string&gt; hash;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// vector&lt;vector&lt;int&gt;&gt; res;</span></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; tmp;</span></span><br><span class="line">        <span class="comment">// string tmpStr = &quot;&quot;;</span></span><br><span class="line">        <span class="comment">// chooseN(nums, nums.size(), res, tmp, tmpStr);</span></span><br><span class="line">        <span class="comment">// vector&lt;vector&lt;int&gt;&gt; res;</span></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; tmp;</span></span><br><span class="line">        <span class="comment">// string tmpStr = &quot;&quot;;</span></span><br><span class="line">        <span class="comment">// chooseN2(nums, 0, nums.size(), res, tmpStr);</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">chooseN3</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>(), res, vis, tmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 160ms</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">chooseN</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="type">int</span>&gt;&amp; tmp, string tmpStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">count</span>(tmpStr) == <span class="number">0</span>) &#123;</span><br><span class="line">                std::cout &lt;&lt; tmpStr &lt;&lt; std::endl;</span><br><span class="line">                hash.<span class="built_in">insert</span>(tmpStr);</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            </span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tmpNums;</span><br><span class="line">            tmpNums.<span class="built_in">insert</span>(tmpNums.<span class="built_in">end</span>(), nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + i);</span><br><span class="line">            tmpNums.<span class="built_in">insert</span>(tmpNums.<span class="built_in">end</span>(), nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">            tmp.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            tmpStr.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(nums[i] + <span class="number">107</span>));</span><br><span class="line">            <span class="built_in">chooseN</span>(tmpNums, n<span class="number">-1</span>, res, tmp, tmpStr);</span><br><span class="line">            tmpStr.<span class="built_in">pop_back</span>();</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// chooseN由于每次构造新的串子，这样降低了速度，只用swap到最左边就行了</span></span><br><span class="line">    <span class="comment">// 32ms</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">chooseN2</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> st, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, string tmpStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">count</span>(tmpStr) == <span class="number">0</span>) &#123;</span><br><span class="line">                std::cout &lt;&lt; tmpStr &lt;&lt; std::endl;</span><br><span class="line">                hash.<span class="built_in">insert</span>(tmpStr);</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = st; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            </span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tmpNums;</span><br><span class="line">            tmpStr.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(nums[i] + <span class="number">107</span>));</span><br><span class="line">            <span class="built_in">swap</span>(nums[st], nums[i]);</span><br><span class="line">                      </span><br><span class="line">            <span class="built_in">chooseN2</span>(nums, st + <span class="number">1</span>, nums.<span class="built_in">size</span>(),  res, tmpStr);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swap</span>(nums[st], nums[i]);</span><br><span class="line">            tmpStr.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于使用string来判断还是降低了速度，于是在搜索过程中判断是否能够压入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">chooseN3</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> st, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="type">bool</span>&gt;&amp; vis, vector&lt;<span class="type">int</span>&gt;&amp; tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 如果当前数作为第st层的回溯已经用过了，则不再使用 || 若当前数字和st层上一次使用数字相同，则也不再使用</span></span><br><span class="line">            <span class="keyword">if</span>(vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if (vis[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !vis[i - 1])) &#123;</span></span><br><span class="line">            <span class="comment">//     continue;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tmpNums;</span><br><span class="line">            tmp.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">                      </span><br><span class="line">            <span class="built_in">chooseN3</span>(nums, st + <span class="number">1</span>, nums.<span class="built_in">size</span>(),  res, vis, tmp);</span><br><span class="line"></span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="comment">// swap(nums[st], nums[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2021/11/24/lcGraphDirected1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/24/lcGraphDirected1/" class="post-title-link" itemprop="url">lcGraphDirected1 - 有向图 1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-24 18:36:43" itemprop="dateCreated datePublished" datetime="2021-11-24T18:36:43+08:00">2021-11-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="0-有向图的环路判断"><a href="#0-有向图的环路判断" class="headerlink" title="0 有向图的环路判断"></a>0 有向图的环路判断</h2><ul>
<li>1 bfs访问节点的数目超过n本身才能说明有环</li>
<li>2 或者dfs能够访问到之前访问过的节点，也说明有环</li>
<li>3 不能仅仅通过是否有出度为0的节点来判断是否成环，eg:<br>[[0,1],[1,1]]</li>
</ul>
<h2 id="1857largestPathValue-路径最大节点颜色数"><a href="#1857largestPathValue-路径最大节点颜色数" class="headerlink" title="1857largestPathValue 路径最大节点颜色数"></a>1857largestPathValue 路径最大节点颜色数</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph/">https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph/</a></p>
<h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 自己的思路：自然能够想到的解题方法, 对于出度为0的点做dfs，然后统计每个颜色的值</li>
<li>2 思路存在的问题：<blockquote>
<p>上述算法的遍历节点总是从出度为0的地方开始遍历所有可能的路径<br>有重复计算的第方，想象一下，1, 2分别连着3,3后面跟了1000个节点<br>那么会从1,2分别计算一遍，那3后面的1000个节点被重复计算了2次</p>
</blockquote>
</li>
<li>3 解决思路：<blockquote>
<p>很显然我们就会想到从小规模开始计算，那么1,2的计算结果就能利用<br>小规模的值得到了,那么什么样的节点算是小规模子图的起始点？<br>这隐藏了一个拓扑排序 + 动态规划的思路在其中：<br>如果想要减少上述重复计算过程，可以考虑使用动态规划，但是<br>需要直到1,2,3以及后面节点谁在前谁在后的问题，使用拓扑排序解决<br>这里可以顺便说一下<br>首先bfs获得拓扑排序，依此入栈s，(则s的栈顶得到的是没有后继节点的<br>那些节点)，则依此从s中pop然后得到节点v，<strong>dp[v][c]代表从v出发的<br>颜色为c的最大值</strong>，则对于每个有到达v的边的u，有：<br>dp[u][c] = max(dp[u][c], dp[v][c]);<br>但是这个需要知道，v的前级节点有哪些，则需要翻转一遍v，所以就<br>bfs拓扑排序依此入队列，从队头出数据(这些数据都是没有入度的)，<br><strong>dp[v][c] 表示到达节点v的所有路径的颜色为c的最大值(并未统计v节点本身)</strong><br>对于u所有的 -&gt; v:<br>dp[v][c] = max(dp[u][c], dp[v][c]); // 广度优先遍历</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> from, string&amp; colors, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; g, map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; cntInPath)</span> </span>&#123;</span><br><span class="line">        cntInPath[colors[from]]++;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, cntInPath[colors[from]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> to = <span class="number">0</span>; to &lt; g.<span class="built_in">size</span>(); ++to) &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[from][to] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(to, colors, g, cntInPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cntInPath[colors[from]]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestPathValue</span><span class="params">(string colors, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// // 自然能够想到的解题方法: </span></span><br><span class="line">        <span class="comment">// // 基于出度为0的点做dfs，然后统计每个颜色的值</span></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; noInNode;</span></span><br><span class="line">        <span class="comment">// map&lt;int, int&gt; inDegreeStatistic;</span></span><br><span class="line">        <span class="comment">// for(auto &amp;e : edges) &#123;</span></span><br><span class="line">        <span class="comment">//     inDegreeStatistic[e[1]]++;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// int n = colors.size();</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; n; ++i) &#123;</span></span><br><span class="line">        <span class="comment">//     auto it = inDegreeStatistic.find(i);</span></span><br><span class="line">        <span class="comment">//     if(it == inDegreeStatistic.end()) &#123;</span></span><br><span class="line">        <span class="comment">//         noInNode.emplace_back(i);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(noInNode.size() == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     return -1;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, -1));</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; edges.size(); ++i) &#123;</span></span><br><span class="line">        <span class="comment">//     g[edges[i][0]][edges[i][1]] = 1;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// // 对每一个节点出度为0的遍历</span></span><br><span class="line">        <span class="comment">// int maxApperanceNumInPath = -1;</span></span><br><span class="line">        <span class="comment">// map&lt;char, int&gt; cntInPath;</span></span><br><span class="line">        <span class="comment">// for(auto&amp; c : colors) &#123;</span></span><br><span class="line">        <span class="comment">//     cntInPath[c] = 0;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// for(auto&amp; n : noInNode) &#123;</span></span><br><span class="line">        <span class="comment">//     dfs(n, colors, g, cntInPath);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上述算法的遍历节点总是从出度为0的地方开始遍历所有可能的路径</span></span><br><span class="line">        <span class="comment">// 有重复计算的第方，想象一下，1, 2分别连着3,3后面跟了1000个节点</span></span><br><span class="line">        <span class="comment">// 那么会动1,2分别计算一遍，那3后面的1000个节点被重复计算了2次</span></span><br><span class="line">        <span class="comment">// 很显然我们就会想到从小规模开始计算，那么1,2的计算结果就能利用</span></span><br><span class="line">        <span class="comment">// 小规模的值得到了,那么什么样的节点算是小规模子图的起始点？</span></span><br><span class="line">        <span class="comment">// 这隐藏了一个拓扑排序 + 动态规划的思路在其中：</span></span><br><span class="line">        <span class="comment">// 如果想要减少上述重复计算过程，可以考虑使用动态规划，但是</span></span><br><span class="line">        <span class="comment">// 需要直到1,2,3以及后面节点谁在前谁在后的问题，使用拓扑排序解决</span></span><br><span class="line">        <span class="comment">// dp[v][c] 表示到达节点v的所有路径的颜色为c的最大值(并未统计v节点本身)</span></span><br><span class="line">        <span class="comment">// 对于u所有的 -&gt; v: </span></span><br><span class="line">        <span class="comment">// dp[v][c] = max(dp[u][c], dp[v][c]); // 广度优先遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建邻接表，统计入度情况</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; noInNode;</span><br><span class="line">        <span class="type">int</span> n = colors.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line"></span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; inDeg;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : edges) &#123;</span><br><span class="line">            inDeg[e[<span class="number">1</span>]]++;</span><br><span class="line">            g[e[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 做拓扑排序，首先找到那些个入度为0的点</span></span><br><span class="line">        vector&lt;array&lt;<span class="type">int</span>, 26&gt;&gt; <span class="built_in">dp</span>(n);</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = inDeg.<span class="built_in">find</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(it == inDeg.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                q.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// bfs访问节点的数目超过n本身才能说明有环</span></span><br><span class="line">        <span class="comment">// 或者dfs能够访问到之前访问过的节点，也说明有环</span></span><br><span class="line">        <span class="comment">// 不能仅仅通过是否有出度为0的节点来判断是否成环，eg:</span></span><br><span class="line">        <span class="comment">// [[0,1],[1,1]]</span></span><br><span class="line">        <span class="type">int</span> bfsTravelNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 使用bfs遍历获取拓扑排序顺便动态规划</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++bfsTravelNum;</span><br><span class="line">            <span class="comment">// 取出一个没有入度的节点</span></span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="comment">// 访问到u节点</span></span><br><span class="line">            dp[u][colors[u] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新所有 以v为终点的路径(不包含v本身) 的颜色为c的最大节点数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">                inDeg[v]--;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">26</span>; ++c) &#123;</span><br><span class="line">                    dp[v][c] = <span class="built_in">max</span>(dp[v][c], dp[u][c]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 位于u拓扑排序后面的v</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> == inDeg[v]) &#123;</span><br><span class="line">                    q.<span class="built_in">push_back</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(bfsTravelNum != n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, *<span class="built_in">max_element</span>(dp[i].<span class="built_in">begin</span>(), dp[i].<span class="built_in">end</span>()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-环路判断"><a href="#3-环路判断" class="headerlink" title="3 环路判断"></a>3 环路判断</h3><ul>
<li>1 bfs访问节点的数目超过n本身才能说明有环</li>
<li>2 或者dfs能够访问到之前访问过的节点，也说明有环</li>
<li>3 不能仅仅通过是否有出度为0的节点来判断是否成环，eg:<br>[[0,1],[1,1]]</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2021/11/23/influxDBInstall/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/23/influxDBInstall/" class="post-title-link" itemprop="url">influxDBInstall</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-23 13:21:42" itemprop="dateCreated datePublished" datetime="2021-11-23T13:21:42+08:00">2021-11-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-docker-compose安装"><a href="#1-docker-compose安装" class="headerlink" title="1 docker-compose安装"></a>1 docker-compose安装</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://docs.influxdata.com/influxdb/v1.7/administration/config</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">influxdb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">influxdb:1.7-alpine</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">INFLUXDB_ADMIN_ENABLED=true</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">INFLUXDB_ADMIN_USER=$&#123;INFLUXDB_ADMIN_USER:-root&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">INFLUXDB_ADMIN_PASSWORD=$&#123;INFLUXDB_ADMIN_PASSWORD:-root&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">INFLUXDB_DB=test</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">INFLUXDB_HTTP_LOG_ENABLED=false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">INFLUXDB_REPORTING_DISABLED=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">INFLUXDB_USER=$&#123;INFLUXDB_USER:-test&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">INFLUXDB_USER_PASSWORD=$&#123;INFLUXDB_USER_PASSWORD:-test&#125;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8083:8083&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8086:8086&quot;</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">replicated</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">2048M</span></span><br><span class="line">        <span class="attr">reservations:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">1024M</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./local_bind_volume_dir:/var/lib/influxdb</span></span><br></pre></td></tr></table></figure>

<h2 id="1-5-基本概念理解"><a href="#1-5-基本概念理解" class="headerlink" title="1.5 基本概念理解"></a>1.5 基本概念理解</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yihuihui/p/11386679.html">https://www.cnblogs.com/yihuihui/p/11386679.html</a></p>
<h2 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2 基本操作"></a>2 基本操作</h2><p><a target="_blank" rel="noopener" href="https://jasper-zhang1.gitbooks.io/influxdb/content/Guide/writing_data.html">https://jasper-zhang1.gitbooks.io/influxdb/content/Guide/writing_data.html</a><br>插入一个值：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST <span class="string">&quot;http://localhost:8086/write?db=test&quot;</span> -u root:root --data-binary <span class="string">&quot;cpu_load_short,host=server01,region=us-west value=0.64,value2=0.86 1434055562000000000&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; insert cpu_load_short,host=server02,region=de value=0.1,value2=0.2</span><br></pre></td></tr></table></figure>
<p>从上面的输出，简单小结一下插入的语句写法:<br><strong>insert + measurement + “,” + tag=value,tag=value +  + field=value,field=value</strong></p>
<ul>
<li>tag与tag之间用逗号分隔；field与field之间用逗号分隔</li>
<li>tag与field之间用空格分隔</li>
<li>tag都是string类型，不需要引号将value包裹</li>
<li>field如果是string类型，需要加引号</li>
</ul>
<p>查询该值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cpu_load_short;</span><br><span class="line">name: cpu_load_short</span><br><span class="line"><span class="type">time</span>                host     region  <span class="keyword">value</span> value2</span><br><span class="line"><span class="comment">----                ----     ------  ----- ------</span></span><br><span class="line"><span class="number">1434055562000000000</span> server01 us<span class="operator">-</span>west <span class="number">0.64</span>  <span class="number">0.86</span></span><br><span class="line"><span class="number">1637648158355267700</span> server02 de      <span class="number">0.1</span>   <span class="number">0.2</span></span><br></pre></td></tr></table></figure>

<h2 id="4-代码操作"><a href="#4-代码操作" class="headerlink" title="4 代码操作:"></a>4 代码操作:</h2><p><strong>注意写入的过程需要保证有field，不能全为tag</strong>，将很多raw插入：(以下划线开始的为filed，filed字段不会建立索引，故查询慢)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String table, List&lt;Map&lt;String, Object&gt;&gt; rows)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(rows)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Point&gt; points = rows.stream()</span><br><span class="line">                .filter(e -&gt; !CollectionUtils.isEmpty(e))</span><br><span class="line">                .map(e -&gt; &#123;</span><br><span class="line">                        <span class="keyword">return</span> to(table, e);</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(points)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BatchPoints</span> <span class="variable">batchPoints</span> <span class="operator">=</span> BatchPoints.builder()</span><br><span class="line">                .points(points)</span><br><span class="line">                .build();</span><br><span class="line">        influxDB.write(batchPoints);</span><br><span class="line">        influxDB.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** to函数 **/</span> </span><br><span class="line">    <span class="keyword">private</span> Point <span class="title function_">to</span><span class="params">(String table, Map&lt;String, Object&gt; row)</span>  &#123;</span><br><span class="line">        Point.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> Point.measurement(table).time(getTime(row), TimeUnit.MILLISECONDS);</span><br><span class="line">        row.remove(<span class="string">&quot;time&quot;</span>);</span><br><span class="line">        row.forEach((k, v) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.startsWith(k, <span class="string">&quot;_&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> StringUtils.removeStart(k, <span class="string">&quot;_&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (v.getClass().getName().equals(<span class="type">boolean</span>.class.getName())) &#123;</span><br><span class="line">                    builder.addField(key, (<span class="type">boolean</span>) v);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.getClass().getName().equals(<span class="type">short</span>.class.getName())) &#123;</span><br><span class="line">                    builder.addField(key, (<span class="type">short</span>) v);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.getClass().getName().equals(<span class="type">int</span>.class.getName())) &#123;</span><br><span class="line">                    builder.addField(key, (<span class="type">int</span>) v);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.getClass().getName().equals(<span class="type">long</span>.class.getName())) &#123;</span><br><span class="line">                    builder.addField(key, (<span class="type">long</span>) v);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.getClass().getName().equals(<span class="type">float</span>.class.getName())) &#123;</span><br><span class="line">                    builder.addField(key, (<span class="type">float</span>) v);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.getClass().getName().equals(<span class="type">double</span>.class.getName())) &#123;</span><br><span class="line">                    builder.addField(key, (<span class="type">double</span>) v);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">                    builder.addField(key, (Boolean) v);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Number) &#123;</span><br><span class="line">                    builder.addField(key, (Number) v);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                    builder.addField(key, (String) v);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    builder.addField(key, v.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                builder.tag(k, v.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/** build函数(influxdb官方维护) 将会检测是否含有field字段 **/</span> </span><br><span class="line">        <span class="keyword">public</span> Point <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            Preconditions.checkNonEmptyString(<span class="built_in">this</span>.measurement, <span class="string">&quot;measurement&quot;</span>);</span><br><span class="line">            Preconditions.checkPositiveNumber(<span class="built_in">this</span>.fields.size(), <span class="string">&quot;fields size&quot;</span>); <span class="comment">// 此处需保证fields size 大于等于1</span></span><br><span class="line">            <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">            point.setFields(<span class="built_in">this</span>.fields);</span><br><span class="line">            point.setMeasurement(<span class="built_in">this</span>.measurement);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.time != <span class="literal">null</span>) &#123;</span><br><span class="line">                point.setTime(<span class="built_in">this</span>.time);</span><br><span class="line">                point.setPrecision(<span class="built_in">this</span>.precision);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            point.setTags(<span class="built_in">this</span>.tags);</span><br><span class="line">            <span class="keyword">return</span> point;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2021/11/18/lcMovingWindow1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/18/lcMovingWindow1/" class="post-title-link" itemprop="url">lcMovingWindow - 滑动窗口 1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-18 15:12:14" itemprop="dateCreated datePublished" datetime="2021-11-18T15:12:14+08:00">2021-11-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1 滑动窗口"></a>1 滑动窗口</h1><p>priority_queue经常用</p>
<h2 id="0480-滑动窗口中位数"><a href="#0480-滑动窗口中位数" class="headerlink" title="0480 滑动窗口中位数"></a>0480 滑动窗口中位数</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sliding-window-median/">https://leetcode-cn.com/problems/sliding-window-median/</a></p>
<h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 使用一个multiset维护当前窗口，<ul>
<li>1.1 不使用priority_queue的原因，无法删除元素</li>
<li>1.2 不使用map/set的原因，不能含有重复元素</li>
</ul>
</li>
<li>2 对于窗口，维护一个中位数指针，注意到中位数指针在每一次窗口移动只会发生几种情况<ul>
<li>2.1 向左，向右，不动</li>
<li>2.2 分类讨论清除即可</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        std::multiset&lt;<span class="type">long</span> <span class="type">long</span>, std::less&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">mySet</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">        multiset&lt;<span class="type">long</span> <span class="type">long</span>&gt;::iterator mid = mySet.<span class="built_in">begin</span>();</span><br><span class="line">        std::<span class="built_in">advance</span>(mid, (k<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = k; i &lt;= n; ++i) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>((*mid + *<span class="built_in">next</span>(mid, <span class="number">1</span> - k%<span class="number">2</span>))*<span class="number">1.0L</span>/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(i == n) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            mySet.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; *mid &amp;&amp; nums[i - k] &lt; *mid) &#123;</span><br><span class="line">                mid++;</span><br><span class="line">                mySet.<span class="built_in">erase</span>(mySet.<span class="built_in">lower_bound</span>(nums[i-k]));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// std::advance(mid, 1);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; *mid &amp;&amp; nums[i - k] &gt; *mid) &#123;</span><br><span class="line">                mid--;</span><br><span class="line">                mySet.<span class="built_in">erase</span>(mySet.<span class="built_in">lower_bound</span>(nums[i-k]));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// std::advance(mid, -1);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7 3 7 7 4, k = 4</span></span><br><span class="line">            <span class="comment">// 7 8 7 7 4, k = 4</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i-k] == *mid) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt;= *mid)  ++mid;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(*<span class="built_in">prev</span>(mid) != *mid) &#123;</span><br><span class="line">                        --mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mySet.<span class="built_in">erase</span>(mySet.<span class="built_in">lower_bound</span>(nums[i-k]));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == *mid) &#123;<span class="comment">// 相当于一个比mid大的数字插入到了mid的前面</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i-k] &lt;= *mid)  ++mid;</span><br><span class="line">                mySet.<span class="built_in">erase</span>(mySet.<span class="built_in">lower_bound</span>(nums[i-k]));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="0992-k个不同元素的子数组个数"><a href="#0992-k个不同元素的子数组个数" class="headerlink" title="0992 k个不同元素的子数组个数"></a>0992 k个不同元素的子数组个数</h2><h3 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/submissions/">https://leetcode-cn.com/problems/subarrays-with-k-different-integers/submissions/</a></p>
<h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 正常思路：<ul>
<li>1.1 首先窗口是必须的，即为[st, ed]，那么保证这个窗口时刻含有k个不同变量，然后求出来每个以ed为结尾的子数组的个数求和即可</li>
<li>1.2 那么以ed为结尾的窗口[st, ed]的子数组个数求法，假设k=2，窗口为1,2，1,2,那么以ed为结尾，st就向前移动，直到窗口内的不同元素个数减少到了k-1，此时st移动到第二个2的位置，一共移动了3次，也就是说以ed为结尾的含有k个不同变量的子数组个数为3。</li>
<li>1.3 其中的复杂之地在于：如何判断窗口内不同元素的个数，我们采用经典的空间换时间的方法(因为所有元素的值不会大于数组本身长度),用freq[val]记录val出现的次数， 倘若长度不限呢？那就需要使用unordered_map来记录当前窗口所有元素的出现次数，然后每移动一次st需要遍历一遍这个map来判断当前窗口内不同元素的个数，那么整体复杂度为： o(n * k * k)</li>
</ul>
</li>
<li>2 官方题解：<ul>
<li>2.1 不同元素为k的子数组的个数为： 不同元素最多为k的子数组个数 - 不同元素最多为k-1的子数组个数，那么问题转为求不同元素最多为k的一个数组它子数组的个数</li>
<li>2.2 求法： 还是滑动窗口的思想，始终保持窗口中最多元素的个数不超过k（方式为每次移动ed，直到第一次超过k，然后移动st直到小于k），然后对于每个ed，ed - st就是以ed为窗口结尾对应的不同元素不超过k的子数组的个数，举个例子：(官方例子)：<blockquote>
<p>用具体的例子理解：最多包含 3 种不同整数的子区间 [1, 3, 2, 3] （双指针算法是在左边界固定的前提下，让右边界走到最右边），当前可以确定 1 开始的满足最多包含 3 种不同整数的子区间有 [1]、[1, 3]、[1, 3, 2]、[1, 3, 2, 3]。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maxSubArrayNumForKDiff</span>(nums, k) - <span class="built_in">maxSubArrayNumForKDiff</span>(nums, k - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArrayNumForKDiff</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">freq</span><span class="params">(nums.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> st = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ed = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> curCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ed &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 求每个ed对应得到的最多k个不同元素的子数组个数</span></span><br><span class="line">            <span class="keyword">if</span>(freq[nums[ed]] == <span class="number">0</span>) &#123;</span><br><span class="line">                curCnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            freq[nums[ed]]++;</span><br><span class="line">            ++ed;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 减小窗口到窗口内元素种类第一次为k-1个</span></span><br><span class="line">            <span class="keyword">while</span>(curCnt &gt; k) &#123;</span><br><span class="line">                freq[nums[st]]--;</span><br><span class="line">                <span class="keyword">if</span>(freq[nums[st]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    curCnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                ++st;</span><br><span class="line">            &#125;</span><br><span class="line">            res += ed - st;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0904-完全水果个数"><a href="#0904-完全水果个数" class="headerlink" title="0904 完全水果个数"></a>0904 完全水果个数</h2><h3 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fruit-into-baskets/">https://leetcode-cn.com/problems/fruit-into-baskets/</a></p>
<h3 id="2-解题思路-2"><a href="#2-解题思路-2" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 正常思路：(于0904<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fruit-into-baskets/">https://leetcode-cn.com/problems/fruit-into-baskets/</a>实现)<ul>
<li>1.1 首先窗口是必须的，即为[st, ed]，那么保证这个窗口时刻含有k个不同变量，然后求出来每个以ed为结尾的子数组的个数求和即可</li>
<li>1.2 那么以ed为结尾的窗口[st, ed]的子数组个数求法，假设k=2，窗口为1,2，1,2,那么以ed为结尾，st就向前移动，直到窗口内的不同元素个数减少到了k-1，此时st移动到第二个2的位置，一共移动了3次，也就是说以ed为结尾的含有k个不同变量的子数组个数为3。</li>
<li>1.3 其中的复杂之地在于：如何判断窗口内不同元素的个数，我们采用经典的空间换时间的方法(因为所有元素的值不会大于数组本身长度),用freq[val]记录val出现的次数， 倘若长度不限呢？那就需要使用unordered_map来记录当前窗口所有元素的出现次数，然后每移动一次st需要遍历一遍这个map来判断当前窗口内不同元素的个数，那么整体复杂度为： o(n * k * (log k)) = o(n)</li>
</ul>
</li>
<li>2 官方题解：<ul>
<li>2.1 不同元素为k的子数组的个数为： 不同元素最多为k的子数组个数 - 不同元素最多为k-1的子数组个数，那么问题转为求不同元素最多为k的一个数组它子数组的个数</li>
<li>2.2 求法： 还是滑动窗口的思想，始终保持窗口中最多元素的个数不超过k（方式为每次移动ed，直到第一次超过k，然后移动st直到小于k），然后对于每个ed，ed - st就是以ed为窗口结尾对应的不同元素不超过k的子数组的个数，举个例子：(官方例子)：<blockquote>
<p>用具体的例子理解：最多包含 3 种不同整数的子区间 [1, 3, 2, 3] （双指针算法是在左边界固定的前提下，让右边界走到最右边），当前可以确定 1 开始的满足最多包含 3 种不同整数的子区间有 [1]、[1, 3]、[1, 3, 2]、[1, 3, 2, 3]。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fruits.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不同元素最多为2的数组长度</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> st = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ed = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> curCnt = <span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freq;</span><br><span class="line">        <span class="type">bool</span> stNotMov = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(ed &lt; fruits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(freq.<span class="built_in">size</span>() &lt;= <span class="number">2</span> &amp;&amp; ed &lt; fruits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(freq.<span class="built_in">find</span>(fruits[ed]) == freq.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    curCnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                freq[fruits[ed]]++;</span><br><span class="line">                ed++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!stNotMov &amp;&amp; ed != fruits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                res = std::<span class="built_in">max</span>(res, ed - st - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">                <span class="keyword">if</span>(freq.<span class="built_in">size</span>() == <span class="number">3</span>) &#123;</span><br><span class="line">                    res = std::<span class="built_in">max</span>(res, ed - st - <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res = std::<span class="built_in">max</span>(res, ed - st);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(freq.<span class="built_in">size</span>() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                freq[fruits[st]]--;</span><br><span class="line">                <span class="keyword">if</span>(freq[fruits[st]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    freq.<span class="built_in">erase</span>(freq.<span class="built_in">find</span>(fruits[st]));</span><br><span class="line">                &#125;</span><br><span class="line">                ++st;</span><br><span class="line">                stNotMov = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0995-执行次数最小-每次翻转k个让数组全为1"><a href="#0995-执行次数最小-每次翻转k个让数组全为1" class="headerlink" title="0995 执行次数最小: 每次翻转k个让数组全为1"></a>0995 执行次数最小: 每次翻转k个让数组全为1</h2><h3 id="1-题目-3"><a href="#1-题目-3" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/">https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/</a></p>
<h3 id="2-解题思路-3"><a href="#2-解题思路-3" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 正常思路：窗口始终保持k个，去模拟翻转过程，由于需要在窗口内找到翻转后第一个为0的数字，这个复杂度为O（k），所以总复杂度为： O(n*k)</li>
<li>2 官方题解：使用差分数组diff,diff[i]表示nums[i]比nums[i-1]多了多少次翻转，那么当前总的翻转次数就为： sum(diff[i])，对于nums[i]而言， sum(diff[i])%2为0则表示nums[i]需要翻转。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minKBitFlips</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; preSum = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> num : nums) &#123;</span><br><span class="line">            preSum.<span class="built_in">emplace_back</span>(preSum.<span class="built_in">back</span>() + num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> st = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ed = st + k - <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">diff</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> flipCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// while(st &lt; n - k + 1) &#123;</span></span><br><span class="line">            <span class="comment">// 模拟思路会超时</span></span><br><span class="line">            <span class="comment">// if(nums[st] == 1) &#123;</span></span><br><span class="line">            <span class="comment">//     ++st;</span></span><br><span class="line">            <span class="comment">//     continue;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// int newSt = flipKBit(nums, k, st, preSum);</span></span><br><span class="line">            <span class="comment">// if(newSt == -1) &#123;</span></span><br><span class="line">            <span class="comment">//     st = st + k;</span></span><br><span class="line">            <span class="comment">// &#125; else &#123;</span></span><br><span class="line">            <span class="comment">//     st = newSt;</span></span><br><span class="line">            <span class="comment">//     res += 1;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if(find(nums.end() - k, nums.end(), 0) == (nums.end())) &#123;</span></span><br><span class="line">        <span class="comment">//     return res;</span></span><br><span class="line">        <span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(st &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 采用查分数组记录每个元素应该翻转的次数</span></span><br><span class="line">            <span class="comment">// 这启发我们用差分数组的思想来计算当前数字需要翻转的次数。我们可以维护一个差分数组 \textit&#123;diff&#125;diff，其中 \textit&#123;diff&#125;[i]diff[i] 表示两个相邻元素 </span></span><br><span class="line">            <span class="comment">// \textit&#123;nums&#125;[i-1]nums[i−1] 和 \textit&#123;nums&#125;[i]nums[i] 的翻转次数的差，对于区间 [l,r][l,r]，将其元素全部加 11，只会影响到 ll 和 r+1r+1 处的差分值，</span></span><br><span class="line">            <span class="comment">// 故 \textit&#123;diff&#125;[l]diff[l] 增加 11，\textit&#123;diff&#125;[r+1]diff[r+1] 减少 11。</span></span><br><span class="line">            flipCnt += diff[st];</span><br><span class="line">            <span class="keyword">if</span>((flipCnt + nums[st]) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(st + k &gt; n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                diff[st] ++;</span><br><span class="line">                diff[st + k] --;</span><br><span class="line">                res++;</span><br><span class="line">                flipCnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            ++st;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转kbit，返回第一个翻转窗口中反转后值不等于1的下标，否则返回-1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">flipKBit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> st, vector&lt;<span class="type">int</span>&gt;&amp; preSum)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> firstNot1 = INT_MAX;</span><br><span class="line">        <span class="comment">// 需要O(k)时间的复杂度</span></span><br><span class="line">        <span class="type">bool</span> needFlip = <span class="built_in">find</span>(nums.<span class="built_in">begin</span>() + st, nums.<span class="built_in">begin</span>() + st + k, <span class="number">0</span>) != (nums.<span class="built_in">begin</span>() + st + k);</span><br><span class="line">        <span class="comment">// 使用前缀和优化，由于实地翻转了数组，于是会改变对应的前缀和，所以此方法行不通</span></span><br><span class="line">        <span class="comment">// bool needFlip = ((preSum[st + k] - preSum[st]) != k);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i = st; i &lt; k; ++i) &#123;</span></span><br><span class="line">        <span class="comment">//     if(nums[st + i] != 1) &#123;</span></span><br><span class="line">        <span class="comment">//         needFlip = true;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">if</span>(needFlip) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                nums[st + i] = <span class="built_in">abs</span>(nums[st + i] - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(nums[st + i] != <span class="number">1</span>) &#123;</span><br><span class="line">                    firstNot1 = <span class="built_in">min</span>(firstNot1, st + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> firstNot1 &gt; nums.<span class="built_in">size</span>() ? st + k : firstNot1 ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1696-最大结果"><a href="#1696-最大结果" class="headerlink" title="1696 最大结果"></a>1696 最大结果</h2><h3 id="1-题目-4"><a href="#1-题目-4" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game-vi/submissions/">https://leetcode-cn.com/problems/jump-game-vi/submissions/</a></p>
<h3 id="2-解题思路-4"><a href="#2-解题思路-4" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 采用动态规划：dp[i]表示跳到i处的最大收益,如下：搜索i的前k个下标即可<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// o(n * k)解法</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>() + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">1</span>; m &lt; k + <span class="number">1</span> &amp;&amp; i - m &gt; <span class="number">0</span>; ++m) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i], dp[i-m] + nums[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>2 优化上述搜索前k个下标的方案，我们采用优先队列来维护前k个中最大的上一跳：<ul>
<li>将上述O(n*k)变为O(n*logk)，原因是maxHeap的push操作是logN的复杂度<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">number</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">number</span>(<span class="type">long</span> <span class="type">long</span> idx, <span class="type">long</span> <span class="type">long</span> val): <span class="built_in">idx</span>(idx), <span class="built_in">val</span>(val) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sort descending</span></span><br><span class="line">        <span class="type">bool</span>  <span class="keyword">operator</span>&lt;(<span class="type">const</span> number&amp; b) <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;val &lt; b.val;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxResult</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(nums.size() + <span class="number">1</span>, INT_MIN)</span></span>;</span><br><span class="line">        <span class="comment">// o(n * k)解法</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt; nums.size() + 1; ++i) &#123;</span></span><br><span class="line">        <span class="comment">//     for(int m = 1; m &lt; k + 1 &amp;&amp; i - m &gt; 0; ++m) &#123;</span></span><br><span class="line">        <span class="comment">//         dp[i] = max(dp[i], dp[i-m] + nums[i-1]);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        std::priority_queue&lt;number, std::vector&lt;number&gt;, std::less&lt;number&gt;&gt; maxHeap;</span><br><span class="line">        maxHeap.<span class="built_in">push</span>(&#123;<span class="number">1</span>, nums[<span class="number">0</span>]&#125;);</span><br><span class="line">        <span class="comment">// 使用堆优化：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>() + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(maxHeap.<span class="built_in">top</span>().idx &lt; i - k) &#123;</span><br><span class="line">                maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp[i] =  maxHeap.<span class="built_in">top</span>().val + nums[i - <span class="number">1</span>];</span><br><span class="line">            maxHeap.<span class="built_in">push</span>(&#123;i, dp[i]&#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// for(int m = 1; m &lt; k + 1 &amp;&amp; i - m &gt; 0; ++m) &#123;</span></span><br><span class="line">            <span class="comment">//     dp[i] = max(dp[i], dp[i-m] + nums[i-1]);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>滑动窗口的最大值：可以使用maxHeap来维护，复杂度logk</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2021/11/18/lcPrefixSum/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/18/lcPrefixSum/" class="post-title-link" itemprop="url">lcPrefixSum - 前缀和 1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-18 14:53:35" itemprop="dateCreated datePublished" datetime="2021-11-18T14:53:35+08:00">2021-11-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-前缀和"><a href="#1-前缀和" class="headerlink" title="1 前缀和"></a>1 前缀和</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; prefSum &#123;nums[<span class="number">0</span>]&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    prefSum[i] += (nums[i] + prefSum.<span class="built_in">back</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1546最大非重叠数组"><a href="#1546最大非重叠数组" class="headerlink" title="1546最大非重叠数组"></a>1546最大非重叠数组</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/submissions/">https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/submissions/</a></p>
<h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><p>最为关键的一句话：<br>每次找结束序号最小的和为target的子数组，然后从这个子数组的后面开始搜寻下一个子数组，经典贪心。</p>
<p>前缀和，普通为o(n^2)，使用hash优化：<br>subSum[j:i]，本来需要遍历所有的j找出为k的subarray，<br>但是换个思路：  其实就是找i之前，有多少个前缀和为 preSum[j] - k，<br>那么我们把前缀和用hash存一下，那不就能够很快找到了？</p>
<p>但是有一个问题，在下一次搜寻开始的时候，需要将上一次搜寻过程的hash清零，<br>否则上一次的hash的结果会影响当前子序和。<br>而且假设上一次搜寻到j了，那么这次从j+1开始搜寻，必须保证前缀和也是从j+1开始</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxNonOverlapping</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// vector&lt;int&gt; preSum(nums.size());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// preSum[0] = nums[0];</span></span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt; nums.size(); ++i )&#123;</span></span><br><span class="line">        <span class="comment">//     preSum[i] = preSum[i-1] + nums[i];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// while(ed &lt; nums.size()) &#123;</span></span><br><span class="line">        <span class="comment">//     for(int st = lastFoundEd; st &lt;= ed; ++st) &#123;</span></span><br><span class="line">        <span class="comment">//         if(preSum[ed] - preSum[st] + nums[st] == target) &#123;</span></span><br><span class="line">        <span class="comment">//             ++ans;</span></span><br><span class="line">        <span class="comment">//             lastFoundEd = ed+1;</span></span><br><span class="line">        <span class="comment">//             break;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     ++ed;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> st = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ed = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lastFoundEd = ed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// map&lt;int, int&gt; hash;</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(st &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ed = st;</span><br><span class="line">            <span class="comment">// hash.clear();   // clear history to avoid repeat count</span></span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt; hash = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="type">int</span> curSumFromLastFoundEd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(ed &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                curSumFromLastFoundEd += nums[ed];</span><br><span class="line">                <span class="keyword">if</span>(hash.<span class="built_in">count</span>(curSumFromLastFoundEd - target)) &#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    st = ed;        <span class="comment">// new search start</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    hash.<span class="built_in">insert</span>(curSumFromLastFoundEd);</span><br><span class="line">                &#125;</span><br><span class="line">                ++ed;</span><br><span class="line">            &#125;</span><br><span class="line">            ++st;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0560subArraySum-子数组和为k"><a href="#0560subArraySum-子数组和为k" class="headerlink" title="0560subArraySum 子数组和为k"></a>0560subArraySum 子数组和为k</h2><h3 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">https://leetcode-cn.com/problems/subarray-sum-equals-k/</a></p>
<h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><p>前缀和，普通为o(n^2)，使用hash优化：<br>subSum[j:i]，本来需要遍历所有的j找出为k的subarray，<br>但是换个思路：  其实就是找i之前，有多少个前缀和为 preSum[j] - k，<br>那么我们把前缀和用hash存一下，那不就能够很快找到了？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefSum</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        prefSum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            prefSum[i] += (nums[i] + prefSum[i<span class="number">-1</span>]); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> st = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ed = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        hash[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(ed &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">find</span>(prefSum[ed] - k) != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans += hash[prefSum[ed] - k];</span><br><span class="line">            &#125; </span><br><span class="line">            hash[prefSum[ed]]++;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// for(int st = ed; st &gt;= 0; --st) &#123;</span></span><br><span class="line">            <span class="comment">//     curSum = prefSum[ed] - prefSum[st] + nums[st];</span></span><br><span class="line">            <span class="comment">//     if(curSum == k)&#123;</span></span><br><span class="line">            <span class="comment">//         ++ans;</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            ++ed;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1171移除和为0的子链表"><a href="#1171移除和为0的子链表" class="headerlink" title="1171移除和为0的子链表"></a>1171移除和为0的子链表</h2><h3 id="1-题目："><a href="#1-题目：" class="headerlink" title="1 题目："></a>1 题目：</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/">https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/</a></p>
<h3 id="2-解题思路："><a href="#2-解题思路：" class="headerlink" title="2 解题思路："></a>2 解题思路：</h3><p>个人暴力思路：</p>
<ul>
<li>1 每次移除一个和为0的子数组，返回一个新的链表</li>
<li>2 重复上述过程直到没有和为0的子数组</li>
</ul>
<p>前缀和思路参考：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/solution/c-jian-ji-dai-si-lu-by-philhsu/">采用前缀和判断和为0方法</a>：<br>我们可以考虑如果给的入参不是链表是数组的话，只需要求出前缀和，对于前缀和相同的项，那他们中间的部分即是可以消除掉的，比如以 [1, 2, 3, -3, 4] 为例，其前缀和数组为 [1, 3, 6, 3, 7] ，我们发现有两项均为 3，则 6 和 第二个 3 所对应的原数组中的数字是可以消掉的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* newHead;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">removeZeroSumSublists</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        newHead = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">removeOneZeroSubList</span>(newHead))&#123; &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">removeOneZeroSubList</span><span class="params">(ListNode* newHead)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; valVec;</span><br><span class="line">        ListNode* head = newHead;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            valVec.<span class="built_in">emplace_back</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">size_t</span> len = valVec.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sumMat</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cal all the sub len</span></span><br><span class="line">        <span class="comment">// sumMat[a, b] = sumMat[a, b-1] + a</span></span><br><span class="line">        ListNode* stPtr = head;</span><br><span class="line">        ListNode* lastStPtr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> st = <span class="number">0</span>; st &lt; len; ++st) &#123;</span><br><span class="line">            sumMat[st][st] = valVec[st];</span><br><span class="line">            <span class="keyword">if</span>(sumMat[st][st] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">nullptr</span> == lastStPtr) &#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;newHead = head-&gt;next;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                lastStPtr-&gt;next = stPtr-&gt;next;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* edPtr = stPtr-&gt;next;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> ed = st + <span class="number">1</span>; ed &lt; len; ++ed) &#123;</span><br><span class="line">                sumMat[st][ed] = sumMat[st][ed<span class="number">-1</span>] + valVec[ed];</span><br><span class="line">                <span class="keyword">if</span>(sumMat[st][ed] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="literal">nullptr</span> == lastStPtr) &#123;</span><br><span class="line">                        <span class="keyword">this</span>-&gt;newHead = edPtr-&gt;next;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    lastStPtr-&gt;next = edPtr-&gt;next;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                edPtr = edPtr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            lastStPtr = stPtr;</span><br><span class="line">            stPtr = stPtr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1292最大方块长度"><a href="#1292最大方块长度" class="headerlink" title="1292最大方块长度"></a>1292最大方块长度</h2><h3 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/">https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/</a></p>
<h3 id="2-解题思路-2"><a href="#2-解题思路-2" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><ul>
<li>1 建立二维前缀和： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">preSum</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">        preSum[i][j] = preSum[i<span class="number">-1</span>][j] + preSum[i][j<span class="number">-1</span>] - preSum[i<span class="number">-1</span>][j<span class="number">-1</span>] + mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>2 遍历所有边长的正方形即可(每个正放形为起点加上边长)，遍历长度的过程可以通过二分搜索加速</li>
</ul>
<p>值得思考的点：<br>如何快速得知当前位置是不是被阻挡了？<br>使用unordered_set作为hash快速查找</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSideLength</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// mat.row &gt;= m &gt; i &gt;= 0, mat.col &gt;= n &gt; j &gt;= 0</span></span><br><span class="line">        <span class="comment">// preSum[m][n] -&gt; preSum[i][j] = preSum[m][n] - preSum[m][j] - preSum[i][n] + preSum[i][j];</span></span><br><span class="line">        <span class="type">int</span> m = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">preSum</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">                preSum[i][j] = preSum[i<span class="number">-1</span>][j] + preSum[i][j<span class="number">-1</span>] - preSum[i<span class="number">-1</span>][j<span class="number">-1</span>] + mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// traverse all square</span></span><br><span class="line">        <span class="type">int</span> maxSquareLen = std::<span class="built_in">min</span>(m, n);</span><br><span class="line">    <span class="comment">//    for(int len = maxSquareLen; len &gt;= 1; --len) &#123; // len could be binary search</span></span><br><span class="line">    <span class="comment">//         for(int i = 0; i &lt;= m - len; ++i) &#123;</span></span><br><span class="line">    <span class="comment">//             for(int j = 0; j &lt;= n - len; ++j) &#123;</span></span><br><span class="line">    <span class="comment">//                 if(getRec(preSum, i+1, j+1, i + len, j + len) &lt;= threshold) &#123;</span></span><br><span class="line">    <span class="comment">//                     return len;</span></span><br><span class="line">    <span class="comment">//                 &#125;;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="type">int</span> stLen = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> edLen = maxSquareLen;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(stLen &lt;= edLen) &#123;</span><br><span class="line">            <span class="type">int</span> len = (stLen + edLen) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m - len; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n - len; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">getRec</span>(preSum, i+<span class="number">1</span>, j+<span class="number">1</span>, i + len, j + len) &lt;= threshold) &#123;</span><br><span class="line">                        found = <span class="literal">true</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span>(found) &#123; <span class="comment">// len too small</span></span><br><span class="line">                stLen = len+<span class="number">1</span>;</span><br><span class="line">                ans = len;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// len too big</span></span><br><span class="line">                edLen = len<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRec</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; preSum, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preSum[m][n] - preSum[m][j<span class="number">-1</span>] - preSum[i<span class="number">-1</span>][n] + preSum[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1124-良好表现的最长时间段"><a href="#1124-良好表现的最长时间段" class="headerlink" title="1124 良好表现的最长时间段"></a>1124 良好表现的最长时间段</h2><h3 id="1-题目-3"><a href="#1-题目-3" class="headerlink" title="1 题目"></a>1 题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-well-performing-interval/">https://leetcode-cn.com/problems/longest-well-performing-interval/</a></p>
<h3 id="2-解题思路-3"><a href="#2-解题思路-3" class="headerlink" title="2 解题思路"></a>2 解题思路</h3><p>较为容易想到前缀和思路：<br>不好想的地方在于第1和3条，思路如下：</p>
<ul>
<li>1 对于这种良好费良好的判断，我们需要把数组转换成 -1, 1的数组</li>
<li>2 对上述数组作前缀和</li>
<li>3 那么对于每个到来的j，只需要找到最小的i，满足 preSum[j] - preSum[i] == 1即可<ul>
<li>3.1 如何理解最小的i，也就是说，对于同一个preSum值的下标，我们总是去最小的i即可</li>
<li>3.2 对于 9 9 9 9 9这种全正常的思路，如何判断？ 前缀和的值本身就可以判断，大于零的下标都可以是良好工作区间</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestWPI</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; hours)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; preSum = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; hours.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            preSum.<span class="built_in">emplace_back</span>((hours[i] &gt; <span class="number">8</span> ? <span class="number">1</span> : <span class="number">-1</span>) + preSum.<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="type">int</span> st = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ed = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = INT_MIN;</span><br><span class="line">        <span class="comment">// key: presum&#x27;s value, value: presum&#x27;s index</span></span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        m[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lastPop = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; mono = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(; ed &lt; hours.<span class="built_in">size</span>(); ++ed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (preSum[ed + <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res = std::<span class="built_in">max</span>(res, ed + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">find</span>(preSum[ed + <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                res = std::<span class="built_in">max</span>(ed - it-&gt;second, res);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">find</span>(preSum[ed + <span class="number">1</span>]) == m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                m[preSum[ed + <span class="number">1</span>]] = ed; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res &lt; <span class="number">0</span> ? <span class="number">0</span> : res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xychen5</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
