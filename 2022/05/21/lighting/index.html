<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=victor+mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"xychen5.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12,"width":300},"copycode":false,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"changyan":{"text":"Load Disqus","order":-2},"gitalk":{"order":-1}}},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"zoomIn","post_header":"zoomIn","post_body":"zoomIn","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

  <meta name="description" content="1 phon的光照和blinn-phon的光照直接看这个shader： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#version 330 coreout vec4 FragColor;in VS_OUT &amp;#123;    vec3 FragPos;    vec3 Nor">
<meta property="og:type" content="article">
<meta property="og:title" content="lighting - 一些光照模型以及高级光照">
<meta property="og:url" content="https://xychen5.github.io/2022/05/21/lighting/index.html">
<meta property="og:site_name" content="LuftBallon">
<meta property="og:description" content="1 phon的光照和blinn-phon的光照直接看这个shader： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#version 330 coreout vec4 FragColor;in VS_OUT &amp;#123;    vec3 FragPos;    vec3 Nor">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-05-21T07:00:29.000Z">
<meta property="article:modified_time" content="2023-08-03T11:50:26.485Z">
<meta property="article:author" content="xychen5">
<meta property="article:tag" content="render">
<meta property="article:tag" content="gl">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://xychen5.github.io/2022/05/21/lighting/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://xychen5.github.io/2022/05/21/lighting/","path":"2022/05/21/lighting/","title":"lighting - 一些光照模型以及高级光照"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>lighting - 一些光照模型以及高级光照 | LuftBallon</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">LuftBallon</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-arrow-right fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-phon%E7%9A%84%E5%85%89%E7%85%A7%E5%92%8Cblinn-phon%E7%9A%84%E5%85%89%E7%85%A7"><span class="nav-number">1.</span> <span class="nav-text">1 phon的光照和blinn-phon的光照</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-gamma%E7%9F%AB%E6%AD%A3"><span class="nav-number">2.</span> <span class="nav-text">2 gamma矫正</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84-%E5%AE%9A%E5%90%91%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE%E6%8A%80%E6%9C%AF-%E5%9F%BA%E4%BA%8E%E5%85%89%E7%85%A7%E7%A9%BA%E9%97%B4%E7%9A%84%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2%E5%92%8C%E6%AD%A3%E5%B8%B8%E6%B8%B2%E6%9F%93%E7%A9%BA%E9%97%B4%E7%9A%84%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2%E5%81%9A%E6%AF%94%E8%BE%83%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C"><span class="nav-number">3.</span> <span class="nav-text">3 阴影映射(定向阴影贴图技术)(基于光照空间的深度缓冲和正常渲染空间的深度缓冲做比较来实现阴影效果)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%82%B9%E5%85%89%E6%BA%90%E9%98%B4%E5%BD%B1-%E4%B8%87%E5%90%91%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE%EF%BC%88omnidirectional-shadow-maps%EF%BC%89%E6%8A%80%E6%9C%AF"><span class="nav-number">4.</span> <span class="nav-text">4 点光源阴影(万向阴影贴图（omnidirectional shadow maps）技术)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE%EF%BC%88%E6%A8%A1%E6%8B%9F%E5%85%89%E7%85%A7%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">5 法线贴图（模拟光照）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE%EF%BC%88%E6%A8%A1%E6%8B%9F%E6%B7%B1%E5%BA%A6%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">6 视差贴图（模拟深度）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%A1%E5%B3%AD%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE%EF%BC%88viewDircection%E5%A4%9A%E6%AC%A1%E9%87%87%E6%A0%B7%EF%BC%8C%E5%BE%97%E5%88%B0%E6%9B%B4%E7%B2%BE%E7%A1%AE%E7%9A%84%E8%A7%86%E5%B7%AE%EF%BC%89"><span class="nav-number">6.1.</span> <span class="nav-text">陡峭视差贴图（viewDircection多次采样，得到更精确的视差）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%B7%AE%E9%81%AE%E8%94%BD%E6%98%A0%E5%B0%84"><span class="nav-number">6.2.</span> <span class="nav-text">视差遮蔽映射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-HDR%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4"><span class="nav-number">7.</span> <span class="nav-text">7 HDR高动态范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E6%B3%9B%E5%85%89"><span class="nav-number">8.</span> <span class="nav-text">8 泛光</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E5%BB%B6%E8%BF%9F%E7%9D%80%E8%89%B2%E6%B3%95"><span class="nav-number">9.</span> <span class="nav-text">9 延迟着色法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-SSAO-sscreen-space-ambient-occlusion-%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%8E%AF%E5%A2%83%E5%85%89%E9%81%AE%E8%94%BD"><span class="nav-number">10.</span> <span class="nav-text">10 SSAO(sscreen-space ambient occlusion)屏幕空间环境光遮蔽</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="xychen5"
      src="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
  <p class="site-author-name" itemprop="name">xychen5</p>
  <div class="site-description" itemprop="description">Freiheit Weht</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">69</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/xychen5?tab=repositories" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xychen5?tab&#x3D;repositories" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cxynash5@gmail.com" title="E-Mail → mailto:cxynash5@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xychen5.github.io/2022/05/21/lighting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.jsdelivr.net/gh/xychen5/blogImgs@main/imgs/index3(复件).1h2t3p2cfiow.jpg">
      <meta itemprop="name" content="xychen5">
      <meta itemprop="description" content="Freiheit Weht">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuftBallon">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          lighting - 一些光照模型以及高级光照
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-21 15:00:29" itemprop="dateCreated datePublished" datetime="2022-05-21T15:00:29+08:00">2022-05-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-03 19:50:26" itemprop="dateModified" datetime="2023-08-03T19:50:26+08:00">2023-08-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="1-phon的光照和blinn-phon的光照"><a href="#1-phon的光照和blinn-phon的光照" class="headerlink" title="1 phon的光照和blinn-phon的光照"></a>1 phon的光照和blinn-phon的光照</h2><p>直接看这个shader：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D floorTexture;</span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line">uniform <span class="type">bool</span> blinn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    vec3 color = <span class="built_in">texture</span>(floorTexture, fs_in.TexCoords).rgb;</span><br><span class="line">    <span class="comment">// ambient</span></span><br><span class="line">    vec3 ambient = <span class="number">0.05</span> * color;</span><br><span class="line">    <span class="comment">// diffuse</span></span><br><span class="line">    vec3 lightDir = <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    vec3 normal = <span class="built_in">normalize</span>(fs_in.Normal);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = diff * color;</span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    vec3 viewDir = <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);</span><br><span class="line">    vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(blinn)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 然而blinn光照，就考虑了大于90度的问题，</span></span><br><span class="line">        <span class="comment">// 将theta角度定义为了视线和光线的中间向量，然后和表面法向的夹角</span></span><br><span class="line">        vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">        spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">32.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// phong的光照里，有这个反射光线和视线的点乘，代表了反射光线和眼睛看向反光点的视线夹角有多小，</span></span><br><span class="line">        <span class="comment">// 越小漫反射效果就越好，cos(theta)嘛！</span></span><br><span class="line">        <span class="comment">// theta很容易想到会大于90度，那么漫反射就失效了</span></span><br><span class="line">        vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">        spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">8.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 specular = <span class="built_in">vec3</span>(<span class="number">0.3</span>) * spec; <span class="comment">// assuming bright white light color</span></span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-gamma矫正"><a href="#2-gamma矫正" class="headerlink" title="2 gamma矫正"></a>2 gamma矫正</h2><p>一句话理解他： 物理显示器显示（线性空间）的颜色亮度为0.5，人看到的亮度会为0.5^2.2，也就是更暗了，于是需要先做1/2.2次幂的拔高</p>
<blockquote>
<p>Gamma校正(Gamma Correction)的思路是在最终的颜色输出上应用监视器Gamma的倒数。回头看前面的Gamma曲线图，你会有一个短划线，它是监视器Gamma曲线的翻转曲线。我们在颜色显示到监视器的时候把每个颜色输出都加上这个翻转的Gamma曲线，这样应用了监视器Gamma以后最终的颜色将会变为线性的。我们所得到的中间色调就会更亮，所以虽然监视器使它们变暗，但是我们又将其平衡回来了。<br>我们来看另一个例子。还是那个暗红色(0.5,0.0,0.0)。在将颜色显示到监视器之前，我们先对颜色应用Gamma校正曲线。线性的颜色显示在监视器上相当于降低了2.2次幂的亮度，所以倒数就是1/2.2次幂。Gamma校正后的暗红色就会成为(0.5,0.0,0.0)1/2.2=(0.5,0.0,0.0)0.45=(0.73,0.0,0.0)。校正后的颜色接着被发送给监视器，最终显示出来的颜色是(0.73,0.0,0.0)2.2=(0.5,0.0,0.0)。你会发现使用了Gamma校正，监视器最终会显示出我们在应用中设置的那种线性的颜色<br>总而言之，gamma校正使你可以在线性空间中进行操作。因为线性空间更符合物理世界，大多数物理公式现在都可以获得较好效果，比如真实的光的衰减。你的光照越真实，使用gamma校正获得漂亮的效果就越容易。这也正是为什么当引进gamma校正时，建议只去调整光照参数的原因。</p>
</blockquote>
<p>在使用了gamma校正之后，另一个不同之处是光照衰减(Attenuation)。真实的物理世界中，光照的衰减和光源的距离的平方成反比。但是由于本身有gamma矫正，所以我们就用双曲线函数衰减就行了，因为最后会乘以2.2次幂！约等于距离平方反比</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D floorTexture;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPositions[<span class="number">4</span>];</span><br><span class="line">uniform vec3 lightColors[<span class="number">4</span>];</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line">uniform <span class="type">bool</span> gamma;</span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">BlinnPhong</span><span class="params">(vec3 normal, vec3 fragPos, vec3 lightPos, vec3 lightColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// diffuse</span></span><br><span class="line">    vec3 lightDir = <span class="built_in">normalize</span>(lightPos - fragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = diff * lightColor;</span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    vec3 viewDir = <span class="built_in">normalize</span>(viewPos - fragPos);</span><br><span class="line">    vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">    spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">64.0</span>);</span><br><span class="line">    vec3 specular = spec * lightColor;    </span><br><span class="line">    <span class="comment">// simple attenuation</span></span><br><span class="line">    <span class="type">float</span> max_distance = <span class="number">1.5</span>;</span><br><span class="line">    <span class="type">float</span> distance = <span class="built_in">length</span>(lightPos - fragPos);</span><br><span class="line">    <span class="comment">// gamma开了就是双曲线衰减，然后由于线性到视觉，有个2.2次幂，相当于是2次幂的距离衰减</span></span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (gamma ? distance * distance : distance);</span><br><span class="line">    </span><br><span class="line">    diffuse *= attenuation;</span><br><span class="line">    specular *= attenuation;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> diffuse + specular;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    vec3 color = <span class="built_in">texture</span>(floorTexture, fs_in.TexCoords).rgb;</span><br><span class="line">    vec3 lighting = <span class="built_in">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        lighting += <span class="built_in">BlinnPhong</span>(<span class="built_in">normalize</span>(fs_in.Normal), fs_in.FragPos, lightPositions[i], lightColors[i]);</span><br><span class="line">    color *= lighting;</span><br><span class="line">    <span class="keyword">if</span>(gamma) <span class="comment">// 手动gamma矫正，之前调用一个ogl的函数将纹理变为线性空间的纹理</span></span><br><span class="line">        color = <span class="built_in">pow</span>(color, <span class="built_in">vec3</span>(<span class="number">1.0</span>/<span class="number">2.2</span>));</span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-阴影映射-定向阴影贴图技术-基于光照空间的深度缓冲和正常渲染空间的深度缓冲做比较来实现阴影效果"><a href="#3-阴影映射-定向阴影贴图技术-基于光照空间的深度缓冲和正常渲染空间的深度缓冲做比较来实现阴影效果" class="headerlink" title="3 阴影映射(定向阴影贴图技术)(基于光照空间的深度缓冲和正常渲染空间的深度缓冲做比较来实现阴影效果)"></a>3 阴影映射(定向阴影贴图技术)(基于光照空间的深度缓冲和正常渲染空间的深度缓冲做比较来实现阴影效果)</h2><p>一句话理解：对于场景的每个顶点转换到光源为中心的坐标系里，然后渲染场景得到的z值就是光源能看到它的深度，然后借用原本渲染场景时，会有一个深度值z‘，比较这两个值，就知道在这个像素是否能够直面光源</p>
<ul>
<li>效果不错，但它只适合定向光，因为阴影只是在单一定向光源下生成的。它也叫定向阴影映射，深度（阴影）贴图生成自定向光的视角。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 首选渲染深度贴图</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>(); <span class="comment">// 将目标的深度信息存在这个depthMapFBO里面</span></span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2. 绘制深度贴图，将深度可视化的意思</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <span class="comment">// clear掉之前为了得到深度缓冲的物体</span></span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, depthMap);</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br><span class="line"><span class="comment">// ------------------------------------利用光照空间生成光照里面的深度缓存对应的vs</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line">uniform mat4 lightSpaceMatrix;</span><br><span class="line">uniform mat4 model;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = lightSpaceMatrix * model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后利用这个光照空间深度buffer，得到阴影是否该渲染，直接看shader：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec3 Normal;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec4 FragPosLightSpace;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D diffuseTexture;</span><br><span class="line">uniform sampler2D shadowMap;</span><br><span class="line"></span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ShadowCalculation</span><span class="params">(vec4 fragPosLightSpace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// perform perspective divide</span></span><br><span class="line">    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    <span class="comment">// transform to [0,1] range</span></span><br><span class="line">    projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// get closest depth value from light&#x27;s perspective (using [0,1] range fragPosLight as coords)</span></span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy).r; </span><br><span class="line">    <span class="comment">// get depth of current fragment from light&#x27;s perspective</span></span><br><span class="line">    <span class="type">float</span> currentDepth = projCoords.z;</span><br><span class="line">    <span class="comment">// calculate bias (based on depth map resolution and slope)</span></span><br><span class="line">    vec3 normal = <span class="built_in">normalize</span>(fs_in.Normal);</span><br><span class="line">    vec3 lightDir = <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    <span class="comment">// 解决阴影失真问题，由于可能出现多个个pixel对应同一个深度texel，然后深度texel是呈现一个角度照射地面的</span></span><br><span class="line">    <span class="comment">// 那么有一些pixel上的texel比地面小，有一些就比地面深度值大，解决办法就是当渲染深度和texel深度的误差很小</span></span><br><span class="line">    <span class="comment">// 我们将其认为是无阴影，然后渲染即可</span></span><br><span class="line">    <span class="type">float</span> bias = <span class="built_in">max</span>(<span class="number">0.05</span> * (<span class="number">1.0</span> - <span class="built_in">dot</span>(normal, lightDir)), <span class="number">0.005</span>);</span><br><span class="line">    <span class="comment">// if(abs(currentDepth - closestDepth) &lt;= offset) &#123;</span></span><br><span class="line">    <span class="comment">//     shadow = 0;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// check whether current frag pos is in shadow</span></span><br><span class="line">    <span class="comment">// float shadow = currentDepth - bias &gt; closestDepth  ? 1.0 : 0.0;</span></span><br><span class="line">    <span class="comment">// PCF</span></span><br><span class="line">    <span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line">    vec2 texelSize = <span class="number">1.0</span> / <span class="built_in">textureSize</span>(shadowMap, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">-1</span>; x &lt;= <span class="number">1</span>; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">-1</span>; y &lt;= <span class="number">1</span>; ++y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 因为深度贴图有一个固定的分辨率，多个片段对应于一个纹理像素。</span></span><br><span class="line">            <span class="comment">// 结果就是多个片段会从深度贴图的同一个深度值进行采样，这几个片段便得到的是同一个阴影，这就会产生锯齿边。</span></span><br><span class="line">            <span class="comment">// 导致锯齿严重</span></span><br><span class="line">            <span class="type">float</span> pcfDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy + <span class="built_in">vec2</span>(x, y) * texelSize).r; </span><br><span class="line">            shadow += currentDepth - bias &gt; pcfDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    shadow /= <span class="number">9.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// keep the shadow at 0.0 when outside the far_plane region of the light&#x27;s frustum.</span></span><br><span class="line">    <span class="keyword">if</span>(projCoords.z &gt; <span class="number">1.0</span>)</span><br><span class="line">        shadow = <span class="number">0.0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    vec3 color = <span class="built_in">texture</span>(diffuseTexture, fs_in.TexCoords).rgb;</span><br><span class="line">    vec3 normal = <span class="built_in">normalize</span>(fs_in.Normal);</span><br><span class="line">    vec3 lightColor = <span class="built_in">vec3</span>(<span class="number">0.3</span>);</span><br><span class="line">    <span class="comment">// ambient</span></span><br><span class="line">    vec3 ambient = <span class="number">0.3</span> * lightColor;</span><br><span class="line">    <span class="comment">// diffuse</span></span><br><span class="line">    vec3 lightDir = <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = diff * lightColor;</span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    vec3 viewDir = <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);</span><br><span class="line">    vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">    spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">64.0</span>);</span><br><span class="line">    vec3 specular = spec * lightColor;    </span><br><span class="line">    <span class="comment">// calculate shadow</span></span><br><span class="line">    <span class="type">float</span> shadow = <span class="built_in">ShadowCalculation</span>(fs_in.FragPosLightSpace);                      </span><br><span class="line">    vec3 lighting = (ambient + (<span class="number">1.0</span> - shadow) * (diffuse + specular)) * color;    </span><br><span class="line">    </span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(lighting, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-点光源阴影-万向阴影贴图（omnidirectional-shadow-maps）技术"><a href="#4-点光源阴影-万向阴影贴图（omnidirectional-shadow-maps）技术" class="headerlink" title="4 点光源阴影(万向阴影贴图（omnidirectional shadow maps）技术)"></a>4 点光源阴影(万向阴影贴图（omnidirectional shadow maps）技术)</h2><p>算法本身：我们从光的透视图生成一个深度贴图，基于当前fragment位置来对深度贴图采样，然后用储存的深度值和每个fragment进行对比，看看它是否在阴影中。定向阴影映射和万向阴影映射的主要不同在于深度贴图的使用上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">万向阴影贴图有两个渲染阶段：首先我们生成深度贴图，然后我们正常使用深度贴图渲染，在场景中创建阴影。帧缓冲对象和立方体贴图的处理看起是这样的：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. first render to depth cubemap</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2. then render scene as normal with shadow mapping (using depth cubemap)</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, depthCubemap);</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br></pre></td></tr></table></figure>
<p>由于万向阴影贴图基于传统阴影映射的原则，它便也继承了由解析度产生的非真实感。如果你放大就会看到锯齿边了。PCF或称Percentage-closer filtering允许我们通过对fragment位置周围过滤多个样本，并对结果平均化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> bias = <span class="number">0.05</span>; </span><br><span class="line"><span class="type">float</span> samples = <span class="number">4.0</span>;</span><br><span class="line"><span class="type">float</span> offset = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">float</span> x = -offset; x &lt; offset; x += offset / (samples * <span class="number">0.5</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">float</span> y = -offset; y &lt; offset; y += offset / (samples * <span class="number">0.5</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">float</span> z = -offset; z &lt; offset; z += offset / (samples * <span class="number">0.5</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight + <span class="built_in">vec3</span>(x, y, z)).r; </span><br><span class="line">            closestDepth *= far_plane;   <span class="comment">// Undo mapping [0;1]</span></span><br><span class="line">            <span class="keyword">if</span>(currentDepth - bias &gt; closestDepth)</span><br><span class="line">                shadow += <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">shadow /= (samples * samples * samples);</span><br><span class="line"><span class="comment">// 然而，samples设置为4.0，每个fragment我们会得到总共64个样本，这太多了！大多数这些采样都是多余的，与其在原始方向向量附近处采样，不如在采样方向向量的垂直方向进行采样更有意义。可是，没有（简单的）方式能够指出哪一个子方向是多余的，这就难了。有个技巧可以使用，用一个偏移量方向数组，它们差不多都是分开的，每一个指向完全不同的方向，剔除彼此接近的那些子方向。下面就是一个有着20个偏移方向的数组：</span></span><br><span class="line">vec3 sampleOffsetDirections[<span class="number">20</span>] = vec3[]</span><br><span class="line">(</span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>( <span class="number">1</span>, <span class="number">-1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">-1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">1</span>,  <span class="number">1</span>), </span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">1</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>( <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">1</span>, <span class="number">-1</span>),</span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">0</span>), <span class="built_in">vec3</span>( <span class="number">1</span>, <span class="number">-1</span>,  <span class="number">0</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">-1</span>,  <span class="number">0</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">1</span>,  <span class="number">0</span>),</span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">0</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>( <span class="number">1</span>,  <span class="number">0</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>(<span class="number">-1</span>,  <span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">   <span class="built_in">vec3</span>( <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>( <span class="number">0</span>, <span class="number">-1</span>,  <span class="number">1</span>), <span class="built_in">vec3</span>( <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>), <span class="built_in">vec3</span>( <span class="number">0</span>,  <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 然后我们把PCF算法与从sampleOffsetDirections得到的样本数量进行适配，使用它们从立方体贴图里采样。这么做的好处是与之前的PCF算法相比，我们需要的样本数量变少了。</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> bias = <span class="number">0.15</span>;</span><br><span class="line"><span class="type">int</span> samples = <span class="number">20</span>;</span><br><span class="line"><span class="type">float</span> viewDistance = <span class="built_in">length</span>(viewPos - fragPos);</span><br><span class="line"><span class="type">float</span> diskRadius = <span class="number">0.05</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; samples; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight + sampleOffsetDirections[i] * diskRadius).r;</span><br><span class="line">    closestDepth *= far_plane;   <span class="comment">// Undo mapping [0;1]</span></span><br><span class="line">    <span class="keyword">if</span>(currentDepth - bias &gt; closestDepth)</span><br><span class="line">        shadow += <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">shadow /= <span class="built_in">float</span>(samples);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个在这里可以应用的有意思的技巧是，我们可以基于观察者里一个fragment的距离来改变diskRadius；这样我们就能根据观察者的距离来增加偏移半径了，当距离更远的时候阴影更柔和，更近了就更锐利。</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> diskRadius = (<span class="number">1.0</span> + (viewDistance / far_plane)) / <span class="number">25.0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="5-法线贴图（模拟光照）"><a href="#5-法线贴图（模拟光照）" class="headerlink" title="5 法线贴图（模拟光照）"></a>5 法线贴图（模拟光照）</h2><p>一句话：为每个fragment生成一个法向，更真实地模拟光照<br>考虑一个问题，当光照在z轴，然后墙面法向也是z轴，那么法线贴图的每个法线都指向z轴，者能够正常工作，但是当墙面指向正y方向，法向应该能随着墙面旋转而旋转，然后我们没有改动法向，那么就会产生错误的光照！<br>一个稍微有点难的解决方案是，在一个不同的坐标空间中进行光照，这个坐标空间里，法线贴图向量总是指向这个坐标空间的正z方向；所有的光照向量都相对与这个正z方向进行变换。这样我们就能始终使用同样的法线贴图，不管朝向问题。这个坐标空间叫做切线空间（tangent space）。<br>方法就是，纹理的相邻两边叉乘得到法向量得到TBN矩阵（切线、副切线、法向），有两种方式使用：</p>
<ul>
<li>1 法线坐标左乘上TBN矩阵，转换到世界坐标空间中，这样所有法线和其他光照变量就在同一个坐标系中了。(在着色器里传入这个向量即可，然后对于着色器里的法向向量乘以TBN矩阵)</li>
<li>2 TBN矩阵的逆矩阵，这个矩阵可以把世界坐标空间的向量转换到切线坐标空间。因此我们使用这个矩阵左乘其他光照变量，把他们转换到切线空间，这样法线和其他光照变量再一次在一个坐标系中了。（正交矩阵（每个轴既是单位向量同时相互垂直）的一大属性是一个正交矩阵的置换矩阵与它的逆矩阵相等。所有我们对正交矩阵求逆一般都是直接transpose，而不是inverse）<blockquote>
<p>第二种方法看似要做的更多，它还需要在像素着色器中进行更多的乘法操作，所以为何还用第二种方法呢？(将lightpos viewpos等等都在顶点着色器就转换到了切线空间，避免了在像素着色器阶段做这件事)<br>将向量从世界空间转换到切线空间有个额外好处，我们可以把所有相关向量在顶点着色器中转换到切线空间，不用在像素着色器中做这件事。这是可行的，因为lightPos和viewPos不是每个fragment运行都要改变，对于fs_in.FragPos，我们也可以在顶点着色器计算它的切线空间位置。基本上，不需要把任何向量在像素着色器中进行变换，而第一种方法中就是必须的，因为采样出来的法线向量对于每个像素着色器都不一样。<br>所以现在不是把TBN矩阵的逆矩阵发送给像素着色器，而是将切线空间的光源位置，观察位置以及顶点位置发送给像素着色器。这样我们就不用在像素着色器里进行矩阵乘法了。这是一个极佳的优化，因为顶点着色器通常比像素着色器运行的少。这也是为什么这种方法是一种更好的实现方式的原因。</p>
</blockquote>
</li>
</ul>
<p>使用法线贴图的优势</p>
<ul>
<li>1 更漂亮</li>
<li>2 保持细节，高精度网格和使用法线贴图的低精度网格几乎区分不出来。所以法线贴图不仅看起来漂亮，它也是一个将高精度多边形转换为低精度多边形而不失细节的重要工具。</li>
</ul>
<p>对于网格渲染，共享顶点的TBN法向会被平均用于平滑效果，这样做有个问题，就是TBN向量可能会不能互相垂直，这意味着TBN矩阵不再是正交矩阵了。法线贴图可能会稍稍偏移，但这仍然可以改进。使用叫做格拉姆-施密特正交化过程（Gram-Schmidt process）的数学技巧，我们可以对TBN向量进行重正交化，这样每个向量就又会重新垂直了。在顶点着色器中我们这样做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vec3 T = <span class="built_in">normalize</span>(<span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(tangent, <span class="number">0.0</span>)));</span><br><span class="line">vec3 N = <span class="built_in">normalize</span>(<span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(normal, <span class="number">0.0</span>)));</span><br><span class="line"><span class="comment">// re-orthogonalize T with respect to N</span></span><br><span class="line">T = <span class="built_in">normalize</span>(T - <span class="built_in">dot</span>(T, N) * N);</span><br><span class="line"><span class="comment">// then retrieve perpendicular vector B with the cross product of T and N</span></span><br><span class="line">vec3 B = <span class="built_in">cross</span>(T, N);</span><br><span class="line"></span><br><span class="line">mat3 TBN = <span class="built_in">mat3</span>(T, B, N)</span><br></pre></td></tr></table></figure>

<h2 id="6-视差贴图（模拟深度）"><a href="#6-视差贴图（模拟深度）" class="headerlink" title="6 视差贴图（模拟深度）"></a>6 视差贴图（模拟深度）</h2><p>一句话：视差贴图背后的思想是修改纹理坐标使一个fragment的表面看起来比实际的更高或者更低，所有这些都根据观察方向和高度贴图。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec2 <span class="title">ParallaxMapping</span><span class="params">(vec2 texCoords, vec3 viewDir)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">float</span> height =  <span class="built_in">texture</span>(depthMap, texCoords).r;    </span><br><span class="line">    vec2 p = viewDir.xy / viewDir.z * (height * height_scale); <span class="comment">// 考虑这个p，这个p就是假设一开始的坐标是texCoords，对吧？然后我们有viewDirection看向texCoords的位置，然后我们取这个方向乘以这个点的理应高度（也就是想要渲染出来的高度），得到texCoords应该做的偏移以达到效果</span></span><br><span class="line">    <span class="comment">// 上面除以z，是因为viewDir已经单位化了，所以会适当放大p，得到更大的偏移效果，这个看个人喜好了</span></span><br><span class="line">    <span class="keyword">return</span> texCoords - p;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="陡峭视差贴图（viewDircection多次采样，得到更精确的视差）"><a href="#陡峭视差贴图（viewDircection多次采样，得到更精确的视差）" class="headerlink" title="陡峭视差贴图（viewDircection多次采样，得到更精确的视差）"></a>陡峭视差贴图（viewDircection多次采样，得到更精确的视差）</h3><p>一句话：上面的直接用高度h在viewDirection方向采样去模拟偏移p，不够精确，那么对viewDirection方向上做很多个layer的采样，通过每个采样点和真实高度相比较，直到找到第一个比真实高度低的采样点作为结果即可！<br>上面我们可以知道，这个p只是我们利用viewDir乘以高度得到的偏移，那么我们可以考虑在viewDir多采样几个长度，会得到若干深度，有些大于目标深度，有些小于，那么采样的个数我们把它叫做层数，层数越高就越能逼近真实值<br>而且这种情况你很容易知道，随着采样层数的增多，砖体上凹下去的横纹会渐渐消失(用1280测试过)，因为采样层数少了以后，高度相近的fragment（实际不相同）会最终偏移到同一个纹理坐标，导致横纹</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in VS_OUT &#123;</span><br><span class="line">    vec3 FragPos;</span><br><span class="line">    vec2 TexCoords;</span><br><span class="line">    vec3 TangentLightPos;</span><br><span class="line">    vec3 TangentViewPos;</span><br><span class="line">    vec3 TangentFragPos;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line">uniform sampler2D diffuseMap;</span><br><span class="line">uniform sampler2D normalMap;</span><br><span class="line">uniform sampler2D depthMap;</span><br><span class="line"></span><br><span class="line">uniform <span class="type">float</span> heightScale;</span><br><span class="line"></span><br><span class="line"><span class="function">vec2 <span class="title">ParallaxMapping</span><span class="params">(vec2 texCoords, vec3 viewDir)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// number of depth layers</span></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> minLayers = <span class="number">8</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> maxLayers = <span class="number">32</span>;</span><br><span class="line">    <span class="type">float</span> numLayers = <span class="built_in">mix</span>(maxLayers, minLayers, <span class="built_in">abs</span>(<span class="built_in">dot</span>(<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>), viewDir)));  </span><br><span class="line">    <span class="comment">// calculate the size of each layer</span></span><br><span class="line">    <span class="type">float</span> layerDepth = <span class="number">1.0</span> / numLayers;</span><br><span class="line">    <span class="comment">// depth of current layer</span></span><br><span class="line">    <span class="type">float</span> currentLayerDepth = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// the amount to shift the texture coordinates per layer (from vector P)</span></span><br><span class="line">    vec2 P = viewDir.xy / viewDir.z * heightScale; </span><br><span class="line">    vec2 deltaTexCoords = P / numLayers;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// get initial values</span></span><br><span class="line">    vec2  currentTexCoords     = texCoords;</span><br><span class="line">    <span class="type">float</span> currentDepthMapValue = <span class="built_in">texture</span>(depthMap, currentTexCoords).r;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span>(currentLayerDepth &lt; currentDepthMapValue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// shift texture coordinates along direction of P</span></span><br><span class="line">        currentTexCoords -= deltaTexCoords;</span><br><span class="line">        <span class="comment">// get depthmap value at current texture coordinates</span></span><br><span class="line">        currentDepthMapValue = <span class="built_in">texture</span>(depthMap, currentTexCoords).r;  </span><br><span class="line">        <span class="comment">// get depth of next layer</span></span><br><span class="line">        currentLayerDepth += layerDepth;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> currentTexCoords;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    <span class="comment">// offset texture coordinates with Parallax Mapping</span></span><br><span class="line">    vec3 viewDir = <span class="built_in">normalize</span>(fs_in.TangentViewPos - fs_in.TangentFragPos);</span><br><span class="line">    vec2 texCoords = fs_in.TexCoords;</span><br><span class="line">    </span><br><span class="line">    texCoords = <span class="built_in">ParallaxMapping</span>(fs_in.TexCoords,  viewDir);       </span><br><span class="line">    <span class="keyword">if</span>(texCoords.x &gt; <span class="number">1.0</span> || texCoords.y &gt; <span class="number">1.0</span> || texCoords.x &lt; <span class="number">0.0</span> || texCoords.y &lt; <span class="number">0.0</span>)</span><br><span class="line">        discard;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// obtain normal from normal map</span></span><br><span class="line">    vec3 normal = <span class="built_in">texture</span>(normalMap, texCoords).rgb;</span><br><span class="line">    normal = <span class="built_in">normalize</span>(normal * <span class="number">2.0</span> - <span class="number">1.0</span>);   </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// get diffuse color</span></span><br><span class="line">    vec3 color = <span class="built_in">texture</span>(diffuseMap, texCoords).rgb;</span><br><span class="line">    <span class="comment">// ambient</span></span><br><span class="line">    vec3 ambient = <span class="number">0.1</span> * color;</span><br><span class="line">    <span class="comment">// diffuse</span></span><br><span class="line">    vec3 lightDir = <span class="built_in">normalize</span>(fs_in.TangentLightPos - fs_in.TangentFragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    vec3 diffuse = diff * color;</span><br><span class="line">    <span class="comment">// specular    </span></span><br><span class="line">    vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">32.0</span>);</span><br><span class="line"></span><br><span class="line">    vec3 specular = <span class="built_in">vec3</span>(<span class="number">0.2</span>) * spec;</span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="视差遮蔽映射"><a href="#视差遮蔽映射" class="headerlink" title="视差遮蔽映射"></a>视差遮蔽映射</h3><p>一句话：相比较与陡峭视差映射，我们采用和真实高度最相近的两个layer线性差值得到最终结果<br>视差遮蔽映射(Parallax Occlusion Mapping)和陡峭视差映射的原则相同，但不是用触碰的第一个深度层的纹理坐标（本来的过程不是说：从最高layer每个采样点去比较，直到遇到第一个比他小的，然后就作为最终的偏移结果嘛），而是在触碰之前和之后这两个layer，在深度层之间进行一次线性插值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[...] <span class="comment">// steep parallax mapping code here</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get texture coordinates before collision (reverse operations)</span></span><br><span class="line">vec2 prevTexCoords = currentTexCoords + deltaTexCoords;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get depth after and before collision for linear interpolation</span></span><br><span class="line"><span class="type">float</span> afterDepth  = currentDepthMapValue - currentLayerDepth;</span><br><span class="line"><span class="type">float</span> beforeDepth = <span class="built_in">texture</span>(depthMap, prevTexCoords).r - currentLayerDepth + layerDepth;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interpolation of texture coordinates</span></span><br><span class="line"><span class="type">float</span> weight = afterDepth / (afterDepth - beforeDepth);</span><br><span class="line">vec2 finalTexCoords = prevTexCoords * weight + currentTexCoords * (<span class="number">1.0</span> - weight);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> finalTexCoords;</span><br></pre></td></tr></table></figure>

<h2 id="7-HDR高动态范围"><a href="#7-HDR高动态范围" class="headerlink" title="7 HDR高动态范围"></a>7 HDR高动态范围</h2><p>一句话：我们能做的是用一个不同的方程与/或曲线来转换这些HDR(渲染过程中的连读)值到LDR(真实渲染的亮度)值，从而给我们对于场景的亮度完全掌控，这就是之前说的色调变换，也是HDR渲染的最终步骤。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">useExposureOnlyWhenDark</span><span class="params">(vec3 hdrColor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">length</span>(hdrColor) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> exposure;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> gamma = <span class="number">2.2</span>;</span><br><span class="line">    vec3 hdrColor = <span class="built_in">texture</span>(hdrBuffer, TexCoords).rgb;</span><br><span class="line">    <span class="keyword">if</span>(hdr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// reinhard</span></span><br><span class="line">        <span class="comment">// vec3 result = hdrColor / (hdrColor + vec3(1.0));</span></span><br><span class="line">        <span class="comment">// exposure</span></span><br><span class="line">        <span class="comment">// vec3 result = vec3(1.0) - exp(-hdrColor * useExposureOnlyWhenDark(hdrColor));</span></span><br><span class="line">        vec3 result = <span class="built_in">vec3</span>(<span class="number">1.0</span>) - <span class="built_in">exp</span>(-hdrColor * <span class="built_in">useExposureOnlyWhenDark</span>(hdrColor));</span><br><span class="line">        <span class="comment">// vec3 result = vec3(1.0) - exp(-hdrColor * exposure);</span></span><br><span class="line">        <span class="comment">// also gamma correct while we&#x27;re at it       </span></span><br><span class="line">        result = <span class="built_in">pow</span>(result, <span class="built_in">vec3</span>(<span class="number">1.0</span> / gamma));</span><br><span class="line">        FragColor = <span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">// Reinhard色调映射</span></span><br><span class="line">		vec3 mapped = hdrColor / (hdrColor + <span class="built_in">vec3</span>(<span class="number">1.0</span>));</span><br><span class="line">		<span class="comment">// Gamma校正</span></span><br><span class="line">		mapped = <span class="built_in">pow</span>(mapped, <span class="built_in">vec3</span>(<span class="number">1.0</span> / gamma));</span><br><span class="line"></span><br><span class="line">        FragColor = <span class="built_in">vec4</span>(mapped, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="8-泛光"><a href="#8-泛光" class="headerlink" title="8 泛光"></a>8 泛光</h2><p>一句话：对于高亮的东西先取出来，然后blur掉，然后再和原来的combine得到泛光</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体算法流程：</span></span><br><span class="line"><span class="comment">// 1. 取出高亮：</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="comment">// 像这样对一个帧缓冲对象添加多个颜色或者深度缓冲对象，就是MRT技术(多渲染目标技术)</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) out vec4 FragColor;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) out vec4 BrightColor;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">...</span><br><span class="line">    <span class="comment">// check whether result is higher than some threshold, if so, output as bloom threshold color</span></span><br><span class="line">    <span class="type">float</span> brightness = <span class="built_in">dot</span>(result, <span class="built_in">vec3</span>(<span class="number">0.2126</span>, <span class="number">0.7152</span>, <span class="number">0.0722</span>));</span><br><span class="line">    <span class="keyword">if</span>(brightness &gt; <span class="number">1.0</span>)</span><br><span class="line">        BrightColor = <span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        BrightColor = <span class="built_in">vec4</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 高斯模糊</span></span><br><span class="line"><span class="comment">// 幸运的是，高斯方程有个非常巧妙的特性，它允许我们把二维方程分解为两个更小的方程：一个描述水平权重，另一个描述垂直权重。我们首先用水平权重在整个纹理上进行水平模糊，然后在经改变的纹理上进行垂直模糊。利用这个特性，结果是一样的，但是可以节省难以置信的性能，因为我们现在只需做32+32次采样，不再是1024了！这叫做两步高斯模糊。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">     vec2 tex_offset = <span class="number">1.0</span> / <span class="built_in">textureSize</span>(image, <span class="number">0</span>); <span class="comment">// gets size of single texel</span></span><br><span class="line">     vec3 result = <span class="built_in">texture</span>(image, TexCoords).rgb * weight[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">if</span>(horizontal)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">         &#123;</span><br><span class="line">            result += <span class="built_in">texture</span>(image, TexCoords + <span class="built_in">vec2</span>(tex_offset.x * i, <span class="number">0.0</span>)).rgb * weight[i];</span><br><span class="line">            result += <span class="built_in">texture</span>(image, TexCoords - <span class="built_in">vec2</span>(tex_offset.x * i, <span class="number">0.0</span>)).rgb * weight[i];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">         &#123;</span><br><span class="line">             result += <span class="built_in">texture</span>(image, TexCoords + <span class="built_in">vec2</span>(<span class="number">0.0</span>, tex_offset.y * i)).rgb * weight[i];</span><br><span class="line">             result += <span class="built_in">texture</span>(image, TexCoords - <span class="built_in">vec2</span>(<span class="number">0.0</span>, tex_offset.y * i)).rgb * weight[i];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     FragColor = <span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 混合起来：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> gamma = <span class="number">2.2</span>;</span><br><span class="line">    vec3 hdrColor = <span class="built_in">texture</span>(scene, TexCoords).rgb;      </span><br><span class="line">    vec3 bloomColor = <span class="built_in">texture</span>(bloomBlur, TexCoords).rgb;</span><br><span class="line">    <span class="keyword">if</span>(bloom)</span><br><span class="line">        hdrColor += bloomColor; <span class="comment">// additive blending</span></span><br><span class="line">    <span class="comment">// tone mapping</span></span><br><span class="line">    vec3 result = <span class="built_in">vec3</span>(<span class="number">1.0</span>) - <span class="built_in">exp</span>(-hdrColor * exposure);</span><br><span class="line">    <span class="comment">// also gamma correct while we&#x27;re at it       </span></span><br><span class="line">    result = <span class="built_in">pow</span>(result, <span class="built_in">vec3</span>(<span class="number">1.0</span> / gamma));</span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9-延迟着色法"><a href="#9-延迟着色法" class="headerlink" title="9 延迟着色法"></a>9 延迟着色法</h2><p>一句话：通常用的正向渲染(forward shading)对于每一个光源和每一个渲染片段都进行了迭代，计算量很大！而且大部分片段着色器输出之后会被之后的输出覆盖，很多时间浪费，于是我们把法向，镜像贴图颜色等等都先放到gBuffer,然后fragmentShader从gbuffer中读取数据渲染即可</p>
<p>有缺点：</p>
<ul>
<li>1 不能进行混合(Blending)，因为G缓冲中所有的数据都是从一个单独的片段中来的，而混合需要对多个片段的组合进行操作·</li>
<li>2 它迫使你对大部分场景的光照使用相同的光照算法<br>为了克服这些缺点(特别是混合)，我们通常分割我们的渲染器为两个部分：一个是延迟渲染的部分，另一个是专门为了混合或者其他不适合延迟渲染管线的着色器效果而设计的的正向渲染的部分(比如光照物体，需要gbuffer中的场景物体的深度，那么我们会把这个gbuffer的深度信息在渲染光照物体之前copy出来，然后渲染光照物体之前绑定，让光照物体有这些深度信息)。为了展示这是如何工作的，我们将会使用正向渲染器渲染光源为一个小立方体，因为光照立方体会需要一个特殊的着色器(会输出一个光照颜色)。</li>
</ul>
<p>延迟渲染一直被称赞的原因就是它能够渲染大量的光源而不消耗大量的性能。然而，延迟渲染它本身并不能支持非常大量的光源，因为我们仍然必须要对场景中每一个光源计算每一个片段的光照分量。真正让大量光源成为可能的是我们能够对延迟渲染管线引用的一个非常棒的优化：光体积(Light Volumes)（计算每个光源的可照明半径，仅渲染球体内部像素，超出部分不渲染）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform sampler2D gPosition;</span><br><span class="line">uniform sampler2D gNormal;</span><br><span class="line">uniform sampler2D gAlbedoSpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    vec3 Position;</span><br><span class="line">    vec3 Color;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> Linear;</span><br><span class="line">    <span class="type">float</span> Quadratic;</span><br><span class="line">    <span class="type">float</span> Radius;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NR_LIGHTS = <span class="number">32</span>;</span><br><span class="line">uniform Light lights[NR_LIGHTS];</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="comment">// retrieve data from gbuffer</span></span><br><span class="line">    vec3 FragPos = <span class="built_in">texture</span>(gPosition, TexCoords).rgb;</span><br><span class="line">    vec3 Normal = <span class="built_in">texture</span>(gNormal, TexCoords).rgb;</span><br><span class="line">    vec3 Diffuse = <span class="built_in">texture</span>(gAlbedoSpec, TexCoords).rgb;</span><br><span class="line">    <span class="type">float</span> Specular = <span class="built_in">texture</span>(gAlbedoSpec, TexCoords).a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// then calculate lighting as usual</span></span><br><span class="line">    vec3 lighting  = Diffuse * <span class="number">0.1</span>; <span class="comment">// hard-coded ambient component</span></span><br><span class="line">    vec3 viewDir  = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NR_LIGHTS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// calculate distance between light source and current fragment</span></span><br><span class="line">        <span class="comment">// 计算每个光源的可照明半径，仅渲染球体内部像素，超出部分不渲染</span></span><br><span class="line">        <span class="type">float</span> distance = <span class="built_in">length</span>(lights[i].Position - FragPos);</span><br><span class="line">        <span class="keyword">if</span>(distance &lt; lights[i].Radius)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// diffuse</span></span><br><span class="line">            vec3 lightDir = <span class="built_in">normalize</span>(lights[i].Position - FragPos);</span><br><span class="line">            vec3 diffuse = <span class="built_in">max</span>(<span class="built_in">dot</span>(Normal, lightDir), <span class="number">0.0</span>) * Diffuse * lights[i].Color;</span><br><span class="line">            <span class="comment">// specular</span></span><br><span class="line">            vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">            <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(Normal, halfwayDir), <span class="number">0.0</span>), <span class="number">16.0</span>);</span><br><span class="line">            vec3 specular = lights[i].Color * spec * Specular;</span><br><span class="line">            <span class="comment">// attenuation</span></span><br><span class="line">            <span class="type">float</span> attenuation = <span class="number">1.0</span> / (<span class="number">1.0</span> + lights[i].Linear * distance + lights[i].Quadratic * distance * distance);</span><br><span class="line">            diffuse *= attenuation;</span><br><span class="line">            specular *= attenuation;</span><br><span class="line">            lighting += diffuse + specular;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(lighting, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅仅是延迟着色法它本身(没有光体积)已经是一个很大的优化了，每个像素仅仅运行一个单独的片段着色器，然而对于正向渲染，我们通常会对一个像素运行多次片段着色器。当然，延迟渲染确实带来一些缺点：大内存开销，没有MSAA和混合(仍需要正向渲染的配合)。</p>
<h2 id="10-SSAO-sscreen-space-ambient-occlusion-屏幕空间环境光遮蔽"><a href="#10-SSAO-sscreen-space-ambient-occlusion-屏幕空间环境光遮蔽" class="headerlink" title="10 SSAO(sscreen-space ambient occlusion)屏幕空间环境光遮蔽"></a>10 SSAO(sscreen-space ambient occlusion)屏幕空间环境光遮蔽</h2><p>一句话：给环境光照加上一个遮蔽因子，决定环境光照的强弱，简单的来说，在凹下去的地方要暗一点，就这个需求，对！<br>算法核心：若一个点周围的深度都比他高，那么我们增加遮蔽因子，在目标周围的法向半球型附近随机采样即可。</p>
<p>很明显，渲染效果的质量和精度与我们采样的样本数量有直接关系。如果样本数量太低，渲染的精度会急剧减少，我们会得到一种叫做波纹(Banding)的效果；如果它太高了，反而会影响性能。我们可以通过引入随机性到采样核心(Sample Kernel)的采样中从而减少样本的数目。通过随机旋转采样核心，我们能在有限样本数量中得到高质量的结果。然而这仍然会有一定的麻烦，因为随机性引入了一个很明显的噪声图案，我们将需要通过模糊结果来修复这一问题。</p>
<p>因为核心中一半的样本都会在墙这个几何体上。下面这幅图展示了孤岛危机的SSAO，它清晰地展示了这种灰蒙蒙的感觉，由于这个原因，我们将不会使用球体的采样核心，而使用一个沿着表面法向量的半球体采样核心。通过在法向半球体(Normal-oriented Hemisphere)周围采样，我们将不会考虑到片段底部的几何体.它消除了环境光遮蔽灰蒙蒙的感觉，从而产生更真实的结果。</p>
<p>如下是大体流程以及shader中的某些实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// render循环：</span></span><br><span class="line">        <span class="comment">// 1. geometry pass: render scene&#x27;s geometry/color data into gbuffer</span></span><br><span class="line">        <span class="comment">// 把ssao shader需要的信息先放到gbuffer里面，包括：</span></span><br><span class="line">        <span class="comment">// 逐片段位置向量</span></span><br><span class="line">        <span class="comment">// 逐片段的法线向量</span></span><br><span class="line">        <span class="comment">// 逐片段的反射颜色</span></span><br><span class="line">        <span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line">        <span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, gBuffer);</span><br><span class="line">            ...</span><br><span class="line">            backpack.<span class="built_in">Draw</span>(shaderGeometryPass);</span><br><span class="line">        <span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. generate SSAO texture</span></span><br><span class="line">        <span class="comment">// ------------------------</span></span><br><span class="line">        <span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, ssaoFBO);</span><br><span class="line">            <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">            shaderSSAO.<span class="built_in">use</span>();</span><br><span class="line">            <span class="comment">// Send kernel + rotation，将循环外部生成好的kernel设置到shader里面 </span></span><br><span class="line">            <span class="comment">// 采样核心 用来旋转采样核心的随机旋转矢量 在这一步送入</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i)</span><br><span class="line">                shaderSSAO.<span class="built_in">setVec3</span>(<span class="string">&quot;samples[&quot;</span> + std::<span class="built_in">to_string</span>(i) + <span class="string">&quot;]&quot;</span>, ssaoKernel[i]);</span><br><span class="line">            shaderSSAO.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line">            <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">            <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, gPosition);</span><br><span class="line">            <span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line">            <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, gNormal);</span><br><span class="line">            <span class="built_in">glActiveTexture</span>(GL_TEXTURE2);</span><br><span class="line">            <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, noiseTexture);</span><br><span class="line">            <span class="built_in">renderQuad</span>();</span><br><span class="line">        <span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. blur SSAO texture to remove noise</span></span><br><span class="line">        <span class="comment">// ------------------------------------</span></span><br><span class="line">        <span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, ssaoBlurFBO);</span><br><span class="line">            <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">            <span class="comment">// 简单的对产生的ssao纹理进行一个模糊，为了创建一个光滑的环境遮蔽结果，我们需要模糊环境遮蔽纹理。</span></span><br><span class="line">            shaderSSAOBlur.<span class="built_in">use</span>();</span><br><span class="line">            <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">            <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, ssaoColorBuffer);</span><br><span class="line">            <span class="built_in">renderQuad</span>();</span><br><span class="line">        <span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. lighting pass: traditional deferred Blinn-Phong lighting with added screen-space ambient occlusion</span></span><br><span class="line">        <span class="comment">// -----------------------------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">        shaderLightingPass.<span class="built_in">use</span>();</span><br><span class="line">        <span class="comment">// send light relevant uniforms</span></span><br><span class="line">        glm::vec3 lightPosView = glm::<span class="built_in">vec3</span>(camera.<span class="built_in">GetViewMatrix</span>() * glm::<span class="built_in">vec4</span>(lightPos, <span class="number">1.0</span>));</span><br><span class="line">        shaderLightingPass.<span class="built_in">setVec3</span>(<span class="string">&quot;light.Position&quot;</span>, lightPosView);</span><br><span class="line">        shaderLightingPass.<span class="built_in">setVec3</span>(<span class="string">&quot;light.Color&quot;</span>, lightColor);</span><br><span class="line">        <span class="comment">// Update attenuation parameters</span></span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> linear    = <span class="number">0.09f</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> quadratic = <span class="number">0.032f</span>;</span><br><span class="line">        shaderLightingPass.<span class="built_in">setFloat</span>(<span class="string">&quot;light.Linear&quot;</span>, linear);</span><br><span class="line">        shaderLightingPass.<span class="built_in">setFloat</span>(<span class="string">&quot;light.Quadratic&quot;</span>, quadratic);</span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, gPosition);</span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, gNormal);</span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE2);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, gAlbedo);</span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE3); <span class="comment">// add extra SSAO texture to lighting pass</span></span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, ssaoColorBufferBlur);</span><br><span class="line">        <span class="built_in">renderQuad</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------- phase1 gbuffer获取纹理，法向，反射率给ssao shader</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) out vec3 gPosition;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) out vec3 gNormal;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">2</span>) out vec3 gAlbedo;</span><br><span class="line"></span><br><span class="line">in vec2 TexCoords;</span><br><span class="line">in vec3 FragPos;</span><br><span class="line">in vec3 Normal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">// store the fragment position vector in the first gbuffer texture</span></span><br><span class="line">    gPosition = FragPos;</span><br><span class="line">    <span class="comment">// also store the per-fragment normals into the gbuffer</span></span><br><span class="line">    gNormal = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="comment">// and the diffuse per-fragment color</span></span><br><span class="line">    gAlbedo.rgb = <span class="built_in">vec3</span>(<span class="number">0.95</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------- phase2 ssao 生成阶段</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out <span class="type">float</span> FragColor;</span><br><span class="line"></span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别用多纹理附件将需要的数据bind进来</span></span><br><span class="line">uniform sampler2D gPosition;</span><br><span class="line">uniform sampler2D gNormal;</span><br><span class="line">uniform sampler2D texNoise;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染循环前就设置好</span></span><br><span class="line">uniform vec3 samples[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// parameters (you&#x27;d probably want to use them as uniforms to more easily tweak the effect)</span></span><br><span class="line"><span class="type">int</span> kernelSize = <span class="number">64</span>; <span class="comment">// 减小然后去掉模糊，我们看一下ssao带来的波纹</span></span><br><span class="line"><span class="type">float</span> radius = <span class="number">0.5</span>;</span><br><span class="line"><span class="type">float</span> bias = <span class="number">0.025</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕的平铺噪声纹理会根据屏幕分辨率除以噪声大小的值来决定</span></span><br><span class="line"><span class="comment">// tile noise texture over screen based on screen dimensions divided by noise size</span></span><br><span class="line"><span class="type">const</span> vec2 noiseScale = <span class="built_in">vec2</span>(<span class="number">800.0</span>/<span class="number">4.0</span>, <span class="number">600.0</span>/<span class="number">4.0</span>); </span><br><span class="line"></span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get input for SSAO algorithm</span></span><br><span class="line">    vec3 fragPos = <span class="built_in">texture</span>(gPosition, TexCoords).xyz;</span><br><span class="line">    vec3 normal = <span class="built_in">normalize</span>(<span class="built_in">texture</span>(gNormal, TexCoords).rgb);</span><br><span class="line">    vec3 randomVec = <span class="built_in">normalize</span>(<span class="built_in">texture</span>(texNoise, TexCoords * noiseScale).xyz);</span><br><span class="line">    <span class="comment">// create TBN change-of-basis matrix: from tangent-space to view-space</span></span><br><span class="line">    <span class="comment">// 由于对每个表面法线方向生成采样核心非常困难，也不合实际，我们将在切线空间(Tangent Space)内生成采样核心，法向量将指向正z方向。</span></span><br><span class="line">    vec3 tangent = <span class="built_in">normalize</span>(randomVec - normal * <span class="built_in">dot</span>(randomVec, normal));</span><br><span class="line">    vec3 bitangent = <span class="built_in">cross</span>(normal, tangent);</span><br><span class="line">    mat3 TBN = <span class="built_in">mat3</span>(tangent, bitangent, normal);</span><br><span class="line">    <span class="comment">// iterate over the sample kernel and calculate occlusion factor</span></span><br><span class="line">    <span class="type">float</span> occlusion = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; kernelSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// get sample position</span></span><br><span class="line">        vec3 samplePos = TBN * samples[i]; <span class="comment">// from tangent to view-space</span></span><br><span class="line">        samplePos = fragPos + samplePos * radius; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// project sample position (to sample texture) (to get position on screen/texture)</span></span><br><span class="line">        vec4 offset = <span class="built_in">vec4</span>(samplePos, <span class="number">1.0</span>);</span><br><span class="line">        offset = projection * offset; <span class="comment">// from view to clip-space</span></span><br><span class="line">        offset.xyz /= offset.w; <span class="comment">// perspective divide</span></span><br><span class="line">        offset.xyz = offset.xyz * <span class="number">0.5</span> + <span class="number">0.5</span>; <span class="comment">// transform to range 0.0 - 1.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// get sample depth</span></span><br><span class="line">        <span class="type">float</span> sampleDepth = <span class="built_in">texture</span>(gPosition, offset.xy).z; <span class="comment">// get depth value of kernel sample</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 。当检测一个靠近表面边缘的片段时，它将会考虑测试表面之下的表面的深度值；这些值将会(不正确地)影响遮蔽因子。</span></span><br><span class="line">        <span class="comment">// range check &amp; accumulate, 在这里根据它非常光滑地在第一和第二个参数范围内插值了第三个参数。如果深度差因此最终取值在radius之间，</span></span><br><span class="line">        <span class="comment">// 它们的值将会光滑地根据下面这个曲线插值在0.0和1.0之间</span></span><br><span class="line">        <span class="type">float</span> rangeCheck = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, radius / <span class="built_in">abs</span>(fragPos.z - sampleDepth));</span><br><span class="line">        occlusion += (sampleDepth &gt;= samplePos.z + bias ? <span class="number">1.0</span> : <span class="number">0.0</span>) * rangeCheck;           </span><br><span class="line">    &#125;</span><br><span class="line">    occlusion = <span class="number">1.0</span> - (occlusion / kernelSize);</span><br><span class="line">    </span><br><span class="line">    FragColor = occlusion;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------- phase3 ssao 由于重复的纹理噪声（相同的环境因子按条纹出现），于是有模糊(平滑)阶段</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out <span class="type">float</span> FragColor;</span><br><span class="line"></span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform sampler2D ssaoInput;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec2 texelSize = <span class="number">1.0</span> / <span class="built_in">vec2</span>(<span class="built_in">textureSize</span>(ssaoInput, <span class="number">0</span>));</span><br><span class="line">    <span class="type">float</span> result = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">-2</span>; x &lt; <span class="number">2</span>; ++x) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">-2</span>; y &lt; <span class="number">2</span>; ++y) </span><br><span class="line">        &#123;</span><br><span class="line">            vec2 offset = <span class="built_in">vec2</span>(<span class="built_in">float</span>(x), <span class="built_in">float</span>(y)) * texelSize;</span><br><span class="line">            result += <span class="built_in">texture</span>(ssaoInput, TexCoords + offset).r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FragColor = result / (<span class="number">4.0</span> * <span class="number">4.0</span>);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------- phase4 bling phon光照模型</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform sampler2D gPosition;</span><br><span class="line">uniform sampler2D gNormal;</span><br><span class="line">uniform sampler2D gAlbedo;</span><br><span class="line">uniform sampler2D ssao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    vec3 Position;</span><br><span class="line">    vec3 Color;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> Linear;</span><br><span class="line">    <span class="type">float</span> Quadratic;</span><br><span class="line">&#125;;</span><br><span class="line">uniform Light light;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">    <span class="comment">// retrieve data from gbuffer</span></span><br><span class="line">    vec3 FragPos = <span class="built_in">texture</span>(gPosition, TexCoords).rgb;</span><br><span class="line">    vec3 Normal = <span class="built_in">texture</span>(gNormal, TexCoords).rgb;</span><br><span class="line">    vec3 Diffuse = <span class="built_in">texture</span>(gAlbedo, TexCoords).rgb;</span><br><span class="line">    <span class="type">float</span> AmbientOcclusion = <span class="built_in">texture</span>(ssao, TexCoords).r;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// then calculate lighting as usual</span></span><br><span class="line">    vec3 ambient = <span class="built_in">vec3</span>(<span class="number">0.3</span> * Diffuse * AmbientOcclusion);</span><br><span class="line">    vec3 lighting  = ambient; </span><br><span class="line">    vec3 viewDir  = <span class="built_in">normalize</span>(-FragPos); <span class="comment">// viewpos is (0.0.0)</span></span><br><span class="line">    <span class="comment">// diffuse</span></span><br><span class="line">    vec3 lightDir = <span class="built_in">normalize</span>(light.Position - FragPos);</span><br><span class="line">    vec3 diffuse = <span class="built_in">max</span>(<span class="built_in">dot</span>(Normal, lightDir), <span class="number">0.0</span>) * Diffuse * light.Color;</span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    vec3 halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(Normal, halfwayDir), <span class="number">0.0</span>), <span class="number">8.0</span>);</span><br><span class="line">    vec3 specular = light.Color * spec;</span><br><span class="line">    <span class="comment">// attenuation</span></span><br><span class="line">    <span class="type">float</span> distance = <span class="built_in">length</span>(light.Position - FragPos);</span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (<span class="number">1.0</span> + light.Linear * distance + light.Quadratic * distance * distance);</span><br><span class="line">    diffuse *= attenuation;</span><br><span class="line">    specular *= attenuation;</span><br><span class="line">    lighting += diffuse + specular;</span><br><span class="line"></span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(lighting, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>xychen5
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="https://xychen5.github.io/2022/05/21/lighting/" title="lighting - 一些光照模型以及高级光照">https://xychen5.github.io/2022/05/21/lighting/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/render/" rel="tag"># render</a>
              <a href="/tags/gl/" rel="tag"># gl</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/05/21/renderPipeline/" rel="prev" title="renderPipeline - 一个三维场景的渲染过程">
                  <i class="fa fa-chevron-left"></i> renderPipeline - 一个三维场景的渲染过程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/05/30/lcBFS1/" rel="next" title="lcBFS1">
                  lcBFS1 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xychen5</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
